\hypertarget{mtk__grad__1d_8cc_source}{\section{mtk\+\_\+grad\+\_\+1d.\+cc}
\label{mtk__grad__1d_8cc_source}\index{src/mtk\+\_\+grad\+\_\+1d.\+cc@{src/mtk\+\_\+grad\+\_\+1d.\+cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed, unless these modifications are made through the project's GitHub}
00025 \textcolor{comment}{page: http://www.csrc.sdsu.edu/mtk. Documentation related to said modifications}
00026 \textcolor{comment}{should be developed and included in any deliverable.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00029 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00030 \textcolor{comment}{}
00031 \textcolor{comment}{3. Redistributions in binary form must reproduce the above copyright notice,}
00032 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00033 \textcolor{comment}{other materials provided with the distribution.}
00034 \textcolor{comment}{}
00035 \textcolor{comment}{4. Usage of the binary form on proprietary applications shall require explicit}
00036 \textcolor{comment}{prior written permission from the the copyright holders, and due credit should}
00037 \textcolor{comment}{be given to the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{5. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 
00067 \textcolor{preprocessor}{#ifdef MTK\_VERBOSE\_WEIGHTS}
00068 \textcolor{preprocessor}{#include <fstream>}
00069 \textcolor{preprocessor}{#endif}
00070 
00071 \textcolor{preprocessor}{#include <limits>}
00072 \textcolor{preprocessor}{#include <algorithm>}
00073 
00074 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00075 
00076 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00077 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00078 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00079 
00080 \textcolor{preprocessor}{#include "\hyperlink{mtk__grad__1d_8h}{mtk\_grad\_1d.h}"}
00081 
00082 \textcolor{keyword}{namespace }\hyperlink{namespacemtk}{mtk} \{
00083 
\hypertarget{mtk__grad__1d_8cc_source_l00084}{}\hyperlink{namespacemtk_a3f546b8a3743b8719db17e33f2d7ef7f}{00084} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Grad1D}{mtk::Grad1D} &in) \{
00085 
00086   \textcolor{keywordtype}{int} output\_precision\{4\};
00087   \textcolor{keywordtype}{int} output\_width\{8\};
00088 
00090 
00091   stream << \textcolor{stringliteral}{"Order of accuracy: "} << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[0] << std::endl;
00092 
00094 
00095   stream << \textcolor{stringliteral}{"Interior stencil: "} << std::endl;
00096   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00097     stream << std::setprecision(output\_precision) <<
00098         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{charliteral}{' '};
00099   \}
00100   stream << std::endl;
00101 
00103 
00104   stream << \textcolor{stringliteral}{"Weights:"} << std::endl;
00105   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00106     stream << std::setprecision(output\_precision) <<
00107         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{charliteral}{' '};
00108   \}
00109   stream << std::endl;
00110 
00112 
00113   \textcolor{keywordtype}{int} offset\{2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1\};
00114   \textcolor{keywordtype}{int} mm \{\};
00115   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
00116     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Grad1D_abe15c1ffd9dfaba1a65f4f0e096287ce}{num\_bndy\_approxs\_} ; ++ii) \{
00117       stream << \textcolor{stringliteral}{"Mimetic boundary row "} << ii + 1 << \textcolor{stringliteral}{":"} << std::endl;
00118       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_}; jj++) \{
00119         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + (mm)];
00120         stream << std::setprecision(output\_precision) <<
00121         std::setw(output\_width) << value << \textcolor{charliteral}{' '};
00122         mm++;
00123       \}
00124       stream << std::endl;
00125       stream << \textcolor{stringliteral}{"Sum of elements in row "} << ii + 1 << \textcolor{stringliteral}{": "} <<
00126         in.\hyperlink{classmtk_1_1Grad1D_ab8858a35339ed7036083d25b23293737}{sums\_rows\_mim\_bndy\_}[ii];
00127       stream << std::endl;
00128     \}
00129   \} \textcolor{keywordflow}{else} \{
00130     stream << std::setprecision(output\_precision) <<
00131         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] << \textcolor{charliteral}{' '};
00132     stream << std::setprecision(output\_precision) <<
00133         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] << \textcolor{charliteral}{' '};
00134     stream << std::setprecision(output\_precision) <<
00135         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2] << \textcolor{charliteral}{' '};
00136     stream << std::endl;
00137   \}
00138 
00139   \textcolor{keywordflow}{return} stream;
00140 \}
00141 \}
00142 
\hypertarget{mtk__grad__1d_8cc_source_l00143}{}\hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{00143} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}():
00144   order\_accuracy\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00145   dim\_null\_(),
00146   num\_bndy\_approxs\_(),
00147   num\_bndy\_coeffs\_(),
00148   gradient\_length\_(),
00149   minrow\_(),
00150   row\_(),
00151   coeffs\_interior\_(),
00152   prem\_apps\_(),
00153   weights\_crs\_(),
00154   weights\_cbs\_(),
00155   mim\_bndy\_(),
00156   gradient\_(),
00157   sums\_rows\_mim\_bndy\_(),
00158   mimetic\_threshold\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}) \{\}
00159 
\hypertarget{mtk__grad__1d_8cc_source_l00160}{}\hyperlink{classmtk_1_1Grad1D_a5708bcb61bde3f7f3a4ddede191d82a4}{00160} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Grad1D}{Grad1D} &grad):
00161   order\_accuracy\_(grad.order\_accuracy\_),
00162   dim\_null\_(grad.dim\_null\_),
00163   num\_bndy\_approxs\_(grad.num\_bndy\_approxs\_),
00164   num\_bndy\_coeffs\_(grad.num\_bndy\_coeffs\_),
00165   gradient\_length\_(grad.gradient\_length\_),
00166   minrow\_(grad.minrow\_),
00167   row\_(grad.row\_),
00168   coeffs\_interior\_(grad.coeffs\_interior\_),
00169   prem\_apps\_(grad.prem\_apps\_),
00170   weights\_crs\_(grad.weights\_crs\_),
00171   weights\_cbs\_(grad.weights\_cbs\_),
00172   mim\_bndy\_(grad.mim\_bndy\_),
00173   gradient\_(grad.gradient\_),
00174   sums\_rows\_mim\_bndy\_(grad.sums\_rows\_mim\_bndy\_),
00175   mimetic\_threshold\_(grad.mimetic\_threshold\_) \{\}
00176 
\hypertarget{mtk__grad__1d_8cc_source_l00177}{}\hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{00177} \hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{mtk::Grad1D::~Grad1D}() \{
00178 
00179   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00180   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00181 
00182   \textcolor{keyword}{delete}[] prem\_apps\_;
00183   prem\_apps\_ = \textcolor{keyword}{nullptr};
00184 
00185   \textcolor{keyword}{delete}[] weights\_crs\_;
00186   weights\_crs\_ = \textcolor{keyword}{nullptr};
00187 
00188   \textcolor{keyword}{delete}[] weights\_cbs\_;
00189   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00190 
00191   \textcolor{keyword}{delete}[] mim\_bndy\_;
00192   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00193 
00194   \textcolor{keyword}{delete}[] gradient\_;
00195   gradient\_ = \textcolor{keyword}{nullptr};
00196 \}
00197 
\hypertarget{mtk__grad__1d_8cc_source_l00198}{}\hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{00198} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{mtk::Grad1D::ConstructGrad1D}(\textcolor{keywordtype}{int} order\_accuracy, 
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} mimetic\_threshold) \{
00199 
00200 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00201   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00202   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00203   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00204                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00205 
00206   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
00207     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is high."} << std::endl;
00208   \}
00209 
00210   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;
00211   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;
00212 \textcolor{preprocessor}{  #endif}
00213 
00214   order\_accuracy\_ = order\_accuracy;
00215   mimetic\_threshold\_ = mimetic\_threshold;
00216 
00218   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00219 
00220 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00221   \textcolor{keywordflow}{if} (!abort\_construction) \{
00222     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;
00223     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00224     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00225   \}
00226 \textcolor{preprocessor}{  #endif}
00227 
00228   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00229   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00230 
00231   dim\_null\_ = order\_accuracy\_/2 - 1;
00232 
00233   num\_bndy\_approxs\_ = dim\_null\_ + 1;
00234 
00235 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00236   num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00237 \textcolor{preprocessor}{  #else}
00238   num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00239 \textcolor{preprocessor}{  #endif}
00240 
00242 
00243   \textcolor{comment}{// For this we will follow recommendations given in:}
00244   \textcolor{comment}{//}
00245   \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00246   \textcolor{comment}{//}
00247   \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00248   \textcolor{comment}{// following (MATLAB) pseudo-code:}
00249   \textcolor{comment}{//}
00250   \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00251   \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00252   \textcolor{comment}{//}
00253   \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00254   \textcolor{comment}{//}
00255   \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00256   \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00257   \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00258   \textcolor{comment}{// (west boundary).}
00259 
00260   \textcolor{comment}{// In the case of the gradient, the first Vandermonde system has a unique}
00261   \textcolor{comment}{// solution for the case of second-order-accuracy. Ergo, the Vandermonde}
00262   \textcolor{comment}{// matrix used to assemble said system, will have an empty null-space.}
00263 
00264   \textcolor{comment}{// Therefore, we only compute a rational basis for the case of order higher}
00265   \textcolor{comment}{// than second.}
00266 
00267   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00268 
00269     abort\_construction = ComputeRationalBasisNullSpace();
00270 
00271 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00272     \textcolor{keywordflow}{if} (!abort\_construction) \{
00273       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;
00274       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00275       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00276     \}
00277 \textcolor{preprocessor}{    #endif}
00278   \}
00279 
00281   abort\_construction = ComputePreliminaryApproximations();
00282 
00283 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00284   \textcolor{keywordflow}{if} (!abort\_construction) \{
00285     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;
00286     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00287     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00288   \}
00289 \textcolor{preprocessor}{  #endif}
00290 
00292   abort\_construction = ComputeWeights();
00293 
00294 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00295   \textcolor{keywordflow}{if} (!abort\_construction) \{
00296     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;
00297     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00298     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00299   \}
00300 \textcolor{preprocessor}{  #endif}
00301 
00303   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00304 
00305     abort\_construction = ComputeStencilBoundaryGrid();
00306 
00307 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00308     \textcolor{keywordflow}{if} (!abort\_construction) \{
00309       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;
00310       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00311       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00312     \}
00313 \textcolor{preprocessor}{    #endif}
00314   \}
00315 
00317 
00318   \textcolor{comment}{// Once we have the following three collections of data:}
00319   \textcolor{comment}{//   (a) the coefficients for the interior,}
00320   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00321   \textcolor{comment}{//   (c) and the weights (if it applies),}
00322   \textcolor{comment}{// we will store everything in the output array:}
00323 
00324   abort\_construction = AssembleOperator();
00325 
00326 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00327   \textcolor{keywordflow}{if} (!abort\_construction) \{
00328     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;
00329     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00330     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00331   \}
00332 \textcolor{preprocessor}{  #endif}
00333 
00334   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00335 \}
00336 
\hypertarget{mtk__grad__1d_8cc_source_l00337}{}\hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{00337} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{mtk::Grad1D::num\_bndy\_coeffs}()\textcolor{keyword}{ const }\{
00338 
00339   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00340 \}
00341 
\hypertarget{mtk__grad__1d_8cc_source_l00342}{}\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{00342} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{mtk::Grad1D::coeffs\_interior}()\textcolor{keyword}{ const }\{
00343 
00344   \textcolor{keywordflow}{return} coeffs\_interior\_;
00345 \}
00346 
\hypertarget{mtk__grad__1d_8cc_source_l00347}{}\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{00347} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{mtk::Grad1D::weights\_crs}()\textcolor{keyword}{ const }\{
00348 
00349   \textcolor{keywordflow}{return} weights\_crs\_;
00350 \}
00351 
\hypertarget{mtk__grad__1d_8cc_source_l00352}{}\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{00352} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{mtk::Grad1D::weights\_cbs}()\textcolor{keyword}{ const }\{
00353 
00354   \textcolor{keywordflow}{return} weights\_cbs\_;
00355 \}
00356 
\hypertarget{mtk__grad__1d_8cc_source_l00357}{}\hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{00357} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{mtk::Grad1D::mim\_bndy}()\textcolor{keyword}{ const }\{
00358 
00359   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} xx(dim\_null\_ + 1, 3*order\_accuracy\_/2);
00360 
00361   \textcolor{keyword}{auto} counter = 0;
00362   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_ + 1; ++ii) \{
00363     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < 3*order\_accuracy\_/2; ++jj) \{
00364       xx.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj, gradient\_[2*order\_accuracy\_ + 1 + counter]);
00365       counter++;
00366     \}
00367   \}
00368 
00369   \textcolor{keywordflow}{return} xx;
00370 \}
00371 
\hypertarget{mtk__grad__1d_8cc_source_l00372}{}\hyperlink{classmtk_1_1Grad1D_ab1c580e5e7f6fad9a0f643b48d3e0e55}{00372} std::vector<mtk::Real> \hyperlink{classmtk_1_1Grad1D_ab1c580e5e7f6fad9a0f643b48d3e0e55}{mtk::Grad1D::sums\_rows\_mim\_bndy}()\textcolor{keyword}{ const }\{
00373 
00374   \textcolor{keywordflow}{return} sums\_rows\_mim\_bndy\_;
00375 \}
00376 
\hypertarget{mtk__grad__1d_8cc_source_l00377}{}\hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{00377} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} west,
00378                                                   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} east,
00379                                                   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00380 
00381   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00382 
00383 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00384   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(east < west, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00385   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00386   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00387 \textcolor{preprocessor}{  #endif}
00388 
00389   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} delta\_x = (east - west)/((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) num\_cells\_x);
00390 
00391   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/delta\_x\};
00392 
00393   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00394   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00395   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00396   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00397 
00398   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00399   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00400 
00402 
00403   \textcolor{keyword}{auto} ee\_index = 0;
00404   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00405     \textcolor{keyword}{auto} cc = 0;
00406     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00407       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00408         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00409       \} \textcolor{keywordflow}{else} \{
00410         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00411                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00412         cc++;
00413       \}
00414     \}
00415   \}
00416 
00418 
00419   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00420     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00421     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00422       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00423     \}
00424   \}
00425 
00427 
00428   ee\_index = 0;
00429   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00430     \textcolor{keyword}{auto} cc = 0;
00431     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00432       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00433         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00434       \} \textcolor{keywordflow}{else} \{
00435         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00436                      -gradient\_[2*order\_accuracy\_ + 1 +
00437 ee\_index++]*inv\_delta\_x);
00438         cc++;
00439       \}
00440      \}
00441   \}
00442 
00443   \textcolor{keywordflow}{return} out;
00444 \}
00445 
\hypertarget{mtk__grad__1d_8cc_source_l00446}{}\hyperlink{classmtk_1_1Grad1D_a871a3b31e257b04d5e303b3211df3a73}{00446} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
00447   \textcolor{keyword}{const} \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid)\textcolor{keyword}{ const }\{
00448 
00449   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00450 
00451 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00452   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00453   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00454 \textcolor{preprocessor}{  #endif}
00455 
00456   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00457 
00458   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00459   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00460   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00461   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00462 
00463   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00464   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00465 
00467 
00468   \textcolor{keyword}{auto} ee\_index = 0;
00469   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00470     \textcolor{keyword}{auto} cc = 0;
00471     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00472       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00473         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00474       \} \textcolor{keywordflow}{else} \{
00475         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00476                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00477         cc++;
00478       \}
00479     \}
00480   \}
00481 
00483 
00484   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00485     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00486     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00487       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00488     \}
00489   \}
00490 
00492 
00493   ee\_index = 0;
00494   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00495     \textcolor{keyword}{auto} cc = 0;
00496     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00497       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00498         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00499       \} \textcolor{keywordflow}{else} \{
00500         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00501                     -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00502         cc++;
00503       \}
00504      \}
00505   \}
00506 
00507   \textcolor{keywordflow}{return} out;
00508 \}
00509 
\hypertarget{mtk__grad__1d_8cc_source_l00510}{}\hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{00510} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{mtk::Grad1D::ReturnAsDimensionlessDenseMatrix}
      (
00511   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00512 
00513   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00514 
00515 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00516   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00517   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00518 \textcolor{preprocessor}{  #endif}
00519 
00520   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00521   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00522   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00523   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00524 
00525   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00526   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00527 
00529 
00530   \textcolor{keyword}{auto} ee\_index = 0;
00531   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00532     \textcolor{keyword}{auto} cc = 0;
00533     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00534       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00535         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00536       \} \textcolor{keywordflow}{else} \{
00537         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00538                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00539         cc++;
00540       \}
00541     \}
00542   \}
00543 
00545 
00546   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00547     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00548     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00549       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]);
00550     \}
00551   \}
00552 
00554 
00555   ee\_index = 0;
00556   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00557     \textcolor{keyword}{auto} cc = 0;
00558     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00559       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00560         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00561       \} \textcolor{keywordflow}{else} \{
00562         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00563                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00564         cc++;
00565       \}
00566      \}
00567   \}
00568 
00569   \textcolor{keywordflow}{return} out;
00570 \}
00571 
\hypertarget{mtk__grad__1d_8cc_source_l00572}{}\hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{00572} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{mtk::Grad1D::ComputeStencilInteriorGrid}() \{
00573 
00575 
00576   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00577 
00578   \textcolor{keywordflow}{try} \{
00579     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00580   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00581     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00582       std::endl;
00583     std::cerr << memory\_allocation\_exception.what() << std::endl;
00584   \}
00585   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00586 
00587 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00588   pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00589 \textcolor{preprocessor}{  #else}
00590   pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00591 \textcolor{preprocessor}{  #endif}
00592 
00593   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00594     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00595   \}
00596 
00597 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00598   std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00599   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00600     std::cout << std::setw(12) << pp[ii];
00601   \}
00602   std::cout << std::endl << std::endl;
00603 \textcolor{preprocessor}{  #endif}
00604 
00606 
00607   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00608 
00609   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,order\_accuracy\_,order\_accuracy\_,transpose);
00610 
00611 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00612   std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00613   std::cout << vander\_matrix << std::endl << std::endl;
00614 \textcolor{preprocessor}{  #endif}
00615 
00617 
00618   \textcolor{keywordflow}{try} \{
00619     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00620   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00621     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00622       std::endl;
00623     std::cerr << memory\_allocation\_exception.what() << std::endl;
00624   \}
00625   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00626 \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00627 
00628   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00629 
00630 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00631   std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00632   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00633     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00634   \}
00635   std::cout << std::endl;
00636 \textcolor{preprocessor}{  #endif}
00637 
00639 
00640   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00641                                                 coeffs\_interior\_)\};
00642 
00643 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00644   \textcolor{keywordflow}{if} (!info) \{
00645     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00646     std::cout << std::endl;
00647   \}
00648   \textcolor{keywordflow}{else} \{
00649     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00650     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00651     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00652   \}
00653 \textcolor{preprocessor}{  #endif}
00654 
00655 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00656   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00657   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00658     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00659   \}
00660   std::cout << std::endl << std::endl;
00661 \textcolor{preprocessor}{  #endif}
00662 
00663   \textcolor{keyword}{delete} [] pp;
00664   pp = \textcolor{keyword}{nullptr};
00665 
00666   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00667 \}
00668 
\hypertarget{mtk__grad__1d_8cc_source_l00669}{}\hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{00669} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{mtk::Grad1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00670 
00672 
00673   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00674 
00675   \textcolor{keywordflow}{try} \{
00676     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00677   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00678     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00679       std::endl;
00680     std::cerr << memory\_allocation\_exception.what() << std::endl;
00681   \}
00682   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00683 
00684 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00685   gg[1] = 1.0/2.0;
00686 \textcolor{preprocessor}{  #else}
00687   gg[1] = 1.0f/2.0f;
00688 \textcolor{preprocessor}{  #endif}
00689   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00690     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00691   \}
00692 
00693 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00694   std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00695   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00696     std::cout << std::setw(12) << gg[ii];
00697   \}
00698   std::cout << std::endl << std::endl;
00699 \textcolor{preprocessor}{  #endif}
00700 
00702 
00703   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00704 
00705   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00706 
00707 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00708   std::cout << \textcolor{stringliteral}{"aa\_west\_t ="} << std::endl;
00709   std::cout << aa\_west\_t << std::endl;
00710 \textcolor{preprocessor}{  #endif}
00711 
00713 
00714   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (aa\_west\_t));
00715 
00716 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00717   std::cout << \textcolor{stringliteral}{"qq\_t = "} << std::endl;
00718   std::cout << qq\_t << std::endl;
00719 \textcolor{preprocessor}{  #endif}
00720 
00722 
00723   \textcolor{keywordtype}{int} kk\_num\_rows\{num\_bndy\_coeffs\_\};
00724   \textcolor{keywordtype}{int} kk\_num\_cols\{dim\_null\_\};
00725 
00726   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} kk(kk\_num\_rows, kk\_num\_cols);
00727 
00728   \textcolor{comment}{// In the case of the gradient, even though we must solve for a null-space}
00729   \textcolor{comment}{// of dimension 2, we must only extract ONE basis for the kernel.}
00730   \textcolor{comment}{// We perform this extraction here:}
00731 
00732   \textcolor{keywordtype}{int} aux\_\{kk\_num\_rows - kk\_num\_cols\};
00733   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = kk\_num\_rows - kk\_num\_cols; ii < kk\_num\_rows; ii++) \{
00734     aux\_--;
00735     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < kk\_num\_rows; jj++) \{
00736       kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj*kk\_num\_cols + (kk\_num\_rows - kk\_num\_cols - aux\_ - 1)] =
00737         qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00738     \}
00739   \}
00740 
00741 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
00742   std::cout << \textcolor{stringliteral}{"kk ="} << std::endl;
00743   std::cout << kk << std::endl;
00744   std::cout << \textcolor{stringliteral}{"kk.num\_rows() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a53f3afb3b6a8d21854458aaa9663cc74}{num\_rows}() << std::endl;
00745   std::cout << \textcolor{stringliteral}{"kk.num\_cols() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() << std::endl;
00746   std::cout << std::endl;
00747 \textcolor{preprocessor}{  #endif}
00748 
00750 
00751   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00752   \textcolor{comment}{// null-space, adopt the pattern we require.}
00753   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00754   \textcolor{comment}{//  scalers = kk(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00755   \textcolor{comment}{//  SK = kk*scalers}
00756   \textcolor{comment}{// where SK is the scaled null-space.}
00757 
00758   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00759   \textcolor{comment}{// in memory. We will create the matrix iden\_, and elements we wish to scale}
00760   \textcolor{comment}{// in the kk array. Using the concept of the leading dimension, we could just}
00761   \textcolor{comment}{// use kk, with the correct leading dimension and that is it. BUT I DO NOT}
00762   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00763   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00764   \textcolor{comment}{// whole kk:}
00765 
00766   \textcolor{comment}{// We will then create memory for that sub-matrix of kk (subk).}
00767 
00768   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} subk(dim\_null\_, dim\_null\_);
00769 
00770   \textcolor{keyword}{auto} zz = 0;
00771   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = order\_accuracy\_ + 1; ii < num\_bndy\_coeffs\_; ii++) \{
00772     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; jj++) \{
00773       subk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[zz*(dim\_null\_) + jj] = kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(dim\_null\_) + jj];
00774     \}
00775     zz++;
00776   \}
00777 
00778 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00779   std::cout << \textcolor{stringliteral}{"subk ="} << std::endl;
00780   std::cout << subk << std::endl;
00781 \textcolor{preprocessor}{  #endif}
00782 
00783   subk.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00784 
00785 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00786   std::cout << \textcolor{stringliteral}{"subk\_t ="} << std::endl;
00787   std::cout << subk << std::endl;
00788 \textcolor{preprocessor}{  #endif}
00789 
00790   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00791   tran = \textcolor{keyword}{false};
00792 
00793   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} iden(dim\_null\_, padded, tran);
00794 
00795 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00796   std::cout << \textcolor{stringliteral}{"iden ="} << std::endl;
00797   std::cout << iden << std::endl;
00798 \textcolor{preprocessor}{  #endif}
00799 
00800   \textcolor{comment}{// Solve the system to compute the scalers.}
00801   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00802   \textcolor{comment}{//}
00803   \textcolor{comment}{// subk*scalers = iden or}
00804   \textcolor{comment}{//}
00805   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00806   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00807   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00808   \textcolor{comment}{//}
00809   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00810   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00811   \textcolor{comment}{// will be stored in the created identity matrix.}
00812   \textcolor{comment}{// Let us first transpose subk (because of LAPACK):}
00813 
00814   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(subk, iden)\};
00815 
00816 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00817   \textcolor{keywordflow}{if} (!info) \{
00818     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00819       std::endl;
00820   \} \textcolor{keywordflow}{else} \{
00821     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00822       std::endl;
00823     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00824     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00825   \}
00826   std::cout << std::endl;
00827 \textcolor{preprocessor}{  #endif}
00828 
00829 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00830   std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00831   std::cout << iden << std::endl;
00832 \textcolor{preprocessor}{  #endif}
00833 
00834   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00835 
00836   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(kk, iden);
00837 
00838 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00839   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00840   std::cout << rat\_basis\_null\_space\_ << std::endl;
00841 \textcolor{preprocessor}{  #endif}
00842 
00843   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00844   \textcolor{comment}{// pattern we need! :)}
00845 
00846   \textcolor{keyword}{delete} [] gg;
00847   gg = \textcolor{keyword}{nullptr};
00848 
00849   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00850 \}
00851 
\hypertarget{mtk__grad__1d_8cc_source_l00852}{}\hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{00852} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{mtk::Grad1D::ComputePreliminaryApproximations}() \{
00853 
00855 
00856   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00857 
00858   \textcolor{keywordflow}{try} \{
00859     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00860   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00861     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00862       std::endl;
00863     std::cerr << memory\_allocation\_exception.what() << std::endl;
00864   \}
00865   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00866 
00867 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00868   gg[1] = 1.0/2.0;
00869 \textcolor{preprocessor}{  #else}
00870   gg[1] = 1.0f/2.0f;
00871 \textcolor{preprocessor}{  #endif}
00872   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00873     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00874   \}
00875 
00876 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00877   std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00878   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00879     std::cout << std::setw(12) << gg[ii];
00880   \}
00881   std::cout << std::endl << std::endl;
00882 \textcolor{preprocessor}{  #endif}
00883 
00884   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00885   \textcolor{keywordflow}{try} \{
00886     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
00887   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00888     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00889 std::endl;
00890     std::cerr << memory\_allocation\_exception.what() << std::endl;
00891   \}
00892   memset(prem\_apps\_,
00893          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00894          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
00895 
00897 
00898   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < num\_bndy\_approxs\_; ++ll) \{
00899 
00900     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00901 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00902     \textcolor{keywordflow}{if} (ll > 0) \{
00903       std::cout << \textcolor{stringliteral}{"gg\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00904       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00905         std::cout << std::setw(12) << gg[ii];
00906       \}
00907       std::cout << std::endl << std::endl;
00908     \}
00909 \textcolor{preprocessor}{    #endif}
00910 
00912 
00913     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00914 
00915     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa(gg,
00916                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00917                          transpose);
00918 
00919 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
00920     std::cout << \textcolor{stringliteral}{"aa\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00921     std::cout << aa << std::endl;
00922 \textcolor{preprocessor}{    #endif}
00923 
00925 
00926     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00927 
00928     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00929 
00930     \textcolor{keywordflow}{try} \{
00931       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00932     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00933       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00934         std::endl;
00935       std::cerr << memory\_allocation\_exception.what() << std::endl;
00936     \}
00937     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00938 
00939     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00940 
00941 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00942     std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00943     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00944       std::cout << std::setw(12) << ob[ii] << std::endl;
00945     \}
00946     std::cout << std::endl;
00947 \textcolor{preprocessor}{    #endif}
00948 
00950 
00951     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00952     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00953     \textcolor{comment}{// our LAPACKAdapter class.}
00954 
00955     \textcolor{keywordtype}{int} info\_\{
00956       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(aa, ob
      , ob\_ld)\};
00957 
00958 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00959     \textcolor{keywordflow}{if} (!info\_) \{
00960       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00961     \} \textcolor{keywordflow}{else} \{
00962       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00963       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00964     \}
00965 \textcolor{preprocessor}{    #endif}
00966 
00967 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00968     std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00969     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00970       std::cout << std::setw(12) << ob[ii] << std::endl;
00971     \}
00972     std::cout << std::endl;
00973 \textcolor{preprocessor}{    #endif}
00974 
00976 
00977     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
00978     \textcolor{comment}{// for this operation.}
00979 
00981     \textcolor{comment}{// Save them into the ob\_bottom array:}
00982 
00983     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
00984 
00985     \textcolor{keywordflow}{try} \{
00986       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
00987     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00988       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00989         std::endl;
00990       std::cerr << memory\_allocation\_exception.what() << std::endl;
00991     \}
00992     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
00993 
00994     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00995       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
00996     \}
00997 
00998 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00999     std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
01000     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01001       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
01002     \}
01003     std::cout << std::endl;
01004 \textcolor{preprocessor}{    #endif}
01005 
01007 
01008     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
01009     \textcolor{comment}{// rat\_basis\_null\_space\_.}
01010     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
01011     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
01012     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
01013 
01014 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
01015     std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
01016     std::cout << rat\_basis\_null\_space\_ << std::endl;
01017 \textcolor{preprocessor}{    #endif}
01018 
01019     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01020     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01021 
01022     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
01023                                   ob\_bottom, beta, ob);
01024 
01025 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01026     std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
01027     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01028       std::cout << std::setw(12) << ob[ii] << std::endl;
01029     \}
01030     std::cout << std::endl;
01031 \textcolor{preprocessor}{    #endif}
01032 
01033     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
01034     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
01035     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
01036     \textcolor{comment}{// to implement.}
01037 
01038     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01039       prem\_apps\_[ii*num\_bndy\_approxs\_ + ll] = ob[ii];
01040     \}
01041 
01042     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
01043     \textcolor{comment}{// generator vector used:}
01044     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01045       gg[ii]--;
01046     \}
01047 
01048     \textcolor{comment}{// Garbage collection for this loop:}
01049     \textcolor{keyword}{delete}[] ob;
01050     ob = \textcolor{keyword}{nullptr};
01051 
01052     \textcolor{keyword}{delete}[] ob\_bottom;
01053     ob\_bottom = \textcolor{keyword}{nullptr};
01054   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
01055 
01056 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01057   std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
01058   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01059     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01060       std::cout << std::setw(12) << prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01061     \}
01062     std::cout << std::endl;
01063   \}
01064   std::cout << std::endl;
01065 \textcolor{preprocessor}{  #endif}
01066 
01067   \textcolor{keyword}{delete}[] gg;
01068   gg = \textcolor{keyword}{nullptr};
01069 
01070   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01071 \}
01072 
\hypertarget{mtk__grad__1d_8cc_source_l01073}{}\hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{01073} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{mtk::Grad1D::ComputeWeights}() \{
01074 
01075   \textcolor{comment}{// Matrix to compute the weights as in the CRSA.}
01076   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
01077 
01079 
01080   \textcolor{comment}{// Assemble the pi matrix using:}
01081   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
01082   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
01083   \textcolor{comment}{// 3. The scaled basis for the null-space.}
01084 
01085   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
01086 
01087   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
01088   \textcolor{comment}{// of the pi matrix:}
01089   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01090     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01091       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(2*(num\_bndy\_approxs\_ - 1) + (order\_accuracy\_/2 + 1)) + jj] =
01092         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01093     \}
01094   \}
01095 
01096   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
01097 
01098   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
01099   \textcolor{comment}{// final pi matrix:}
01100   \textcolor{keyword}{auto} mm = 1;
01101   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < order\_accuracy\_; ++jj) \{
01102     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01103       \textcolor{keyword}{auto} de = (ii + mm)*(2*(num\_bndy\_approxs\_ - 1) +
01104         (order\_accuracy\_/2 + 1)) + jj;
01105       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = coeffs\_interior\_[ii];
01106     \}
01107     ++mm;
01108   \}
01109 
01110   rat\_basis\_null\_space\_.OrderColMajor();
01111 
01112 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01113   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
01114   std::cout << rat\_basis\_null\_space\_ << std::endl;
01115 \textcolor{preprocessor}{  #endif}
01116 
01117   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
01118 
01119   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1);
01120        jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
01121     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01122       \textcolor{keyword}{auto} og =
01123         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
01124       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
01125       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
01126     \}
01127   \}
01128 
01129 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01130   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
01131   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01132     std::cout << std::setw(12) << coeffs\_interior\_[ii];
01133   \}
01134   std::cout << std::endl << std::endl;
01135 \textcolor{preprocessor}{  #endif}
01136 
01137 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01138   std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
01139   std::cout << pi << std::endl;
01140 \textcolor{preprocessor}{  #endif}
01141 
01143 
01144   \textcolor{comment}{// This imposes the mimetic condition.}
01145 
01146   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
01147 
01148   \textcolor{keywordflow}{try} \{
01149     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01150   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01151     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01152       std::endl;
01153     std::cerr << memory\_allocation\_exception.what() << std::endl;
01154   \}
01155   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
01156 
01157   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
01158   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
01159     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01160     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
01161       aux\_xx += coeffs\_interior\_[jj];
01162     \}
01163     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
01164   \}
01165 
01167 
01168   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
01169 
01170   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
01171   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
01172   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
01173   \textcolor{comment}{// unique. We will use dgels\_.}
01174 
01175   \textcolor{keywordflow}{try} \{
01176     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01177   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01178     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01179       std::endl;
01180     std::cerr << memory\_allocation\_exception.what() << std::endl;
01181   \}
01182   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
01183 
01184   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() + 1\};
01185 
01186   \textcolor{comment}{// Preserve hh.}
01187   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
01188 
01189   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01190 
01191   \textcolor{keywordtype}{int} info\{
01192     \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(pi,
01193                                                     weights\_cbs\_, weights\_ld)
01194   \};
01195 
01196 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
01197   \textcolor{keywordflow}{if} (!info) \{
01198     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01199   \} \textcolor{keywordflow}{else} \{
01200     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01201     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
01202   \}
01203 \textcolor{preprocessor}{  #endif}
01204 
01205 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01206   std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01207   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01208     std::cout << std::setw(11) << hh[ii] << std::endl;
01209   \}
01210   std::cout << std::endl;
01211 \textcolor{preprocessor}{  #endif}
01212 
01213   \textcolor{comment}{// Preserve the original weights for research.}
01214 
01215   \textcolor{keywordflow}{try} \{
01216     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01217   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01218     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01219       std::endl;
01220     std::cerr << memory\_allocation\_exception.what() << std::endl;
01221   \}
01222   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01223 
01224   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01225 
01226 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01227   std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01228   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01229     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01230   \}
01231   std::cout << std::endl;
01232 \textcolor{preprocessor}{  #endif}
01233 
01235 
01236   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
01237 
01239 
01240     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01241 
01242     \textcolor{comment}{// 6.1. Insert preliminary approximations to first set of columns.}
01243 
01244     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01245       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01246         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(order\_accuracy\_) + jj] =
01247           prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01248       \}
01249     \}
01250 
01251     \textcolor{comment}{// 6.2. Skip a column and negate preliminary approximations.}
01252 
01253     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; jj++) \{
01254       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_approxs\_; ii++) \{
01255         \textcolor{keyword}{auto} de = (ii+ order\_accuracy\_ - num\_bndy\_approxs\_+ jj*order\_accuracy\_);
01256         \textcolor{keyword}{auto} og = (num\_bndy\_approxs\_ - ii + (jj)*num\_bndy\_approxs\_);
01257         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = -prem\_apps\_[og];
01258       \}
01259     \}
01260 
01261     \textcolor{comment}{// 6.3. Flip negative columns up-down.}
01262 
01263     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ii++) \{
01264       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_ + 1; jj < order\_accuracy\_; jj++) \{
01265         \textcolor{keyword}{auto} aux = phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj];
01266         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj] =
01267           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj];
01268         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj] = aux;
01269       \}
01270     \}
01271 
01272     \textcolor{comment}{// 6.4. Insert stencil.}
01273 
01274     \textcolor{keyword}{auto} mm = 0;
01275     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < num\_bndy\_approxs\_ +  1; jj++) \{
01276       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ii++) \{
01277         \textcolor{keywordflow}{if} (ii == 0) \{
01278           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj] = 0.0;
01279         \} \textcolor{keywordflow}{else} \{
01280           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(ii + mm)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii - 1];
01281         \}
01282       \}
01283       mm++;
01284     \}
01285 
01286 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
01287     std::cout << \textcolor{stringliteral}{"phi ="} << std::endl;
01288     std::cout << phi << std::endl;
01289 \textcolor{preprocessor}{    #endif}
01290 
01292 
01293     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01294 
01295     \textcolor{keywordflow}{try} \{
01296       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_approxs\_ - 1];
01297     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01298       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01299         std::endl;
01300       std::cerr << memory\_allocation\_exception.what() << std::endl;
01301     \}
01302     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*(num\_bndy\_approxs\_ - 1));
01303 
01304     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01305       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01306     \}
01307 
01308 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01309     std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01310     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01311       std::cout << std::setw(12) << lamed[ii] << std::endl;
01312     \}
01313     std::cout << std::endl;
01314 \textcolor{preprocessor}{    #endif}
01315 
01316     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01317       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01318       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_ - 1; ++jj) \{
01319         temp = temp +
01320           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01321       \}
01322       hh[ii] = hh[ii] - temp;
01323     \}
01324 
01325 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01326     std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01327     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01328       std::cout << std::setw(12) << hh[ii] << std::endl;
01329     \}
01330     std::cout << std::endl;
01331 \textcolor{preprocessor}{    #endif}
01332 
01334 
01335 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01336     \textcolor{keywordtype}{int} copy\_result\{1\};
01337 \textcolor{preprocessor}{    #else}
01338     \textcolor{keywordtype}{int} copy\_result\{\};
01339 \textcolor{preprocessor}{    #endif}
01340 
01341     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01342 
01343     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01344     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\{std::numeric\_limits<mtk::Real>::infinity()\};
01345 
01346     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01347 
01348 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01349     std::ofstream table(\textcolor{stringliteral}{"grad\_1d\_"} + std::to\_string(order\_accuracy\_) +
01350       \textcolor{stringliteral}{"\_weights.tex"});
01351 
01352     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)begin\{tabular\}[c]\{c"};
01353     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01354       table << \textcolor{charliteral}{'c'};
01355     \}
01356     table << \textcolor{stringliteral}{":c\}\(\backslash\)n\(\backslash\)\(\backslash\)toprule\(\backslash\)nRow & "};
01357     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01358       table << \textcolor{stringliteral}{"$ q\_\{"} + std::to\_string(ii) + \textcolor{stringliteral}{"\}$ &"};
01359     \}
01360     table << \textcolor{stringliteral}{" Relative error \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)midrule\(\backslash\)n"};
01361 \textcolor{preprocessor}{    #endif}
01362 
01363     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01364       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01365                                                           order\_accuracy\_ + 1,
01366                                                           order\_accuracy\_,
01367                                                           order\_accuracy\_,
01368                                                           hh,
01369                                                           weights\_cbs\_,
01370                                                           row\_,
01371                                                           mimetic\_threshold\_,
01372                                                           copy\_result);
01373       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\};
01374 
01375 \textcolor{preprocessor}{      #if MTK\_VERBOSE\_LEVEL > 2}
01376       std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01377       std::cout << std::endl;
01378 \textcolor{preprocessor}{      #endif}
01379 
01380       \textcolor{keywordflow}{if} (aux < minnorm) \{
01381         minnorm = aux;
01382         minrow\_= row\_;
01383       \}
01384 
01385 \textcolor{preprocessor}{      #ifdef MTK\_VERBOSE\_WEIGHTS}
01386       table << std::to\_string(row\_ + 1) << \textcolor{stringliteral}{" & "};
01387       \textcolor{keywordflow}{if} (normerr\_ != std::numeric\_limits<mtk::Real>::infinity()) \{
01388         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01389           table << std::to\_string(weights\_cbs\_[ii - 1]) + \textcolor{stringliteral}{" & "};
01390         \}
01391         table << std::to\_string(aux) << \textcolor{stringliteral}{" \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01392       \} \textcolor{keywordflow}{else} \{
01393         table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)multicolumn\{"} << std::to\_string(order\_accuracy\_) <<
01394           \textcolor{stringliteral}{"\}\{c\}\{$\(\backslash\)\(\backslash\)emptyset$\} & "};
01395         table << \textcolor{stringliteral}{" - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01396       \}
01397 \textcolor{preprocessor}{      #endif}
01398     \}
01399 
01400 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01401     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)midrule"} << std::endl;
01402     table << \textcolor{stringliteral}{"CRS weights:"};
01403     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01404       table << \textcolor{stringliteral}{" & "} << std::to\_string(weights\_crs\_[ii - 1]);
01405     \}
01406     table << \textcolor{stringliteral}{" & - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)bottomrule\(\backslash\)n\(\backslash\)\(\backslash\)end\{tabular\}"} << std::endl;
01407     table.close();
01408 \textcolor{preprocessor}{    #endif}
01409 
01410 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01411     std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01412       std::endl;
01413     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01414       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01415     \}
01416     std::cout << std::endl;
01417 \textcolor{preprocessor}{    #endif}
01418 
01420 
01421     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01422     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01423     \textcolor{comment}{// chosen to be the new weights\_.}
01424 
01425 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01426     std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm << \textcolor{stringliteral}{" found at row "} <<
01427       minrow\_ + 1 << std::endl;
01428     std::cout << std::endl;
01429 \textcolor{preprocessor}{    #endif}
01430 
01431     copy\_result = 1;
01432     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01433                                                         order\_accuracy\_ + 1,
01434                                                         order\_accuracy\_,
01435                                                         order\_accuracy\_,
01436                                                         hh,
01437                                                         weights\_cbs\_,
01438                                                         minrow\_,
01439                                                         mimetic\_threshold\_,
01440                                                         copy\_result);
01441     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\};
01442 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01443     std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01444     std::cout << std::endl;
01445 \textcolor{preprocessor}{    #endif}
01446 
01447     \textcolor{keyword}{delete} [] lamed;
01448     lamed = \textcolor{keyword}{nullptr};
01449   \}
01450 
01451   \textcolor{keyword}{delete} [] hh;
01452   hh = \textcolor{keyword}{nullptr};
01453 
01454   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01455 \}
01456 
\hypertarget{mtk__grad__1d_8cc_source_l01457}{}\hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{01457} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{mtk::Grad1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01458 
01459 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01460   std::cout << \textcolor{stringliteral}{"weights\_* + lambda ="} << std::endl;
01461   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01462     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01463   \}
01464   std::cout << std::endl;
01465 \textcolor{preprocessor}{  #endif}
01466 
01468 
01469   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01470 
01471   \textcolor{keywordflow}{try} \{
01472     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01473   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01474     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01475       std::endl;
01476     std::cerr << memory\_allocation\_exception.what() << std::endl;
01477   \}
01478   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01479 
01480   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01481     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01482   \}
01483 
01484 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01485   std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01486   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01487     std::cout << std::setw(12) << lambda[ii] << std::endl;
01488   \}
01489   std::cout << std::endl;
01490 \textcolor{preprocessor}{  #endif}
01491 
01493 
01494   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01495 
01496   \textcolor{keywordflow}{try} \{
01497     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01498   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01499     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01500       std::endl;
01501     std::cerr << memory\_allocation\_exception.what() << std::endl;
01502   \}
01503   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01504 
01505   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01506     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01507   \}
01508 
01509 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01510   std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01511   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01512     std::cout << std::setw(12) << alpha[ii] << std::endl;
01513   \}
01514   std::cout << std::endl;
01515 \textcolor{preprocessor}{  #endif}
01516 
01518 
01519   \textcolor{keywordflow}{try} \{
01520     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
01521   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01522     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01523       std::endl;
01524     std::cerr << memory\_allocation\_exception.what() << std::endl;
01525   \}
01526   memset(mim\_bndy\_,
01527          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
01528          \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
01529 
01530   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01531     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < (num\_bndy\_approxs\_ - 1); ++jj) \{
01532       mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj] =
01533         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj] +
01534         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01535     \}
01536   \}
01537 
01538   \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01539     mim\_bndy\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)] =
01540       prem\_apps\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)];
01541   \}
01542 
01543 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01544   std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01545   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01546     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01547       std::cout << std::setw(13) << mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj];
01548     \}
01549     std::cout << std::endl;
01550   \}
01551   std::cout << std::endl;
01552 \textcolor{preprocessor}{  #endif}
01553 
01555 
01556   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_; ++ii) \{
01557     sums\_rows\_mim\_bndy\_.push\_back(\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
01558     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; ++jj) \{
01559       sums\_rows\_mim\_bndy\_[ii] += mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01560     \}
01561   \}
01562 
01563 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01564   std::cout << \textcolor{stringliteral}{"Row-wise sum of mimetic approximations:"} << std::endl;
01565   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_; ++ii) \{
01566     std::cout << std::setw(13) << sums\_rows\_mim\_bndy\_[ii];
01567   \}
01568   std::cout << std::endl;
01569   std::cout << std::endl;
01570 \textcolor{preprocessor}{  #endif}
01571 
01572   \textcolor{keyword}{delete}[] lambda;
01573   lambda = \textcolor{keyword}{nullptr};
01574 
01575   \textcolor{keyword}{delete}[] alpha;
01576   alpha = \textcolor{keyword}{nullptr};
01577 
01578   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01579 \}
01580 
\hypertarget{mtk__grad__1d_8cc_source_l01581}{}\hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{01581} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{mtk::Grad1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01582 
01583   \textcolor{comment}{// The output array will have this form:}
01584   \textcolor{comment}{// 1. The first entry of the array will contain the used order kk.}
01585   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01586   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01587   \textcolor{comment}{// 3. The third entry will contain a collection of weights.}
01588   \textcolor{comment}{// 4. The next dim\_null - 1 entries will contain the collections of}
01589   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01590 
01591   gradient\_length\_ = 1 + order\_accuracy\_ + order\_accuracy\_ +
01592     num\_bndy\_approxs\_*num\_bndy\_coeffs\_;
01593 
01594 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
01595   std::cout << \textcolor{stringliteral}{"gradient\_length\_ = "} << gradient\_length\_ << std::endl;
01596 \textcolor{preprocessor}{  #endif}
01597 
01598   \textcolor{keywordflow}{try} \{
01599     gradient\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[gradient\_length\_];
01600   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01601     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01602       std::endl;
01603     std::cerr << memory\_allocation\_exception.what() << std::endl;
01604   \}
01605   memset(gradient\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gradient\_[0])*gradient\_length\_);
01606 
01608 
01609   gradient\_[0] = order\_accuracy\_;
01610 
01613 
01614   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01615     gradient\_[ii + 1] = coeffs\_interior\_[ii];
01616   \}
01617 
01619 
01620   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01621     gradient\_[(order\_accuracy\_ + 1) + ii] = weights\_cbs\_[ii];
01622   \}
01623 
01626 
01627   \textcolor{keywordtype}{int} offset\{2*order\_accuracy\_ + 1\};
01628 
01629   \textcolor{keywordtype}{int} aux \{\}; \textcolor{comment}{// Auxiliary variable.}
01630 
01631   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01632     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ ; ii++) \{
01633       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; jj++) \{
01634         gradient\_[offset + aux] = mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01635         aux++;
01636       \}
01637     \}
01638   \} \textcolor{keywordflow}{else} \{
01639     gradient\_[offset + 0] = prem\_apps\_[0];
01640     gradient\_[offset + 1] = prem\_apps\_[1];
01641     gradient\_[offset + 2] = prem\_apps\_[2];
01642   \}
01643 
01644 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 1}
01645   std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order grad built!"} << std::endl;
01646   std::cout << std::endl;
01647 \textcolor{preprocessor}{  #endif}
01648 
01649   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01650 \}
\end{DoxyCode}
