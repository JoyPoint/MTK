\hypertarget{mtk__grad__1d_8cc}{\section{mtk\-\_\-grad\-\_\-1d.\-cc}
\label{mtk__grad__1d_8cc}\index{src/mtk\-\_\-grad\-\_\-1d.\-cc@{src/mtk\-\_\-grad\-\_\-1d.\-cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed. Documentation related to said modifications should be included.}
00025 \textcolor{comment}{}
00026 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00027 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00028 \textcolor{comment}{}
00029 \textcolor{comment}{3. Redistributions of source code must retain the above copyright notice, this}
00030 \textcolor{comment}{list of conditions and the following disclaimer.}
00031 \textcolor{comment}{}
00032 \textcolor{comment}{4. Redistributions in binary form must reproduce the above copyright notice,}
00033 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00034 \textcolor{comment}{other materials provided with the distribution.}
00035 \textcolor{comment}{}
00036 \textcolor{comment}{5. Usage of the binary form on proprietary applications shall require explicit}
00037 \textcolor{comment}{prior written permission from the the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{6. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 \textcolor{preprocessor}{#include <limits>}
00067 \textcolor{preprocessor}{#include <algorithm>}
00068 
00069 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00070 
00071 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00072 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00073 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00074 
00075 \textcolor{preprocessor}{#include "\hyperlink{mtk__grad__1d_8h}{mtk\_grad\_1d.h}"}
00076 
00077 \textcolor{keyword}{namespace }mtk \{
00078 
\hypertarget{mtk__grad__1d_8cc_source_l00079}{}\hyperlink{namespacemtk_a3f546b8a3743b8719db17e33f2d7ef7f}{00079} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Grad1D}{mtk::Grad1D} &in) \{
00080 
00082 
00083   stream << \textcolor{stringliteral}{"gradient\_[0] = "} << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[0] << std::endl;
00084 
00086 
00087   stream << \textcolor{stringliteral}{"gradient\_[1:"} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00088   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00089     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00090   \}
00091   stream << std::endl;
00092 
00094 
00095   stream << \textcolor{stringliteral}{"gradient\_["} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1 << \textcolor{stringliteral}{":"} <<
00096     2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00097   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00098     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00099   \}
00100   stream << std::endl;
00101 
00103 
00104   \textcolor{keywordtype}{int} offset\{2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1\};
00105   \textcolor{keywordtype}{int} mm \{\};
00106 
00107   stream << \textcolor{stringliteral}{"gradient\_["} << offset + mm << \textcolor{stringliteral}{":"} <<
00108     offset + mm + in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_} - 1 << \textcolor{stringliteral}{"] = "};
00109 
00110   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
00111     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Grad1D_abe15c1ffd9dfaba1a65f4f0e096287ce}{num\_bndy\_approxs\_} ; ++ii) \{
00112       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_}; jj++) \{
00113         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + (mm)];
00114         stream << std::setw(9) << value << \textcolor{stringliteral}{" "};
00115         mm++;
00116       \}
00117     \}
00118   \} \textcolor{keywordflow}{else} \{
00119     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] << \textcolor{charliteral}{' '};
00120     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] << \textcolor{charliteral}{' '};
00121     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2] << \textcolor{charliteral}{' '};
00122   \}
00123   stream << std::endl;
00124 
00125   \textcolor{keywordflow}{return} stream;
00126 \}
00127 \}
00128 
\hypertarget{mtk__grad__1d_8cc_source_l00129}{}\hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{00129} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}():
00130   order\_accuracy\_(mtk::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00131   dim\_null\_(),
00132   num\_bndy\_approxs\_(),
00133   num\_bndy\_coeffs\_(),
00134   gradient\_length\_(),
00135   minrow\_(),
00136   row\_(),
00137   coeffs\_interior\_(),
00138   prem\_apps\_(),
00139   weights\_crs\_(),
00140   weights\_cbs\_(),
00141   mim\_bndy\_(),
00142   gradient\_(),
00143   mimetic\_threshold\_(mtk::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}) \{\}
00144 
\hypertarget{mtk__grad__1d_8cc_source_l00145}{}\hyperlink{classmtk_1_1Grad1D_a5708bcb61bde3f7f3a4ddede191d82a4}{00145} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Grad1D}{Grad1D} &grad):
00146   order\_accuracy\_(grad.order\_accuracy\_),
00147   dim\_null\_(grad.dim\_null\_),
00148   num\_bndy\_approxs\_(grad.num\_bndy\_approxs\_),
00149   num\_bndy\_coeffs\_(grad.num\_bndy\_coeffs\_),
00150   gradient\_length\_(grad.gradient\_length\_),
00151   minrow\_(grad.minrow\_),
00152   row\_(grad.row\_),
00153   coeffs\_interior\_(grad.coeffs\_interior\_),
00154   prem\_apps\_(grad.prem\_apps\_),
00155   weights\_crs\_(grad.weights\_crs\_),
00156   weights\_cbs\_(grad.weights\_cbs\_),
00157   mim\_bndy\_(grad.mim\_bndy\_),
00158   gradient\_(grad.gradient\_),
00159   mimetic\_threshold\_(grad.mimetic\_threshold\_) \{\}
00160 
\hypertarget{mtk__grad__1d_8cc_source_l00161}{}\hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{00161} \hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{mtk::Grad1D::~Grad1D}() \{
00162 
00163   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00164   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00165 
00166   \textcolor{keyword}{delete}[] prem\_apps\_;
00167   prem\_apps\_ = \textcolor{keyword}{nullptr};
00168 
00169   \textcolor{keyword}{delete}[] weights\_crs\_;
00170   weights\_crs\_ = \textcolor{keyword}{nullptr};
00171 
00172   \textcolor{keyword}{delete}[] weights\_cbs\_;
00173   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00174 
00175   \textcolor{keyword}{delete}[] mim\_bndy\_;
00176   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00177 
00178   \textcolor{keyword}{delete}[] gradient\_;
00179   gradient\_ = \textcolor{keyword}{nullptr};
00180 \}
00181 
\hypertarget{mtk__grad__1d_8cc_source_l00182}{}\hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{00182} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{mtk::Grad1D::ConstructGrad1D}(\textcolor{keywordtype}{int} order\_accuracy, 
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} mimetic\_threshold) \{
00183 
00184 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00185 \textcolor{preprocessor}{}  \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00186   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00187   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00188                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00189 
00190   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
00191     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is high."} << std::endl;;
00192   \}
00193 
00194   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;;
00195   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;;
00196 \textcolor{preprocessor}{  #endif}
00197 \textcolor{preprocessor}{}
00198   order\_accuracy\_ = order\_accuracy;
00199   mimetic\_threshold\_ = mimetic\_threshold;
00200 
00202 
00203   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00204 
00205 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00206 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00207     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;;
00208     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00209     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00210   \}
00211 \textcolor{preprocessor}{  #endif}
00212 \textcolor{preprocessor}{}
00213   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00214   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00215 
00216   dim\_null\_ = order\_accuracy\_/2 - 1;
00217 
00218   num\_bndy\_approxs\_ = dim\_null\_ + 1;
00219 
00220 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00221 \textcolor{preprocessor}{}  num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00222 \textcolor{preprocessor}{  #else}
00223 \textcolor{preprocessor}{}  num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00224 \textcolor{preprocessor}{  #endif}
00225 \textcolor{preprocessor}{}
00227 
00228   \textcolor{comment}{// For this we will follow recommendations given in:}
00229   \textcolor{comment}{//}
00230   \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00231   \textcolor{comment}{//}
00232   \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00233   \textcolor{comment}{// following (MATLAB) pseudo-code:}
00234   \textcolor{comment}{//}
00235   \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00236   \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00237   \textcolor{comment}{//}
00238   \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00239   \textcolor{comment}{//}
00240   \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00241   \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00242   \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00243   \textcolor{comment}{// (west boundary).}
00244 
00245   \textcolor{comment}{// In the case of the gradient, the first Vandermonde system has a unique}
00246   \textcolor{comment}{// solution for the case of second-order-accuracy. Ergo, the Vandermonde}
00247   \textcolor{comment}{// matrix used to assemble said system, will have an empty null-space.}
00248 
00249   \textcolor{comment}{// Therefore, we only compute a rational basis for the case of order higher}
00250   \textcolor{comment}{// than second.}
00251 
00252   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00253 
00254     abort\_construction = ComputeRationalBasisNullSpace();
00255 
00256 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00257 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00258       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;;
00259       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00260       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00261     \}
00262 \textcolor{preprocessor}{    #endif}
00263 \textcolor{preprocessor}{}  \}
00264 
00266 
00267   abort\_construction = ComputePreliminaryApproximations();
00268 
00269 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00270 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00271     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;;
00272     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00273     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00274   \}
00275 \textcolor{preprocessor}{  #endif}
00276 \textcolor{preprocessor}{}
00278 
00279   abort\_construction = ComputeWeights();
00280 
00281 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00282 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00283     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;;
00284     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00285     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00286   \}
00287 \textcolor{preprocessor}{  #endif}
00288 \textcolor{preprocessor}{}
00290 
00291   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00292 
00293     abort\_construction = ComputeStencilBoundaryGrid();
00294 
00295 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00296 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00297       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;;
00298       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00299       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00300     \}
00301 \textcolor{preprocessor}{    #endif}
00302 \textcolor{preprocessor}{}  \}
00303 
00305 
00306   \textcolor{comment}{// Once we have the following three collections of data:}
00307   \textcolor{comment}{//   (a) the coefficients for the interior,}
00308   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00309   \textcolor{comment}{//   (c) and the weights (if it applies),}
00310   \textcolor{comment}{// we will store everything in the output array:}
00311 
00312   abort\_construction = AssembleOperator();
00313 
00314 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00315 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00316     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;;
00317     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;;
00318     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00319   \}
00320 \textcolor{preprocessor}{  #endif}
00321 \textcolor{preprocessor}{}
00322   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00323 \}
00324 
\hypertarget{mtk__grad__1d_8cc_source_l00325}{}\hyperlink{classmtk_1_1Grad1D_aa1448d7b389d451e03836d2ed0f197f3}{00325} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_aa1448d7b389d451e03836d2ed0f197f3}{mtk::Grad1D::num\_bndy\_coeffs}() \{
00326 
00327   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00328 \}
00329 
\hypertarget{mtk__grad__1d_8cc_source_l00330}{}\hyperlink{classmtk_1_1Grad1D_a50ea44bda43d32b8741e050af52b961d}{00330} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_a50ea44bda43d32b8741e050af52b961d}{mtk::Grad1D::weights\_crs}() \{
00331 
00332   \textcolor{keywordflow}{return} weights\_crs\_;
00333 \}
00334 
\hypertarget{mtk__grad__1d_8cc_source_l00335}{}\hyperlink{classmtk_1_1Grad1D_adde70cb7e4fd930f84121a4bcd7f2e37}{00335} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_adde70cb7e4fd930f84121a4bcd7f2e37}{mtk::Grad1D::weights\_cbs}() \{
00336 
00337   \textcolor{keywordflow}{return} weights\_cbs\_;
00338 \}
00339 
\hypertarget{mtk__grad__1d_8cc_source_l00340}{}\hyperlink{classmtk_1_1Grad1D_a75781c4455569a7934d4e0dff7e06064}{00340} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a75781c4455569a7934d4e0dff7e06064}{mtk::Grad1D::ReturnAsDenseMatrix}(\textcolor{keyword}{const} 
      \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid) \{
00341 
00342   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00343 
00344 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00345 \textcolor{preprocessor}{}  \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(order\_accuracy\_ <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00346 
00348 
00349   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00350 \textcolor{preprocessor}{  #endif}
00351 \textcolor{preprocessor}{}
00352   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00353 
00354   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00355   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00356   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00357   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00358 
00359   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00360   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00361 
00363 
00364   \textcolor{keyword}{auto} ee\_index = 0;
00365   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00366     \textcolor{keyword}{auto} cc = 0;
00367     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00368       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00369         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00370       \} \textcolor{keywordflow}{else} \{
00371         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj,
00372                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00373         cc++;
00374       \}
00375     \}
00376   \}
00377 
00379 
00380   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00381     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00382     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00383       out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00384     \}
00385   \}
00386 
00388 
00389   ee\_index = 0;
00390   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00391     \textcolor{keyword}{auto} cc = 0;
00392     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00393       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00394         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00395       \} \textcolor{keywordflow}{else} \{
00396         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj,
00397                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00398         cc++;
00399       \}
00400      \}
00401   \}
00402 
00403   \textcolor{keywordflow}{return} out;
00404 \}
00405 
\hypertarget{mtk__grad__1d_8cc_source_l00406}{}\hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{00406} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{mtk::Grad1D::ComputeStencilInteriorGrid}() \{
00407 
00409 
00410   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00411 
00412   \textcolor{keywordflow}{try} \{
00413     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00414   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00415     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00416       std::endl;
00417     std::cerr << memory\_allocation\_exception.what() << std::endl;
00418   \}
00419   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00420 
00421 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00422 \textcolor{preprocessor}{}  pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00423 \textcolor{preprocessor}{  #else}
00424 \textcolor{preprocessor}{}  pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00425 \textcolor{preprocessor}{  #endif}
00426 \textcolor{preprocessor}{}
00427   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00428     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00429   \}
00430 
00431 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00432 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00433   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00434     std::cout << std::setw(12) << pp[ii];
00435   \}
00436   std::cout << std::endl << std::endl;
00437 \textcolor{preprocessor}{  #endif}
00438 \textcolor{preprocessor}{}
00440 
00441   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00442 
00443   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,order\_accuracy\_,order\_accuracy\_,transpose);
00444 
00445 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00446 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00447   std::cout << vander\_matrix << std::endl << std::endl;
00448 \textcolor{preprocessor}{  #endif}
00449 \textcolor{preprocessor}{}
00451 
00452   \textcolor{keywordflow}{try} \{
00453     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00454   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00455     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00456       std::endl;
00457     std::cerr << memory\_allocation\_exception.what() << std::endl;
00458   \}
00459   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00460 
00461   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00462 
00463 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00464 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00465   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00466     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00467   \}
00468   std::cout << std::endl;
00469 \textcolor{preprocessor}{  #endif}
00470 \textcolor{preprocessor}{}
00472 
00473   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00474                                                 coeffs\_interior\_)\};
00475 
00476 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00477 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
00478     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00479     std::cout << std::endl;
00480   \}
00481   \textcolor{keywordflow}{else} \{
00482     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00483     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00484     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00485   \}
00486 \textcolor{preprocessor}{  #endif}
00487 \textcolor{preprocessor}{}
00488 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00489 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00490   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00491     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00492   \}
00493   std::cout << std::endl << std::endl;
00494 \textcolor{preprocessor}{  #endif}
00495 \textcolor{preprocessor}{}
00496   \textcolor{keyword}{delete} [] pp;
00497   pp = \textcolor{keyword}{nullptr};
00498 
00499   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00500 \}
00501 
\hypertarget{mtk__grad__1d_8cc_source_l00502}{}\hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{00502} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{mtk::Grad1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00503 
00505 
00506   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00507 
00508   \textcolor{keywordflow}{try} \{
00509     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00510   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00511     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00512       std::endl;
00513     std::cerr << memory\_allocation\_exception.what() << std::endl;
00514   \}
00515   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00516 
00517 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00518 \textcolor{preprocessor}{}  gg[1] = 1.0/2.0;
00519 \textcolor{preprocessor}{  #else}
00520 \textcolor{preprocessor}{}  gg[1] = 1.0f/2.0f;
00521 \textcolor{preprocessor}{  #endif}
00522 \textcolor{preprocessor}{}  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00523     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00524   \}
00525 
00526 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00527 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00528   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00529     std::cout << std::setw(12) << gg[ii];
00530   \}
00531   std::cout << std::endl << std::endl;
00532 \textcolor{preprocessor}{  #endif}
00533 \textcolor{preprocessor}{}
00535 
00536   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00537 
00538   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00539 
00540 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00541 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"aa\_west\_t ="} << std::endl;
00542   std::cout << aa\_west\_t << std::endl;
00543 \textcolor{preprocessor}{  #endif}
00544 \textcolor{preprocessor}{}
00546 
00547   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (aa\_west\_t));
00548 
00549 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00550 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"qq\_t = "} << std::endl;
00551   std::cout << qq\_t << std::endl;
00552 \textcolor{preprocessor}{  #endif}
00553 \textcolor{preprocessor}{}
00555 
00556   \textcolor{keywordtype}{int} kk\_num\_rows\{num\_bndy\_coeffs\_\};
00557   \textcolor{keywordtype}{int} kk\_num\_cols\{dim\_null\_\};
00558 
00559   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} kk(kk\_num\_rows, kk\_num\_cols);
00560 
00561   \textcolor{comment}{// In the case of the gradient, even though we must solve for a null-space}
00562   \textcolor{comment}{// of dimension 2, we must only extract ONE basis for the kernel.}
00563   \textcolor{comment}{// We perform this extraction here:}
00564 
00565   \textcolor{keywordtype}{int} aux\_\{kk\_num\_rows - kk\_num\_cols\};
00566   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = kk\_num\_rows - kk\_num\_cols; ii < kk\_num\_rows; ii++) \{
00567     aux\_--;
00568     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < kk\_num\_rows; jj++) \{
00569       kk.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[jj*kk\_num\_cols + (kk\_num\_rows - kk\_num\_cols - aux\_ - 1)] =
00570         qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00571     \}
00572   \}
00573 
00574 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00575 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"kk ="} << std::endl;
00576   std::cout << kk << std::endl;
00577   std::cout << \textcolor{stringliteral}{"kk.num\_rows() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a17d8d3b9cc0926044b6972dd190a5c21}{num\_rows}() << std::endl;
00578   std::cout << \textcolor{stringliteral}{"kk.num\_cols() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_af6f78373aaf2136f0c78974d7c8de0a8}{num\_cols}() << std::endl;
00579   std::cout << std::endl;
00580 \textcolor{preprocessor}{  #endif}
00581 \textcolor{preprocessor}{}
00583 
00584   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00585   \textcolor{comment}{// null-space, adopt the pattern we require.}
00586   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00587   \textcolor{comment}{//  scalers = kk(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00588   \textcolor{comment}{//  SK = kk*scalers}
00589   \textcolor{comment}{// where SK is the scaled null-space.}
00590 
00591   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00592   \textcolor{comment}{// in memory. We will create the matrix iden\_, and elements we wish to scale in}
00593   \textcolor{comment}{// the kk array. Using the concept of the leading dimension, we could just}
00594   \textcolor{comment}{// use kk, with the correct leading dimension and that is it. BUT I DO NOT}
00595   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00596   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00597   \textcolor{comment}{// whole kk:}
00598 
00599   \textcolor{comment}{// We will then create memory for that sub-matrix of kk (subk).}
00600 
00601   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} subk(dim\_null\_, dim\_null\_);
00602 
00603   \textcolor{keyword}{auto} zz = 0;
00604   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = order\_accuracy\_ + 1; ii < num\_bndy\_coeffs\_; ii++) \{
00605     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; jj++) \{
00606       subk.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[zz*(dim\_null\_) + jj] = kk.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*(dim\_null\_) + jj];
00607     \}
00608     zz++;
00609   \}
00610 
00611 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00612 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"subk ="} << std::endl;
00613   std::cout << subk << std::endl;
00614 \textcolor{preprocessor}{  #endif}
00615 \textcolor{preprocessor}{}
00616   subk.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00617 
00618 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00619 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"subk\_t ="} << std::endl;
00620   std::cout << subk << std::endl;
00621 \textcolor{preprocessor}{  #endif}
00622 \textcolor{preprocessor}{}
00623   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00624   tran = \textcolor{keyword}{false};
00625 
00626   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} iden(dim\_null\_, padded, tran);
00627 
00628 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00629 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"iden ="} << std::endl;
00630   std::cout << iden << std::endl;
00631 \textcolor{preprocessor}{  #endif}
00632 \textcolor{preprocessor}{}
00633   \textcolor{comment}{// Solve the system to compute the scalers.}
00634   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00635   \textcolor{comment}{//}
00636   \textcolor{comment}{// subk*scalers = iden or}
00637   \textcolor{comment}{//}
00638   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00639   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00640   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00641   \textcolor{comment}{//}
00642   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00643   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00644   \textcolor{comment}{// will be stored in the created identity matrix.}
00645   \textcolor{comment}{// Let us first transpose subk (because of LAPACK):}
00646 
00647   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(subk, iden)\};
00648 
00649 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00650 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
00651     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00652       std::endl;
00653   \} \textcolor{keywordflow}{else} \{
00654     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00655       std::endl;
00656     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00657     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00658   \}
00659   std::cout << std::endl;
00660 \textcolor{preprocessor}{  #endif}
00661 \textcolor{preprocessor}{}
00662 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00663 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00664   std::cout << iden << std::endl;
00665 \textcolor{preprocessor}{  #endif}
00666 \textcolor{preprocessor}{}
00667   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00668 
00669   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(kk, iden);
00670 
00671 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00672 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00673   std::cout << rat\_basis\_null\_space\_ << std::endl;
00674 \textcolor{preprocessor}{  #endif}
00675 \textcolor{preprocessor}{}
00676   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00677   \textcolor{comment}{// pattern we need! :)}
00678 
00679   \textcolor{keyword}{delete} [] gg;
00680   gg = \textcolor{keyword}{nullptr};
00681 
00682   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00683 \}
00684 
\hypertarget{mtk__grad__1d_8cc_source_l00685}{}\hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{00685} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{mtk::Grad1D::ComputePreliminaryApproximations}() \{
00686 
00688 
00689   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00690 
00691   \textcolor{keywordflow}{try} \{
00692     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00693   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00694     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00695       std::endl;
00696     std::cerr << memory\_allocation\_exception.what() << std::endl;
00697   \}
00698   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00699 
00700 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00701 \textcolor{preprocessor}{}  gg[1] = 1.0/2.0;
00702 \textcolor{preprocessor}{  #else}
00703 \textcolor{preprocessor}{}  gg[1] = 1.0f/2.0f;
00704 \textcolor{preprocessor}{  #endif}
00705 \textcolor{preprocessor}{}  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00706     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00707   \}
00708 
00709 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00710 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00711   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00712     std::cout << std::setw(12) << gg[ii];
00713   \}
00714   std::cout << std::endl << std::endl;
00715 \textcolor{preprocessor}{  #endif}
00716 \textcolor{preprocessor}{}
00717   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00718   \textcolor{keywordflow}{try} \{
00719     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
00720   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00721     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00722 std::endl;
00723     std::cerr << memory\_allocation\_exception.what() << std::endl;
00724   \}
00725   memset(prem\_apps\_,
00726          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00727          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
00728 
00730 
00731   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < num\_bndy\_approxs\_; ++ll) \{
00732 
00733     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00734 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00735 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (ll > 0) \{
00736       std::cout << \textcolor{stringliteral}{"gg"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00737       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00738         std::cout << std::setw(12) << gg[ii];
00739       \}
00740       std::cout << std::endl << std::endl;
00741     \}
00742 \textcolor{preprocessor}{    #endif}
00743 \textcolor{preprocessor}{}
00745 
00746     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00747 
00748     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa(gg,
00749                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00750                          transpose);
00751 
00752 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00753 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"aa\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00754     std::cout << aa << std::endl;
00755 \textcolor{preprocessor}{    #endif}
00756 \textcolor{preprocessor}{}
00758 
00759     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00760 
00761     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00762 
00763     \textcolor{keywordflow}{try} \{
00764       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00765     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00766       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00767         std::endl;
00768       std::cerr << memory\_allocation\_exception.what() << std::endl;
00769     \}
00770     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00771 
00772     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00773 
00774 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00775 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00776     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00777       std::cout << std::setw(12) << ob[ii] << std::endl;
00778     \}
00779     std::cout << std::endl;
00780 \textcolor{preprocessor}{    #endif}
00781 \textcolor{preprocessor}{}
00783 
00784     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00785     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00786     \textcolor{comment}{// our LAPACKAdapter class.}
00787 
00788     \textcolor{keywordtype}{int} info\_\{
00789       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(aa, ob
      , ob\_ld)\};
00790 
00791 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00792 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!info\_) \{
00793       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00794     \} \textcolor{keywordflow}{else} \{
00795       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00796     \}
00797 \textcolor{preprocessor}{    #endif}
00798 \textcolor{preprocessor}{}
00799 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00800 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00801     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00802       std::cout << std::setw(12) << ob[ii] << std::endl;
00803     \}
00804     std::cout << std::endl;
00805 \textcolor{preprocessor}{    #endif}
00806 \textcolor{preprocessor}{}
00808 
00809     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
00810     \textcolor{comment}{// for this operation.}
00811 
00813     \textcolor{comment}{// Save them into the ob\_bottom array:}
00814 
00815     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
00816 
00817     \textcolor{keywordflow}{try} \{
00818       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
00819     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00820       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00821         std::endl;
00822       std::cerr << memory\_allocation\_exception.what() << std::endl;
00823     \}
00824     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
00825 
00826     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00827       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
00828     \}
00829 
00830 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00831 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
00832     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00833       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
00834     \}
00835     std::cout << std::endl;
00836 \textcolor{preprocessor}{    #endif}
00837 \textcolor{preprocessor}{}
00839 
00840     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
00841     \textcolor{comment}{// rat\_basis\_null\_space\_.}
00842     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
00843     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
00844     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
00845 
00846 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00847 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00848     std::cout << rat\_basis\_null\_space\_ << std::endl;
00849 \textcolor{preprocessor}{    #endif}
00850 \textcolor{preprocessor}{}
00851     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00852     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00853 
00854     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
00855                                   ob\_bottom, beta, ob);
00856 
00857 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00858 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
00859     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00860       std::cout << std::setw(12) << ob[ii] << std::endl;
00861     \}
00862     std::cout << std::endl;
00863 \textcolor{preprocessor}{    #endif}
00864 \textcolor{preprocessor}{}
00865     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
00866     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
00867     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
00868     \textcolor{comment}{// to implement.}
00869 
00870     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00871       prem\_apps\_[ii*num\_bndy\_approxs\_ + ll] = ob[ii];
00872     \}
00873 
00874     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
00875     \textcolor{comment}{// generator vector used:}
00876     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00877       gg[ii]--;
00878     \}
00879 
00880     \textcolor{comment}{// Garbage collection for this loop:}
00881     \textcolor{keyword}{delete}[] ob;
00882     ob = \textcolor{keyword}{nullptr};
00883 
00884     \textcolor{keyword}{delete}[] ob\_bottom;
00885     ob\_bottom = \textcolor{keyword}{nullptr};
00886   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
00887 
00888 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00889 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
00890   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00891     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
00892       std::cout << std::setw(12) << prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
00893     \}
00894     std::cout << std::endl;
00895   \}
00896   std::cout << std::endl;
00897 \textcolor{preprocessor}{  #endif}
00898 \textcolor{preprocessor}{}
00899   \textcolor{keyword}{delete}[] gg;
00900   gg = \textcolor{keyword}{nullptr};
00901 
00902   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00903 \}
00904 
\hypertarget{mtk__grad__1d_8cc_source_l00905}{}\hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{00905} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{mtk::Grad1D::ComputeWeights}() \{
00906 
00907   \textcolor{comment}{// Matrix to copmpute the weights as in the CRSA.}
00908   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
00909 
00911 
00912   \textcolor{comment}{// Assemble the pi matrix using:}
00913   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
00914   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
00915   \textcolor{comment}{// 3. The scaled basis for the null-space.}
00916 
00917   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
00918 
00919   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
00920   \textcolor{comment}{// of the pi matrix:}
00921   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00922     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
00923       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*(2*(num\_bndy\_approxs\_ - 1) + (order\_accuracy\_/2 + 1)) + jj] =
00924         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
00925     \}
00926   \}
00927 
00928   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
00929 
00930   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
00931   \textcolor{comment}{// final pi matrix:}
00932   \textcolor{keyword}{auto} mm = 1;
00933   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < order\_accuracy\_; ++jj) \{
00934     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00935       \textcolor{keyword}{auto} de = (ii + mm)*(2*(num\_bndy\_approxs\_ - 1) +
00936         (order\_accuracy\_/2 + 1)) + jj;
00937       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[de] = coeffs\_interior\_[ii];
00938     \}
00939     ++mm;
00940   \}
00941 
00942   rat\_basis\_null\_space\_.OrderColMajor();
00943 
00944 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00945 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
00946   std::cout << rat\_basis\_null\_space\_ << std::endl;
00947 \textcolor{preprocessor}{  #endif}
00948 \textcolor{preprocessor}{}
00949   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
00950   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1);
00951        jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
00952     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00953       \textcolor{keyword}{auto} og =
00954         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
00955       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
00956       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
00957     \}
00958   \}
00959 
00960 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
00961 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00962   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00963     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00964   \}
00965   std::cout << std::endl << std::endl;
00966 \textcolor{preprocessor}{  #endif}
00967 \textcolor{preprocessor}{}
00968 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
00969 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
00970   std::cout << pi << std::endl;
00971 \textcolor{preprocessor}{  #endif}
00972 \textcolor{preprocessor}{}
00974 
00975   \textcolor{comment}{// This imposes the mimetic condition.}
00976 
00977   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
00978 
00979   \textcolor{keywordflow}{try} \{
00980     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00981   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00982     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00983       std::endl;
00984     std::cerr << memory\_allocation\_exception.what() << std::endl;
00985   \}
00986   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
00987 
00988   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00989   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
00990     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
00991     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
00992       aux\_xx += coeffs\_interior\_[jj];
00993     \}
00994     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
00995   \}
00996 
00998 
00999   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
01000 
01001   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
01002   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
01003   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
01004   \textcolor{comment}{// unique. We will use dgels\_.}
01005 
01006   \textcolor{keywordflow}{try} \{
01007     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01008   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01009     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01010       std::endl;
01011     std::cerr << memory\_allocation\_exception.what() << std::endl;
01012   \}
01013   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
01014 
01015   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_af6f78373aaf2136f0c78974d7c8de0a8}{num\_cols}() + 1\};
01016 
01017   \textcolor{comment}{// Preserve hh.}
01018   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
01019 
01020   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01021 
01022   \textcolor{keywordtype}{int} info\{
01023     \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(pi,
01024                                                     weights\_cbs\_, weights\_ld)
01025   \};
01026 
01027 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01028 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
01029     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01030   \} \textcolor{keywordflow}{else} \{
01031     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01032   \}
01033 \textcolor{preprocessor}{  #endif}
01034 \textcolor{preprocessor}{}
01035 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01036 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01037   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01038     std::cout << std::setw(11) << hh[ii] << std::endl;
01039   \}
01040   std::cout << std::endl;
01041 \textcolor{preprocessor}{  #endif}
01042 \textcolor{preprocessor}{}
01043   \textcolor{comment}{// Preserve the original weights for research.}
01044 
01045   \textcolor{keywordflow}{try} \{
01046     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01047   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01048     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01049       std::endl;
01050     std::cerr << memory\_allocation\_exception.what() << std::endl;
01051   \}
01052   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01053 
01054   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01055 
01056 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01057 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01058   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01059     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01060   \}
01061   std::cout << std::endl;
01062 \textcolor{preprocessor}{  #endif}
01063 \textcolor{preprocessor}{}
01065   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
01066 
01067     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01068 
01069     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01070     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\{std::numeric\_limits<mtk::Real>::infinity()\};
01071 
01073 
01074     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01075 
01076     \textcolor{comment}{// 6.1. Insert preliminary approximations to first set of columns.}
01077 
01078     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01079       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01080         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*(order\_accuracy\_) + jj] =
01081           prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01082       \}
01083     \}
01084 
01085     \textcolor{comment}{// 6.2. Skip a column and negate preliminary approximations.}
01086 
01087     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; jj++) \{
01088       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_approxs\_; ii++) \{
01089         \textcolor{keyword}{auto} de = (ii+ order\_accuracy\_ - num\_bndy\_approxs\_+ jj*order\_accuracy\_);
01090         \textcolor{keyword}{auto} og = (num\_bndy\_approxs\_ - ii + (jj)*num\_bndy\_approxs\_);
01091         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[de] = -prem\_apps\_[og];
01092       \}
01093     \}
01094 
01095     \textcolor{comment}{// 6.3. Flip negative columns up-down.}
01096 
01097     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ii++) \{
01098       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_ + 1; jj < order\_accuracy\_; jj++) \{
01099         \textcolor{keyword}{auto} aux = phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*order\_accuracy\_ + jj];
01100         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*order\_accuracy\_ + jj] =
01101           phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj];
01102         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj] = aux;
01103       \}
01104     \}
01105 
01106     \textcolor{comment}{// 6.4. Insert stencil.}
01107 
01108     \textcolor{keyword}{auto} mm = 0;
01109     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < num\_bndy\_approxs\_ +  1; jj++) \{
01110       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ii++) \{
01111         \textcolor{keywordflow}{if} (ii == 0) \{
01112           phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[jj] = 0.0;
01113         \} \textcolor{keywordflow}{else} \{
01114           phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(ii + mm)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii - 1];
01115         \}
01116       \}
01117       mm++;
01118     \}
01119 
01120 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01121 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"phi ="} << std::endl;
01122     std::cout << phi << std::endl;
01123 \textcolor{preprocessor}{    #endif}
01124 \textcolor{preprocessor}{}
01126 
01127     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01128 
01129     \textcolor{keywordflow}{try} \{
01130       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_approxs\_ - 1];
01131     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01132       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01133         std::endl;
01134       std::cerr << memory\_allocation\_exception.what() << std::endl;
01135     \}
01136     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*(num\_bndy\_approxs\_ - 1));
01137 
01138     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01139       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01140     \}
01141 
01142 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01143 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01144     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01145       std::cout << std::setw(12) << lamed[ii] << std::endl;
01146     \}
01147     std::cout << std::endl;
01148 \textcolor{preprocessor}{    #endif}
01149 \textcolor{preprocessor}{}
01150     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01151       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01152       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_ - 1; ++jj) \{
01153         temp = temp +
01154           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01155       \}
01156       hh[ii] = hh[ii] - temp;
01157     \}
01158 
01159 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01160 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01161     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01162       std::cout << std::setw(12) << hh[ii] << std::endl;
01163     \}
01164     std::cout << std::endl;
01165 \textcolor{preprocessor}{    #endif}
01166 \textcolor{preprocessor}{}
01168 
01169     \textcolor{keywordtype}{int} copy\_result\{\};  \textcolor{comment}{// Should I replace the solution... not for now.}
01170 
01171     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01172 
01173     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01174       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}(),
01175                                                           order\_accuracy\_ + 1,
01176                                                           order\_accuracy\_,
01177                                                           order\_accuracy\_,
01178                                                           hh,
01179                                                           weights\_cbs\_,
01180                                                           row\_,
01181                                                           mimetic\_threshold\_,
01182                                                           copy\_result);
01183       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\};
01184 
01185 \textcolor{preprocessor}{      #if MTK\_DEBUG\_LEVEL>0}
01186 \textcolor{preprocessor}{}      std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01187       std::cout << std::endl;
01188 \textcolor{preprocessor}{      #endif}
01189 \textcolor{preprocessor}{}
01190       \textcolor{keywordflow}{if} (aux < minnorm) \{
01191         minnorm = aux;
01192         minrow\_= row\_;
01193       \}
01194     \}
01195 
01196 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01197 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01198       std::endl;
01199     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01200       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01201     \}
01202     std::cout << std::endl;
01203 \textcolor{preprocessor}{    #endif}
01204 \textcolor{preprocessor}{}
01206 
01207     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01208     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01209     \textcolor{comment}{// chosen to be the new weights\_.}
01210 
01211 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01212 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm << \textcolor{stringliteral}{" found at row "} <<
01213       minrow\_ + 1 << std::endl;
01214     std::cout << std::endl;
01215 \textcolor{preprocessor}{    #endif}
01216 \textcolor{preprocessor}{}
01217     copy\_result = 1;
01218     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}(),
01219                                                         order\_accuracy\_ + 1,
01220                                                         order\_accuracy\_,
01221                                                         order\_accuracy\_,
01222                                                         hh,
01223                                                         weights\_cbs\_,
01224                                                         minrow\_,
01225                                                         mimetic\_threshold\_,
01226                                                         copy\_result);
01227     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\};
01228 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01229 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01230     std::cout << std::endl;
01231 \textcolor{preprocessor}{    #endif}
01232 \textcolor{preprocessor}{}
01233     \textcolor{keyword}{delete} [] lamed;
01234     lamed = \textcolor{keyword}{nullptr};
01235   \}
01236 
01237   \textcolor{keyword}{delete} [] hh;
01238   hh = \textcolor{keyword}{nullptr};
01239 
01240   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01241 \}
01242 
\hypertarget{mtk__grad__1d_8cc_source_l01243}{}\hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{01243} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{mtk::Grad1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01244 
01245 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01246 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"weights\_* + lambda ="} << std::endl;
01247   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01248     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01249   \}
01250   std::cout << std::endl;
01251 \textcolor{preprocessor}{  #endif}
01252 \textcolor{preprocessor}{}
01254 
01255   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01256 
01257   \textcolor{keywordflow}{try} \{
01258     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01259   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01260     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01261       std::endl;
01262     std::cerr << memory\_allocation\_exception.what() << std::endl;
01263   \}
01264   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01265 
01266   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01267     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01268   \}
01269 
01270 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01271 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01272   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01273     std::cout << std::setw(12) << lambda[ii] << std::endl;
01274   \}
01275   std::cout << std::endl;
01276 \textcolor{preprocessor}{  #endif}
01277 \textcolor{preprocessor}{}
01279 
01280   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01281 
01282   \textcolor{keywordflow}{try} \{
01283     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01284   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01285     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01286       std::endl;
01287     std::cerr << memory\_allocation\_exception.what() << std::endl;
01288   \}
01289   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01290 
01291   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01292     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01293   \}
01294 
01295 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01296 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01297   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01298     std::cout << std::setw(12) << alpha[ii] << std::endl;
01299   \}
01300   std::cout << std::endl;
01301 \textcolor{preprocessor}{  #endif}
01302 \textcolor{preprocessor}{}
01304 
01305   \textcolor{keywordflow}{try} \{
01306     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
01307   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01308     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01309       std::endl;
01310     std::cerr << memory\_allocation\_exception.what() << std::endl;
01311   \}
01312   memset(mim\_bndy\_,
01313          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
01314          \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
01315 
01316   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01317     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < (num\_bndy\_approxs\_ - 1); ++jj) \{
01318       mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj] =
01319         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj] +
01320         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01321     \}
01322   \}
01323 
01324   \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01325     mim\_bndy\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)] =
01326       prem\_apps\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)];
01327   \}
01328 
01329 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01330 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01331   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01332     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01333       std::cout << std::setw(13) << mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj];
01334     \}
01335     std::cout << std::endl;
01336   \}
01337   std::cout << std::endl;
01338 \textcolor{preprocessor}{  #endif}
01339 \textcolor{preprocessor}{}
01340   \textcolor{keyword}{delete}[] lambda;
01341   lambda = \textcolor{keyword}{nullptr};
01342 
01343   \textcolor{keyword}{delete}[] alpha;
01344   alpha = \textcolor{keyword}{nullptr};
01345 
01346   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01347 \}
01348 
\hypertarget{mtk__grad__1d_8cc_source_l01349}{}\hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{01349} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{mtk::Grad1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01350 
01351   \textcolor{comment}{// The output array will have this form:}
01352   \textcolor{comment}{// 1. The first entry of the array will contain the used order kk.}
01353   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01354   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01355   \textcolor{comment}{// 3. The third entry will contain a collection of weights.}
01356   \textcolor{comment}{// 4. The next dim\_null - 1 entries will contain the collections of}
01357   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01358 
01359   gradient\_length\_ = 1 + order\_accuracy\_ + order\_accuracy\_ +
01360     num\_bndy\_approxs\_*num\_bndy\_coeffs\_;
01361 
01362 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01363 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"gradient\_length\_ = "} << gradient\_length\_ << std::endl;
01364 \textcolor{preprocessor}{  #endif}
01365 \textcolor{preprocessor}{}
01366   \textcolor{keywordflow}{try} \{
01367     gradient\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[gradient\_length\_];
01368   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01369     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01370       std::endl;
01371     std::cerr << memory\_allocation\_exception.what() << std::endl;
01372   \}
01373   memset(gradient\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gradient\_[0])*gradient\_length\_);
01374 
01376 
01377   gradient\_[0] = order\_accuracy\_;
01378 
01381 
01382   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01383     gradient\_[ii + 1] = coeffs\_interior\_[ii];
01384   \}
01385 
01387 
01388   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01389     gradient\_[(order\_accuracy\_ + 1) + ii] = weights\_cbs\_[ii];
01390   \}
01391 
01394 
01395   \textcolor{keywordtype}{int} offset\{2*order\_accuracy\_ + 1\};
01396 
01397   \textcolor{keywordtype}{int} aux \{\}; \textcolor{comment}{// Auxiliary variable.}
01398 
01399   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01400     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ ; ii++) \{
01401       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; jj++) \{
01402         gradient\_[offset + aux] = mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01403         aux++;
01404       \}
01405     \}
01406   \} \textcolor{keywordflow}{else} \{
01407     gradient\_[offset + 0] = prem\_apps\_[0];
01408     gradient\_[offset + 1] = prem\_apps\_[1];
01409     gradient\_[offset + 2] = prem\_apps\_[2];
01410   \}
01411 
01412 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01413 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order grad built!"} << std::endl;
01414   std::cout << std::endl;
01415 \textcolor{preprocessor}{  #endif}
01416 \textcolor{preprocessor}{}
01417   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01418 \}
\end{DoxyCode}
