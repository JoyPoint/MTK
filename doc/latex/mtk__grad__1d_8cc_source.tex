\hypertarget{mtk__grad__1d_8cc_source}{\section{mtk\+\_\+grad\+\_\+1d.\+cc}
\label{mtk__grad__1d_8cc_source}\index{src/mtk\+\_\+grad\+\_\+1d.\+cc@{src/mtk\+\_\+grad\+\_\+1d.\+cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed, unless these modifications are made through the project's GitHub}
00025 \textcolor{comment}{page: http://www.csrc.sdsu.edu/mtk. Documentation related to said modifications}
00026 \textcolor{comment}{should be developed and included in any deliverable.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00029 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00030 \textcolor{comment}{}
00031 \textcolor{comment}{3. Redistributions in binary form must reproduce the above copyright notice,}
00032 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00033 \textcolor{comment}{other materials provided with the distribution.}
00034 \textcolor{comment}{}
00035 \textcolor{comment}{4. Usage of the binary form on proprietary applications shall require explicit}
00036 \textcolor{comment}{prior written permission from the the copyright holders, and due credit should}
00037 \textcolor{comment}{be given to the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{5. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 \textcolor{preprocessor}{#include <limits>}
00067 \textcolor{preprocessor}{#include <algorithm>}
00068 
00069 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00070 
00071 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00072 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00073 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00074 
00075 \textcolor{preprocessor}{#include "\hyperlink{mtk__grad__1d_8h}{mtk\_grad\_1d.h}"}
00076 
00077 \textcolor{keyword}{namespace }\hyperlink{namespacemtk}{mtk} \{
00078 
\hypertarget{mtk__grad__1d_8cc_source_l00079}{}\hyperlink{namespacemtk_a3f546b8a3743b8719db17e33f2d7ef7f}{00079} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Grad1D}{mtk::Grad1D} &in) \{
00080 
00082 
00083   stream << \textcolor{stringliteral}{"gradient\_[0] = "} << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[0] << std::endl;
00084 
00086 
00087   stream << \textcolor{stringliteral}{"gradient\_[1:"} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00088   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00089     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00090   \}
00091   stream << std::endl;
00092 
00094 
00095   stream << \textcolor{stringliteral}{"gradient\_["} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1 << \textcolor{stringliteral}{":"} <<
00096     2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00097   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00098     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00099   \}
00100   stream << std::endl;
00101 
00103 
00104   \textcolor{keywordtype}{int} offset\{2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1\};
00105   \textcolor{keywordtype}{int} mm \{\};
00106 
00107   stream << \textcolor{stringliteral}{"gradient\_["} << offset + mm << \textcolor{stringliteral}{":"} <<
00108     offset + mm + in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_} - 1 << \textcolor{stringliteral}{"] = "};
00109 
00110   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
00111     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Grad1D_abe15c1ffd9dfaba1a65f4f0e096287ce}{num\_bndy\_approxs\_} ; ++ii) \{
00112       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_}; jj++) \{
00113         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + (mm)];
00114         stream << std::setw(9) << value << \textcolor{stringliteral}{" "};
00115         mm++;
00116       \}
00117     \}
00118   \} \textcolor{keywordflow}{else} \{
00119     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] << \textcolor{charliteral}{' '};
00120     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] << \textcolor{charliteral}{' '};
00121     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2] << \textcolor{charliteral}{' '};
00122   \}
00123   stream << std::endl;
00124 
00125   \textcolor{keywordflow}{return} stream;
00126 \}
00127 \}
00128 
\hypertarget{mtk__grad__1d_8cc_source_l00129}{}\hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{00129} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}():
00130   order\_accuracy\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00131   dim\_null\_(),
00132   num\_bndy\_approxs\_(),
00133   num\_bndy\_coeffs\_(),
00134   gradient\_length\_(),
00135   minrow\_(),
00136   row\_(),
00137   coeffs\_interior\_(),
00138   prem\_apps\_(),
00139   weights\_crs\_(),
00140   weights\_cbs\_(),
00141   mim\_bndy\_(),
00142   gradient\_(),
00143   mimetic\_threshold\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}) \{\}
00144 
\hypertarget{mtk__grad__1d_8cc_source_l00145}{}\hyperlink{classmtk_1_1Grad1D_a5708bcb61bde3f7f3a4ddede191d82a4}{00145} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Grad1D}{Grad1D} &grad):
00146   order\_accuracy\_(grad.order\_accuracy\_),
00147   dim\_null\_(grad.dim\_null\_),
00148   num\_bndy\_approxs\_(grad.num\_bndy\_approxs\_),
00149   num\_bndy\_coeffs\_(grad.num\_bndy\_coeffs\_),
00150   gradient\_length\_(grad.gradient\_length\_),
00151   minrow\_(grad.minrow\_),
00152   row\_(grad.row\_),
00153   coeffs\_interior\_(grad.coeffs\_interior\_),
00154   prem\_apps\_(grad.prem\_apps\_),
00155   weights\_crs\_(grad.weights\_crs\_),
00156   weights\_cbs\_(grad.weights\_cbs\_),
00157   mim\_bndy\_(grad.mim\_bndy\_),
00158   gradient\_(grad.gradient\_),
00159   mimetic\_threshold\_(grad.mimetic\_threshold\_) \{\}
00160 
\hypertarget{mtk__grad__1d_8cc_source_l00161}{}\hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{00161} \hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{mtk::Grad1D::~Grad1D}() \{
00162 
00163   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00164   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00165 
00166   \textcolor{keyword}{delete}[] prem\_apps\_;
00167   prem\_apps\_ = \textcolor{keyword}{nullptr};
00168 
00169   \textcolor{keyword}{delete}[] weights\_crs\_;
00170   weights\_crs\_ = \textcolor{keyword}{nullptr};
00171 
00172   \textcolor{keyword}{delete}[] weights\_cbs\_;
00173   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00174 
00175   \textcolor{keyword}{delete}[] mim\_bndy\_;
00176   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00177 
00178   \textcolor{keyword}{delete}[] gradient\_;
00179   gradient\_ = \textcolor{keyword}{nullptr};
00180 \}
00181 
\hypertarget{mtk__grad__1d_8cc_source_l00182}{}\hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{00182} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{mtk::Grad1D::ConstructGrad1D}(\textcolor{keywordtype}{int} order\_accuracy, 
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} mimetic\_threshold) \{
00183 
00184 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00185   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00186   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00187   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00188                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00189 
00190   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
00191     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is high."} << std::endl;
00192   \}
00193 
00194   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;
00195   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;
00196 \textcolor{preprocessor}{  #endif}
00197 
00198   order\_accuracy\_ = order\_accuracy;
00199   mimetic\_threshold\_ = mimetic\_threshold;
00200 
00202   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00203 
00204 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00205   \textcolor{keywordflow}{if} (!abort\_construction) \{
00206     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;
00207     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00208     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00209   \}
00210 \textcolor{preprocessor}{  #endif}
00211 
00212   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00213   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00214 
00215   dim\_null\_ = order\_accuracy\_/2 - 1;
00216 
00217   num\_bndy\_approxs\_ = dim\_null\_ + 1;
00218 
00219 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00220   num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00221 \textcolor{preprocessor}{  #else}
00222   num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00223 \textcolor{preprocessor}{  #endif}
00224 
00226 
00227   \textcolor{comment}{// For this we will follow recommendations given in:}
00228   \textcolor{comment}{//}
00229   \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00230   \textcolor{comment}{//}
00231   \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00232   \textcolor{comment}{// following (MATLAB) pseudo-code:}
00233   \textcolor{comment}{//}
00234   \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00235   \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00236   \textcolor{comment}{//}
00237   \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00238   \textcolor{comment}{//}
00239   \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00240   \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00241   \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00242   \textcolor{comment}{// (west boundary).}
00243 
00244   \textcolor{comment}{// In the case of the gradient, the first Vandermonde system has a unique}
00245   \textcolor{comment}{// solution for the case of second-order-accuracy. Ergo, the Vandermonde}
00246   \textcolor{comment}{// matrix used to assemble said system, will have an empty null-space.}
00247 
00248   \textcolor{comment}{// Therefore, we only compute a rational basis for the case of order higher}
00249   \textcolor{comment}{// than second.}
00250 
00251   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00252 
00253     abort\_construction = ComputeRationalBasisNullSpace();
00254 
00255 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00256     \textcolor{keywordflow}{if} (!abort\_construction) \{
00257       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;
00258       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00259       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00260     \}
00261 \textcolor{preprocessor}{    #endif}
00262   \}
00263 
00265   abort\_construction = ComputePreliminaryApproximations();
00266 
00267 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00268   \textcolor{keywordflow}{if} (!abort\_construction) \{
00269     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;
00270     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00271     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00272   \}
00273 \textcolor{preprocessor}{  #endif}
00274 
00276   abort\_construction = ComputeWeights();
00277 
00278 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00279   \textcolor{keywordflow}{if} (!abort\_construction) \{
00280     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;
00281     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00282     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00283   \}
00284 \textcolor{preprocessor}{  #endif}
00285 
00287   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00288 
00289     abort\_construction = ComputeStencilBoundaryGrid();
00290 
00291 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00292     \textcolor{keywordflow}{if} (!abort\_construction) \{
00293       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;
00294       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00295       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00296     \}
00297 \textcolor{preprocessor}{    #endif}
00298   \}
00299 
00301 
00302   \textcolor{comment}{// Once we have the following three collections of data:}
00303   \textcolor{comment}{//   (a) the coefficients for the interior,}
00304   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00305   \textcolor{comment}{//   (c) and the weights (if it applies),}
00306   \textcolor{comment}{// we will store everything in the output array:}
00307 
00308   abort\_construction = AssembleOperator();
00309 
00310 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00311   \textcolor{keywordflow}{if} (!abort\_construction) \{
00312     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;
00313     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00314     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00315   \}
00316 \textcolor{preprocessor}{  #endif}
00317 
00318   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00319 \}
00320 
\hypertarget{mtk__grad__1d_8cc_source_l00321}{}\hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{00321} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{mtk::Grad1D::num\_bndy\_coeffs}()\textcolor{keyword}{ const }\{
00322 
00323   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00324 \}
00325 
\hypertarget{mtk__grad__1d_8cc_source_l00326}{}\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{00326} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{mtk::Grad1D::coeffs\_interior}()\textcolor{keyword}{ const }\{
00327 
00328   \textcolor{keywordflow}{return} coeffs\_interior\_;
00329 \}
00330 
\hypertarget{mtk__grad__1d_8cc_source_l00331}{}\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{00331} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{mtk::Grad1D::weights\_crs}()\textcolor{keyword}{ const }\{
00332 
00333   \textcolor{keywordflow}{return} weights\_crs\_;
00334 \}
00335 
\hypertarget{mtk__grad__1d_8cc_source_l00336}{}\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{00336} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{mtk::Grad1D::weights\_cbs}()\textcolor{keyword}{ const }\{
00337 
00338   \textcolor{keywordflow}{return} weights\_cbs\_;
00339 \}
00340 
\hypertarget{mtk__grad__1d_8cc_source_l00341}{}\hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{00341} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{mtk::Grad1D::mim\_bndy}()\textcolor{keyword}{ const }\{
00342 
00343   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} xx(dim\_null\_ + 1, 3*order\_accuracy\_/2);
00344 
00345   \textcolor{keyword}{auto} counter = 0;
00346   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_ + 1; ++ii) \{
00347     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < 3*order\_accuracy\_/2; ++jj) \{
00348       xx.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj, gradient\_[2*order\_accuracy\_ + 1 + counter]);
00349       counter++;
00350     \}
00351   \}
00352 
00353   \textcolor{keywordflow}{return} xx;
00354 \}
00355 
\hypertarget{mtk__grad__1d_8cc_source_l00356}{}\hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{00356} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} west,
00357                                                   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} east,
00358                                                   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00359 
00360   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00361 
00362 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00363   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(east < west, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00364   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00365   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00366 \textcolor{preprocessor}{  #endif}
00367 
00368   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} delta\_x = (east - west)/((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) num\_cells\_x);
00369 
00370   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/delta\_x\};
00371 
00372   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00373   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00374   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00375   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00376 
00377   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00378   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00379 
00381 
00382   \textcolor{keyword}{auto} ee\_index = 0;
00383   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00384     \textcolor{keyword}{auto} cc = 0;
00385     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00386       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00387         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00388       \} \textcolor{keywordflow}{else} \{
00389         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00390                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00391         cc++;
00392       \}
00393     \}
00394   \}
00395 
00397 
00398   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00399     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00400     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00401       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00402     \}
00403   \}
00404 
00406 
00407   ee\_index = 0;
00408   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00409     \textcolor{keyword}{auto} cc = 0;
00410     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00411       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00412         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00413       \} \textcolor{keywordflow}{else} \{
00414         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00415                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00416         cc++;
00417       \}
00418      \}
00419   \}
00420 
00421   \textcolor{keywordflow}{return} out;
00422 \}
00423 
\hypertarget{mtk__grad__1d_8cc_source_l00424}{}\hyperlink{classmtk_1_1Grad1D_a871a3b31e257b04d5e303b3211df3a73}{00424} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
00425   \textcolor{keyword}{const} \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid)\textcolor{keyword}{ const }\{
00426 
00427   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00428 
00429 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00430   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00431   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00432 \textcolor{preprocessor}{  #endif}
00433 
00434   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00435 
00436   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00437   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00438   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00439   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00440 
00441   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00442   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00443 
00445 
00446   \textcolor{keyword}{auto} ee\_index = 0;
00447   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00448     \textcolor{keyword}{auto} cc = 0;
00449     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00450       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00451         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00452       \} \textcolor{keywordflow}{else} \{
00453         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00454                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00455         cc++;
00456       \}
00457     \}
00458   \}
00459 
00461 
00462   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00463     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00464     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00465       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00466     \}
00467   \}
00468 
00470 
00471   ee\_index = 0;
00472   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00473     \textcolor{keyword}{auto} cc = 0;
00474     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00475       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00476         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00477       \} \textcolor{keywordflow}{else} \{
00478         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00479                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00480         cc++;
00481       \}
00482      \}
00483   \}
00484 
00485   \textcolor{keywordflow}{return} out;
00486 \}
00487 
\hypertarget{mtk__grad__1d_8cc_source_l00488}{}\hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{00488} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{mtk::Grad1D::ReturnAsDimensionlessDenseMatrix}
      (
00489   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00490 
00491   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00492 
00493 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00494   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00495   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00496 \textcolor{preprocessor}{  #endif}
00497 
00498   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00499   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00500   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00501   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00502 
00503   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00504   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00505 
00507 
00508   \textcolor{keyword}{auto} ee\_index = 0;
00509   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00510     \textcolor{keyword}{auto} cc = 0;
00511     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00512       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00513         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00514       \} \textcolor{keywordflow}{else} \{
00515         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00516                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00517         cc++;
00518       \}
00519     \}
00520   \}
00521 
00523 
00524   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00525     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00526     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00527       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]);
00528     \}
00529   \}
00530 
00532 
00533   ee\_index = 0;
00534   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00535     \textcolor{keyword}{auto} cc = 0;
00536     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00537       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00538         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00539       \} \textcolor{keywordflow}{else} \{
00540         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00541                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00542         cc++;
00543       \}
00544      \}
00545   \}
00546 
00547   \textcolor{keywordflow}{return} out;
00548 \}
00549 
\hypertarget{mtk__grad__1d_8cc_source_l00550}{}\hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{00550} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{mtk::Grad1D::ComputeStencilInteriorGrid}() \{
00551 
00553 
00554   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00555 
00556   \textcolor{keywordflow}{try} \{
00557     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00558   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00559     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00560       std::endl;
00561     std::cerr << memory\_allocation\_exception.what() << std::endl;
00562   \}
00563   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00564 
00565 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00566   pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00567 \textcolor{preprocessor}{  #else}
00568   pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00569 \textcolor{preprocessor}{  #endif}
00570 
00571   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00572     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00573   \}
00574 
00575 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00576   std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00577   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00578     std::cout << std::setw(12) << pp[ii];
00579   \}
00580   std::cout << std::endl << std::endl;
00581 \textcolor{preprocessor}{  #endif}
00582 
00584 
00585   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00586 
00587   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,order\_accuracy\_,order\_accuracy\_,transpose);
00588 
00589 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00590   std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00591   std::cout << vander\_matrix << std::endl << std::endl;
00592 \textcolor{preprocessor}{  #endif}
00593 
00595 
00596   \textcolor{keywordflow}{try} \{
00597     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00598   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00599     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00600       std::endl;
00601     std::cerr << memory\_allocation\_exception.what() << std::endl;
00602   \}
00603   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00604 
00605   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00606 
00607 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00608   std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00609   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00610     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00611   \}
00612   std::cout << std::endl;
00613 \textcolor{preprocessor}{  #endif}
00614 
00616 
00617   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00618                                                 coeffs\_interior\_)\};
00619 
00620 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00621   \textcolor{keywordflow}{if} (!info) \{
00622     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00623     std::cout << std::endl;
00624   \}
00625   \textcolor{keywordflow}{else} \{
00626     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00627     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00628     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00629   \}
00630 \textcolor{preprocessor}{  #endif}
00631 
00632 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00633   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00634   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00635     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00636   \}
00637   std::cout << std::endl << std::endl;
00638 \textcolor{preprocessor}{  #endif}
00639 
00640   \textcolor{keyword}{delete} [] pp;
00641   pp = \textcolor{keyword}{nullptr};
00642 
00643   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00644 \}
00645 
\hypertarget{mtk__grad__1d_8cc_source_l00646}{}\hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{00646} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{mtk::Grad1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00647 
00649 
00650   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00651 
00652   \textcolor{keywordflow}{try} \{
00653     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00654   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00655     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00656       std::endl;
00657     std::cerr << memory\_allocation\_exception.what() << std::endl;
00658   \}
00659   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00660 
00661 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00662   gg[1] = 1.0/2.0;
00663 \textcolor{preprocessor}{  #else}
00664   gg[1] = 1.0f/2.0f;
00665 \textcolor{preprocessor}{  #endif}
00666   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00667     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00668   \}
00669 
00670 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00671   std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00672   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00673     std::cout << std::setw(12) << gg[ii];
00674   \}
00675   std::cout << std::endl << std::endl;
00676 \textcolor{preprocessor}{  #endif}
00677 
00679 
00680   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00681 
00682   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00683 
00684 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00685   std::cout << \textcolor{stringliteral}{"aa\_west\_t ="} << std::endl;
00686   std::cout << aa\_west\_t << std::endl;
00687 \textcolor{preprocessor}{  #endif}
00688 
00690 
00691   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (aa\_west\_t));
00692 
00693 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00694   std::cout << \textcolor{stringliteral}{"qq\_t = "} << std::endl;
00695   std::cout << qq\_t << std::endl;
00696 \textcolor{preprocessor}{  #endif}
00697 
00699 
00700   \textcolor{keywordtype}{int} kk\_num\_rows\{num\_bndy\_coeffs\_\};
00701   \textcolor{keywordtype}{int} kk\_num\_cols\{dim\_null\_\};
00702 
00703   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} kk(kk\_num\_rows, kk\_num\_cols);
00704 
00705   \textcolor{comment}{// In the case of the gradient, even though we must solve for a null-space}
00706   \textcolor{comment}{// of dimension 2, we must only extract ONE basis for the kernel.}
00707   \textcolor{comment}{// We perform this extraction here:}
00708 
00709   \textcolor{keywordtype}{int} aux\_\{kk\_num\_rows - kk\_num\_cols\};
00710   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = kk\_num\_rows - kk\_num\_cols; ii < kk\_num\_rows; ii++) \{
00711     aux\_--;
00712     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < kk\_num\_rows; jj++) \{
00713       kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj*kk\_num\_cols + (kk\_num\_rows - kk\_num\_cols - aux\_ - 1)] =
00714         qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00715     \}
00716   \}
00717 
00718 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00719   std::cout << \textcolor{stringliteral}{"kk ="} << std::endl;
00720   std::cout << kk << std::endl;
00721   std::cout << \textcolor{stringliteral}{"kk.num\_rows() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a53f3afb3b6a8d21854458aaa9663cc74}{num\_rows}() << std::endl;
00722   std::cout << \textcolor{stringliteral}{"kk.num\_cols() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() << std::endl;
00723   std::cout << std::endl;
00724 \textcolor{preprocessor}{  #endif}
00725 
00727 
00728   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00729   \textcolor{comment}{// null-space, adopt the pattern we require.}
00730   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00731   \textcolor{comment}{//  scalers = kk(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00732   \textcolor{comment}{//  SK = kk*scalers}
00733   \textcolor{comment}{// where SK is the scaled null-space.}
00734 
00735   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00736   \textcolor{comment}{// in memory. We will create the matrix iden\_, and elements we wish to scale in}
00737   \textcolor{comment}{// the kk array. Using the concept of the leading dimension, we could just}
00738   \textcolor{comment}{// use kk, with the correct leading dimension and that is it. BUT I DO NOT}
00739   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00740   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00741   \textcolor{comment}{// whole kk:}
00742 
00743   \textcolor{comment}{// We will then create memory for that sub-matrix of kk (subk).}
00744 
00745   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} subk(dim\_null\_, dim\_null\_);
00746 
00747   \textcolor{keyword}{auto} zz = 0;
00748   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = order\_accuracy\_ + 1; ii < num\_bndy\_coeffs\_; ii++) \{
00749     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; jj++) \{
00750       subk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[zz*(dim\_null\_) + jj] = kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(dim\_null\_) + jj];
00751     \}
00752     zz++;
00753   \}
00754 
00755 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00756   std::cout << \textcolor{stringliteral}{"subk ="} << std::endl;
00757   std::cout << subk << std::endl;
00758 \textcolor{preprocessor}{  #endif}
00759 
00760   subk.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00761 
00762 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00763   std::cout << \textcolor{stringliteral}{"subk\_t ="} << std::endl;
00764   std::cout << subk << std::endl;
00765 \textcolor{preprocessor}{  #endif}
00766 
00767   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00768   tran = \textcolor{keyword}{false};
00769 
00770   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} iden(dim\_null\_, padded, tran);
00771 
00772 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00773   std::cout << \textcolor{stringliteral}{"iden ="} << std::endl;
00774   std::cout << iden << std::endl;
00775 \textcolor{preprocessor}{  #endif}
00776 
00777   \textcolor{comment}{// Solve the system to compute the scalers.}
00778   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00779   \textcolor{comment}{//}
00780   \textcolor{comment}{// subk*scalers = iden or}
00781   \textcolor{comment}{//}
00782   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00783   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00784   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00785   \textcolor{comment}{//}
00786   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00787   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00788   \textcolor{comment}{// will be stored in the created identity matrix.}
00789   \textcolor{comment}{// Let us first transpose subk (because of LAPACK):}
00790 
00791   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(subk, iden)\};
00792 
00793 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00794   \textcolor{keywordflow}{if} (!info) \{
00795     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00796       std::endl;
00797   \} \textcolor{keywordflow}{else} \{
00798     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00799       std::endl;
00800     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00801     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00802   \}
00803   std::cout << std::endl;
00804 \textcolor{preprocessor}{  #endif}
00805 
00806 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00807   std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00808   std::cout << iden << std::endl;
00809 \textcolor{preprocessor}{  #endif}
00810 
00811   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00812 
00813   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(kk, iden);
00814 
00815 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00816   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00817   std::cout << rat\_basis\_null\_space\_ << std::endl;
00818 \textcolor{preprocessor}{  #endif}
00819 
00820   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00821   \textcolor{comment}{// pattern we need! :)}
00822 
00823   \textcolor{keyword}{delete} [] gg;
00824   gg = \textcolor{keyword}{nullptr};
00825 
00826   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00827 \}
00828 
\hypertarget{mtk__grad__1d_8cc_source_l00829}{}\hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{00829} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{mtk::Grad1D::ComputePreliminaryApproximations}() \{
00830 
00832 
00833   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00834 
00835   \textcolor{keywordflow}{try} \{
00836     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00837   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00838     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00839       std::endl;
00840     std::cerr << memory\_allocation\_exception.what() << std::endl;
00841   \}
00842   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00843 
00844 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00845   gg[1] = 1.0/2.0;
00846 \textcolor{preprocessor}{  #else}
00847   gg[1] = 1.0f/2.0f;
00848 \textcolor{preprocessor}{  #endif}
00849   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00850     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00851   \}
00852 
00853 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00854   std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00855   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00856     std::cout << std::setw(12) << gg[ii];
00857   \}
00858   std::cout << std::endl << std::endl;
00859 \textcolor{preprocessor}{  #endif}
00860 
00861   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00862   \textcolor{keywordflow}{try} \{
00863     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
00864   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00865     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00866 std::endl;
00867     std::cerr << memory\_allocation\_exception.what() << std::endl;
00868   \}
00869   memset(prem\_apps\_,
00870          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00871          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
00872 
00874 
00875   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < num\_bndy\_approxs\_; ++ll) \{
00876 
00877     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00878 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00879     \textcolor{keywordflow}{if} (ll > 0) \{
00880       std::cout << \textcolor{stringliteral}{"gg"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00881       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00882         std::cout << std::setw(12) << gg[ii];
00883       \}
00884       std::cout << std::endl << std::endl;
00885     \}
00886 \textcolor{preprocessor}{    #endif}
00887 
00889 
00890     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00891 
00892     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa(gg,
00893                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00894                          transpose);
00895 
00896 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00897     std::cout << \textcolor{stringliteral}{"aa\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00898     std::cout << aa << std::endl;
00899 \textcolor{preprocessor}{    #endif}
00900 
00902 
00903     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00904 
00905     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00906 
00907     \textcolor{keywordflow}{try} \{
00908       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00909     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00910       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00911         std::endl;
00912       std::cerr << memory\_allocation\_exception.what() << std::endl;
00913     \}
00914     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00915 
00916     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00917 
00918 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00919     std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00920     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00921       std::cout << std::setw(12) << ob[ii] << std::endl;
00922     \}
00923     std::cout << std::endl;
00924 \textcolor{preprocessor}{    #endif}
00925 
00927 
00928     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00929     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00930     \textcolor{comment}{// our LAPACKAdapter class.}
00931 
00932     \textcolor{keywordtype}{int} info\_\{
00933       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(aa, ob
      , ob\_ld)\};
00934 
00935 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00936     \textcolor{keywordflow}{if} (!info\_) \{
00937       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00938     \} \textcolor{keywordflow}{else} \{
00939       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00940     \}
00941 \textcolor{preprocessor}{    #endif}
00942 
00943 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00944     std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00945     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00946       std::cout << std::setw(12) << ob[ii] << std::endl;
00947     \}
00948     std::cout << std::endl;
00949 \textcolor{preprocessor}{    #endif}
00950 
00952 
00953     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
00954     \textcolor{comment}{// for this operation.}
00955 
00957     \textcolor{comment}{// Save them into the ob\_bottom array:}
00958 
00959     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
00960 
00961     \textcolor{keywordflow}{try} \{
00962       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
00963     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00964       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00965         std::endl;
00966       std::cerr << memory\_allocation\_exception.what() << std::endl;
00967     \}
00968     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
00969 
00970     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00971       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
00972     \}
00973 
00974 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00975     std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
00976     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00977       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
00978     \}
00979     std::cout << std::endl;
00980 \textcolor{preprocessor}{    #endif}
00981 
00983 
00984     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
00985     \textcolor{comment}{// rat\_basis\_null\_space\_.}
00986     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
00987     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
00988     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
00989 
00990 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00991     std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00992     std::cout << rat\_basis\_null\_space\_ << std::endl;
00993 \textcolor{preprocessor}{    #endif}
00994 
00995     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00996     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00997 
00998     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
00999                                   ob\_bottom, beta, ob);
01000 
01001 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01002     std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
01003     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01004       std::cout << std::setw(12) << ob[ii] << std::endl;
01005     \}
01006     std::cout << std::endl;
01007 \textcolor{preprocessor}{    #endif}
01008 
01009     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
01010     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
01011     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
01012     \textcolor{comment}{// to implement.}
01013 
01014     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01015       prem\_apps\_[ii*num\_bndy\_approxs\_ + ll] = ob[ii];
01016     \}
01017 
01018     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
01019     \textcolor{comment}{// generator vector used:}
01020     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01021       gg[ii]--;
01022     \}
01023 
01024     \textcolor{comment}{// Garbage collection for this loop:}
01025     \textcolor{keyword}{delete}[] ob;
01026     ob = \textcolor{keyword}{nullptr};
01027 
01028     \textcolor{keyword}{delete}[] ob\_bottom;
01029     ob\_bottom = \textcolor{keyword}{nullptr};
01030   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
01031 
01032 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01033   std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
01034   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01035     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01036       std::cout << std::setw(12) << prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01037     \}
01038     std::cout << std::endl;
01039   \}
01040   std::cout << std::endl;
01041 \textcolor{preprocessor}{  #endif}
01042 
01043   \textcolor{keyword}{delete}[] gg;
01044   gg = \textcolor{keyword}{nullptr};
01045 
01046   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01047 \}
01048 
\hypertarget{mtk__grad__1d_8cc_source_l01049}{}\hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{01049} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{mtk::Grad1D::ComputeWeights}() \{
01050 
01051   \textcolor{comment}{// Matrix to copmpute the weights as in the CRSA.}
01052   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
01053 
01055 
01056   \textcolor{comment}{// Assemble the pi matrix using:}
01057   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
01058   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
01059   \textcolor{comment}{// 3. The scaled basis for the null-space.}
01060 
01061   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
01062 
01063   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
01064   \textcolor{comment}{// of the pi matrix:}
01065   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01066     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01067       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(2*(num\_bndy\_approxs\_ - 1) + (order\_accuracy\_/2 + 1)) + jj] =
01068         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01069     \}
01070   \}
01071 
01072   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
01073 
01074   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
01075   \textcolor{comment}{// final pi matrix:}
01076   \textcolor{keyword}{auto} mm = 1;
01077   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < order\_accuracy\_; ++jj) \{
01078     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01079       \textcolor{keyword}{auto} de = (ii + mm)*(2*(num\_bndy\_approxs\_ - 1) +
01080         (order\_accuracy\_/2 + 1)) + jj;
01081       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = coeffs\_interior\_[ii];
01082     \}
01083     ++mm;
01084   \}
01085 
01086   rat\_basis\_null\_space\_.OrderColMajor();
01087 
01088 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01089   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
01090   std::cout << rat\_basis\_null\_space\_ << std::endl;
01091 \textcolor{preprocessor}{  #endif}
01092 
01093   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
01094 
01095   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1);
01096        jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
01097     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01098       \textcolor{keyword}{auto} og =
01099         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
01100       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
01101       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
01102     \}
01103   \}
01104 
01105 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
01106   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
01107   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01108     std::cout << std::setw(12) << coeffs\_interior\_[ii];
01109   \}
01110   std::cout << std::endl << std::endl;
01111 \textcolor{preprocessor}{  #endif}
01112 
01113 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
01114   std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
01115   std::cout << pi << std::endl;
01116 \textcolor{preprocessor}{  #endif}
01117 
01119 
01120   \textcolor{comment}{// This imposes the mimetic condition.}
01121 
01122   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
01123 
01124   \textcolor{keywordflow}{try} \{
01125     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01126   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01127     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01128       std::endl;
01129     std::cerr << memory\_allocation\_exception.what() << std::endl;
01130   \}
01131   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
01132 
01133   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
01134   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
01135     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01136     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
01137       aux\_xx += coeffs\_interior\_[jj];
01138     \}
01139     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
01140   \}
01141 
01143 
01144   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
01145 
01146   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
01147   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
01148   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
01149   \textcolor{comment}{// unique. We will use dgels\_.}
01150 
01151   \textcolor{keywordflow}{try} \{
01152     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01153   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01154     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01155       std::endl;
01156     std::cerr << memory\_allocation\_exception.what() << std::endl;
01157   \}
01158   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
01159 
01160   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() + 1\};
01161 
01162   \textcolor{comment}{// Preserve hh.}
01163   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
01164 
01165   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01166 
01167   \textcolor{keywordtype}{int} info\{
01168     \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(pi,
01169                                                     weights\_cbs\_, weights\_ld)
01170   \};
01171 
01172 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01173   \textcolor{keywordflow}{if} (!info) \{
01174     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01175   \} \textcolor{keywordflow}{else} \{
01176     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01177   \}
01178 \textcolor{preprocessor}{  #endif}
01179 
01180 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01181   std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01182   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01183     std::cout << std::setw(11) << hh[ii] << std::endl;
01184   \}
01185   std::cout << std::endl;
01186 \textcolor{preprocessor}{  #endif}
01187 
01188   \textcolor{comment}{// Preserve the original weights for research.}
01189 
01190   \textcolor{keywordflow}{try} \{
01191     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01192   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01193     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01194       std::endl;
01195     std::cerr << memory\_allocation\_exception.what() << std::endl;
01196   \}
01197   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01198 
01199   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01200 
01201 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01202   std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01203   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01204     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01205   \}
01206   std::cout << std::endl;
01207 \textcolor{preprocessor}{  #endif}
01208 
01210 
01211   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
01212 
01213     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01214 
01215     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01216     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\{std::numeric\_limits<mtk::Real>::infinity()\};
01217 
01219 
01220     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01221 
01222     \textcolor{comment}{// 6.1. Insert preliminary approximations to first set of columns.}
01223 
01224     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01225       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01226         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(order\_accuracy\_) + jj] =
01227           prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01228       \}
01229     \}
01230 
01231     \textcolor{comment}{// 6.2. Skip a column and negate preliminary approximations.}
01232 
01233     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; jj++) \{
01234       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_approxs\_; ii++) \{
01235         \textcolor{keyword}{auto} de = (ii+ order\_accuracy\_ - num\_bndy\_approxs\_+ jj*order\_accuracy\_);
01236         \textcolor{keyword}{auto} og = (num\_bndy\_approxs\_ - ii + (jj)*num\_bndy\_approxs\_);
01237         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = -prem\_apps\_[og];
01238       \}
01239     \}
01240 
01241     \textcolor{comment}{// 6.3. Flip negative columns up-down.}
01242 
01243     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ii++) \{
01244       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_ + 1; jj < order\_accuracy\_; jj++) \{
01245         \textcolor{keyword}{auto} aux = phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj];
01246         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj] =
01247           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj];
01248         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj] = aux;
01249       \}
01250     \}
01251 
01252     \textcolor{comment}{// 6.4. Insert stencil.}
01253 
01254     \textcolor{keyword}{auto} mm = 0;
01255     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < num\_bndy\_approxs\_ +  1; jj++) \{
01256       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ii++) \{
01257         \textcolor{keywordflow}{if} (ii == 0) \{
01258           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj] = 0.0;
01259         \} \textcolor{keywordflow}{else} \{
01260           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(ii + mm)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii - 1];
01261         \}
01262       \}
01263       mm++;
01264     \}
01265 
01266 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01267     std::cout << \textcolor{stringliteral}{"phi ="} << std::endl;
01268     std::cout << phi << std::endl;
01269 \textcolor{preprocessor}{    #endif}
01270 
01272 
01273     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01274 
01275     \textcolor{keywordflow}{try} \{
01276       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_approxs\_ - 1];
01277     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01278       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01279         std::endl;
01280       std::cerr << memory\_allocation\_exception.what() << std::endl;
01281     \}
01282     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*(num\_bndy\_approxs\_ - 1));
01283 
01284     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01285       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01286     \}
01287 
01288 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01289     std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01290     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01291       std::cout << std::setw(12) << lamed[ii] << std::endl;
01292     \}
01293     std::cout << std::endl;
01294 \textcolor{preprocessor}{    #endif}
01295 
01296     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01297       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01298       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_ - 1; ++jj) \{
01299         temp = temp +
01300           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01301       \}
01302       hh[ii] = hh[ii] - temp;
01303     \}
01304 
01305 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01306     std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01307     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01308       std::cout << std::setw(12) << hh[ii] << std::endl;
01309     \}
01310     std::cout << std::endl;
01311 \textcolor{preprocessor}{    #endif}
01312 
01314 
01315     \textcolor{keywordtype}{int} copy\_result\{\};  \textcolor{comment}{// Should I replace the solution... not for now.}
01316 
01317     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01318 
01319     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01320       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01321                                                           order\_accuracy\_ + 1,
01322                                                           order\_accuracy\_,
01323                                                           order\_accuracy\_,
01324                                                           hh,
01325                                                           weights\_cbs\_,
01326                                                           row\_,
01327                                                           mimetic\_threshold\_,
01328                                                           copy\_result);
01329       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\};
01330 
01331 \textcolor{preprocessor}{      #if MTK\_DEBUG\_LEVEL>0}
01332       std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01333       std::cout << std::endl;
01334 \textcolor{preprocessor}{      #endif}
01335 
01336       \textcolor{keywordflow}{if} (aux < minnorm) \{
01337         minnorm = aux;
01338         minrow\_= row\_;
01339       \}
01340     \}
01341 
01342 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01343     std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01344       std::endl;
01345     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01346       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01347     \}
01348     std::cout << std::endl;
01349 \textcolor{preprocessor}{    #endif}
01350 
01352 
01353     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01354     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01355     \textcolor{comment}{// chosen to be the new weights\_.}
01356 
01357 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01358     std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm << \textcolor{stringliteral}{" found at row "} <<
01359       minrow\_ + 1 << std::endl;
01360     std::cout << std::endl;
01361 \textcolor{preprocessor}{    #endif}
01362 
01363     copy\_result = 1;
01364     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01365                                                         order\_accuracy\_ + 1,
01366                                                         order\_accuracy\_,
01367                                                         order\_accuracy\_,
01368                                                         hh,
01369                                                         weights\_cbs\_,
01370                                                         minrow\_,
01371                                                         mimetic\_threshold\_,
01372                                                         copy\_result);
01373     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\};
01374 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01375     std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01376     std::cout << std::endl;
01377 \textcolor{preprocessor}{    #endif}
01378 
01379     \textcolor{keyword}{delete} [] lamed;
01380     lamed = \textcolor{keyword}{nullptr};
01381   \}
01382 
01383   \textcolor{keyword}{delete} [] hh;
01384   hh = \textcolor{keyword}{nullptr};
01385 
01386   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01387 \}
01388 
\hypertarget{mtk__grad__1d_8cc_source_l01389}{}\hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{01389} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{mtk::Grad1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01390 
01391 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01392   std::cout << \textcolor{stringliteral}{"weights\_* + lambda ="} << std::endl;
01393   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01394     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01395   \}
01396   std::cout << std::endl;
01397 \textcolor{preprocessor}{  #endif}
01398 
01400 
01401   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01402 
01403   \textcolor{keywordflow}{try} \{
01404     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01405   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01406     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01407       std::endl;
01408     std::cerr << memory\_allocation\_exception.what() << std::endl;
01409   \}
01410   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01411 
01412   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01413     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01414   \}
01415 
01416 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01417   std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01418   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01419     std::cout << std::setw(12) << lambda[ii] << std::endl;
01420   \}
01421   std::cout << std::endl;
01422 \textcolor{preprocessor}{  #endif}
01423 
01425 
01426   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01427 
01428   \textcolor{keywordflow}{try} \{
01429     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01430   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01431     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01432       std::endl;
01433     std::cerr << memory\_allocation\_exception.what() << std::endl;
01434   \}
01435   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01436 
01437   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01438     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01439   \}
01440 
01441 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01442   std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01443   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01444     std::cout << std::setw(12) << alpha[ii] << std::endl;
01445   \}
01446   std::cout << std::endl;
01447 \textcolor{preprocessor}{  #endif}
01448 
01450 
01451   \textcolor{keywordflow}{try} \{
01452     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
01453   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01454     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01455       std::endl;
01456     std::cerr << memory\_allocation\_exception.what() << std::endl;
01457   \}
01458   memset(mim\_bndy\_,
01459          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
01460          \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
01461 
01462   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01463     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < (num\_bndy\_approxs\_ - 1); ++jj) \{
01464       mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj] =
01465         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj] +
01466         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01467     \}
01468   \}
01469 
01470   \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01471     mim\_bndy\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)] =
01472       prem\_apps\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)];
01473   \}
01474 
01475 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01476   std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01477   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01478     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01479       std::cout << std::setw(13) << mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj];
01480     \}
01481     std::cout << std::endl;
01482   \}
01483   std::cout << std::endl;
01484 \textcolor{preprocessor}{  #endif}
01485 
01486   \textcolor{keyword}{delete}[] lambda;
01487   lambda = \textcolor{keyword}{nullptr};
01488 
01489   \textcolor{keyword}{delete}[] alpha;
01490   alpha = \textcolor{keyword}{nullptr};
01491 
01492   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01493 \}
01494 
\hypertarget{mtk__grad__1d_8cc_source_l01495}{}\hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{01495} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{mtk::Grad1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01496 
01497   \textcolor{comment}{// The output array will have this form:}
01498   \textcolor{comment}{// 1. The first entry of the array will contain the used order kk.}
01499   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01500   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01501   \textcolor{comment}{// 3. The third entry will contain a collection of weights.}
01502   \textcolor{comment}{// 4. The next dim\_null - 1 entries will contain the collections of}
01503   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01504 
01505   gradient\_length\_ = 1 + order\_accuracy\_ + order\_accuracy\_ +
01506     num\_bndy\_approxs\_*num\_bndy\_coeffs\_;
01507 
01508 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01509   std::cout << \textcolor{stringliteral}{"gradient\_length\_ = "} << gradient\_length\_ << std::endl;
01510 \textcolor{preprocessor}{  #endif}
01511 
01512   \textcolor{keywordflow}{try} \{
01513     gradient\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[gradient\_length\_];
01514   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01515     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01516       std::endl;
01517     std::cerr << memory\_allocation\_exception.what() << std::endl;
01518   \}
01519   memset(gradient\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gradient\_[0])*gradient\_length\_);
01520 
01522 
01523   gradient\_[0] = order\_accuracy\_;
01524 
01527 
01528   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01529     gradient\_[ii + 1] = coeffs\_interior\_[ii];
01530   \}
01531 
01533 
01534   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01535     gradient\_[(order\_accuracy\_ + 1) + ii] = weights\_cbs\_[ii];
01536   \}
01537 
01540 
01541   \textcolor{keywordtype}{int} offset\{2*order\_accuracy\_ + 1\};
01542 
01543   \textcolor{keywordtype}{int} aux \{\}; \textcolor{comment}{// Auxiliary variable.}
01544 
01545   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01546     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ ; ii++) \{
01547       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; jj++) \{
01548         gradient\_[offset + aux] = mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01549         aux++;
01550       \}
01551     \}
01552   \} \textcolor{keywordflow}{else} \{
01553     gradient\_[offset + 0] = prem\_apps\_[0];
01554     gradient\_[offset + 1] = prem\_apps\_[1];
01555     gradient\_[offset + 2] = prem\_apps\_[2];
01556   \}
01557 
01558 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01559   std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order grad built!"} << std::endl;
01560   std::cout << std::endl;
01561 \textcolor{preprocessor}{  #endif}
01562 
01563   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01564 \}
\end{DoxyCode}
