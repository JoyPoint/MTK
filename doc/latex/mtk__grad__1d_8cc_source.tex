\hypertarget{mtk__grad__1d_8cc_source}{\section{mtk\+\_\+grad\+\_\+1d.\+cc}
\label{mtk__grad__1d_8cc_source}\index{src/mtk\+\_\+grad\+\_\+1d.\+cc@{src/mtk\+\_\+grad\+\_\+1d.\+cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed, unless these modifications are made through the project's GitHub}
00025 \textcolor{comment}{page: http://www.csrc.sdsu.edu/mtk. Documentation related to said modifications}
00026 \textcolor{comment}{should be developed and included in any deliverable.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00029 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00030 \textcolor{comment}{}
00031 \textcolor{comment}{3. Redistributions in binary form must reproduce the above copyright notice,}
00032 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00033 \textcolor{comment}{other materials provided with the distribution.}
00034 \textcolor{comment}{}
00035 \textcolor{comment}{4. Usage of the binary form on proprietary applications shall require explicit}
00036 \textcolor{comment}{prior written permission from the the copyright holders, and due credit should}
00037 \textcolor{comment}{be given to the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{5. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 
00067 \textcolor{preprocessor}{#ifdef MTK\_VERBOSE\_WEIGHTS}
00068 \textcolor{preprocessor}{#include <fstream>}
00069 \textcolor{preprocessor}{#endif}
00070 
00071 \textcolor{preprocessor}{#include <limits>}
00072 \textcolor{preprocessor}{#include <algorithm>}
00073 
00074 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00075 
00076 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00077 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00078 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00079 
00080 \textcolor{preprocessor}{#include "\hyperlink{mtk__grad__1d_8h}{mtk\_grad\_1d.h}"}
00081 
00082 \textcolor{keyword}{namespace }\hyperlink{namespacemtk}{mtk} \{
00083 
\hypertarget{mtk__grad__1d_8cc_source_l00084}{}\hyperlink{namespacemtk_a3f546b8a3743b8719db17e33f2d7ef7f}{00084} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Grad1D}{mtk::Grad1D} &in) \{
00085 
00086   \textcolor{keywordtype}{int} output\_precision\{4\};
00087   \textcolor{keywordtype}{int} output\_width\{8\};
00088 
00090 
00091   stream << \textcolor{stringliteral}{"Order of accuracy: "} << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[0] << std::endl;
00092 
00094 
00095   stream << \textcolor{stringliteral}{"Interior stencil: "} << std::endl;
00096   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00097     stream << std::setprecision(output\_precision) <<
00098         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{charliteral}{' '};
00099   \}
00100   stream << std::endl;
00101 
00103 
00104   stream << \textcolor{stringliteral}{"Weights:"} << std::endl;
00105   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00106     stream << std::setprecision(output\_precision) <<
00107         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{charliteral}{' '};
00108   \}
00109   stream << std::endl;
00110 
00112 
00113   \textcolor{keywordtype}{int} offset\{2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1\};
00114   \textcolor{keywordtype}{int} mm \{\};
00115   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
00116     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Grad1D_abe15c1ffd9dfaba1a65f4f0e096287ce}{num\_bndy\_approxs\_} ; ++ii) \{
00117       stream << \textcolor{stringliteral}{"Boundary row "} << ii + 1 << \textcolor{stringliteral}{":"} << std::endl;
00118       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_}; jj++) \{
00119         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + (mm)];
00120         stream << std::setprecision(output\_precision) <<
00121         std::setw(output\_width) << value << \textcolor{charliteral}{' '};
00122         mm++;
00123       \}
00124       stream << std::endl;
00125       stream << \textcolor{stringliteral}{"Sum of elements in boundary row "} << ii + 1 << \textcolor{stringliteral}{": "} <<
00126         in.\hyperlink{classmtk_1_1Grad1D_ab8858a35339ed7036083d25b23293737}{sums\_rows\_mim\_bndy\_}[ii];
00127       stream << std::endl;
00128     \}
00129   \} \textcolor{keywordflow}{else} \{
00130     stream << \textcolor{stringliteral}{"Boundary row 1:"} << std::endl;
00131     stream << std::setprecision(output\_precision) <<
00132         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] << \textcolor{charliteral}{' '};
00133     stream << std::setprecision(output\_precision) <<
00134         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] << \textcolor{charliteral}{' '};
00135     stream << std::setprecision(output\_precision) <<
00136         std::setw(output\_width) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2] << \textcolor{charliteral}{' '};
00137     stream << std::endl;
00138     stream << \textcolor{stringliteral}{"Sum of elements in boundary row 1: "} <<
00139       in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] + in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] +
00140         in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2];
00141     stream << std::endl;
00142   \}
00143 
00144   \textcolor{keywordflow}{return} stream;
00145 \}
00146 \}
00147 
\hypertarget{mtk__grad__1d_8cc_source_l00148}{}\hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{00148} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}():
00149   order\_accuracy\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00150   dim\_null\_(),
00151   num\_bndy\_approxs\_(),
00152   num\_bndy\_coeffs\_(),
00153   gradient\_length\_(),
00154   minrow\_(),
00155   row\_(),
00156   num\_feasible\_sols\_(),
00157   coeffs\_interior\_(),
00158   prem\_apps\_(),
00159   weights\_crs\_(),
00160   weights\_cbs\_(),
00161   mim\_bndy\_(),
00162   gradient\_(),
00163   mimetic\_threshold\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}),
00164   mimetic\_measure\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{kZero}),
00165   sums\_rows\_mim\_bndy\_() \{\}
00166 
\hypertarget{mtk__grad__1d_8cc_source_l00167}{}\hyperlink{classmtk_1_1Grad1D_a5708bcb61bde3f7f3a4ddede191d82a4}{00167} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Grad1D}{Grad1D} &grad):
00168   order\_accuracy\_(grad.order\_accuracy\_),
00169   dim\_null\_(grad.dim\_null\_),
00170   num\_bndy\_approxs\_(grad.num\_bndy\_approxs\_),
00171   num\_bndy\_coeffs\_(grad.num\_bndy\_coeffs\_),
00172   gradient\_length\_(grad.gradient\_length\_),
00173   minrow\_(grad.minrow\_),
00174   row\_(grad.row\_),
00175   num\_feasible\_sols\_(grad.num\_feasible\_sols\_),
00176   coeffs\_interior\_(grad.coeffs\_interior\_),
00177   prem\_apps\_(grad.prem\_apps\_),
00178   weights\_crs\_(grad.weights\_crs\_),
00179   weights\_cbs\_(grad.weights\_cbs\_),
00180   mim\_bndy\_(grad.mim\_bndy\_),
00181   gradient\_(grad.gradient\_),
00182   mimetic\_threshold\_(grad.mimetic\_threshold\_),
00183   mimetic\_measure\_(grad.mimetic\_measure\_),
00184   sums\_rows\_mim\_bndy\_(grad.sums\_rows\_mim\_bndy\_) \{\}
00185 
\hypertarget{mtk__grad__1d_8cc_source_l00186}{}\hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{00186} \hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{mtk::Grad1D::~Grad1D}() \{
00187 
00188   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00189   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00190 
00191   \textcolor{keyword}{delete}[] prem\_apps\_;
00192   prem\_apps\_ = \textcolor{keyword}{nullptr};
00193 
00194   \textcolor{keyword}{delete}[] weights\_crs\_;
00195   weights\_crs\_ = \textcolor{keyword}{nullptr};
00196 
00197   \textcolor{keyword}{delete}[] weights\_cbs\_;
00198   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00199 
00200   \textcolor{keyword}{delete}[] mim\_bndy\_;
00201   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00202 
00203   \textcolor{keyword}{delete}[] gradient\_;
00204   gradient\_ = \textcolor{keyword}{nullptr};
00205 \}
00206 
\hypertarget{mtk__grad__1d_8cc_source_l00207}{}\hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{00207} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{mtk::Grad1D::ConstructGrad1D}(\textcolor{keywordtype}{int} order\_accuracy, 
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} mimetic\_threshold) \{
00208 
00209 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00210   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00211   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00212   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00213                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00214 
00215   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
00216     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is high."} << std::endl;
00217   \}
00218 
00219   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;
00220   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;
00221 \textcolor{preprocessor}{  #endif}
00222 
00223   order\_accuracy\_ = order\_accuracy;
00224   mimetic\_threshold\_ = mimetic\_threshold;
00225 
00227   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00228 
00229 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00230   \textcolor{keywordflow}{if} (!abort\_construction) \{
00231     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;
00232     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00233     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00234   \}
00235 \textcolor{preprocessor}{  #endif}
00236 
00237   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00238   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00239 
00240   dim\_null\_ = order\_accuracy\_/2 - 1;
00241 
00242   num\_bndy\_approxs\_ = dim\_null\_ + 1;
00243 
00244 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00245   num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00246 \textcolor{preprocessor}{  #else}
00247   num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00248 \textcolor{preprocessor}{  #endif}
00249 
00251 
00252   \textcolor{comment}{// For this we will follow recommendations given in:}
00253   \textcolor{comment}{//}
00254   \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00255   \textcolor{comment}{//}
00256   \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00257   \textcolor{comment}{// following (MATLAB) pseudo-code:}
00258   \textcolor{comment}{//}
00259   \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00260   \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00261   \textcolor{comment}{//}
00262   \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00263   \textcolor{comment}{//}
00264   \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00265   \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00266   \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00267   \textcolor{comment}{// (west boundary).}
00268 
00269   \textcolor{comment}{// In the case of the gradient, the first Vandermonde system has a unique}
00270   \textcolor{comment}{// solution for the case of second-order-accuracy. Ergo, the Vandermonde}
00271   \textcolor{comment}{// matrix used to assemble said system, will have an empty null-space.}
00272 
00273   \textcolor{comment}{// Therefore, we only compute a rational basis for the case of order higher}
00274   \textcolor{comment}{// than second.}
00275 
00276   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00277 
00278     abort\_construction = ComputeRationalBasisNullSpace();
00279 
00280 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00281     \textcolor{keywordflow}{if} (!abort\_construction) \{
00282       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;
00283       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00284       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00285     \}
00286 \textcolor{preprocessor}{    #endif}
00287   \}
00288 
00290   abort\_construction = ComputePreliminaryApproximations();
00291 
00292 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00293   \textcolor{keywordflow}{if} (!abort\_construction) \{
00294     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;
00295     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00296     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00297   \}
00298 \textcolor{preprocessor}{  #endif}
00299 
00301   abort\_construction = ComputeWeights();
00302 
00303 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00304   \textcolor{keywordflow}{if} (!abort\_construction) \{
00305     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;
00306     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00307     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00308   \}
00309 \textcolor{preprocessor}{  #endif}
00310 
00312   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00313 
00314     abort\_construction = ComputeStencilBoundaryGrid();
00315 
00316 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00317     \textcolor{keywordflow}{if} (!abort\_construction) \{
00318       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;
00319       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00320       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00321     \}
00322 \textcolor{preprocessor}{    #endif}
00323   \}
00324 
00326 
00327   \textcolor{comment}{// Once we have the following three collections of data:}
00328   \textcolor{comment}{//   (a) the coefficients for the interior,}
00329   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00330   \textcolor{comment}{//   (c) and the weights (if it applies),}
00331   \textcolor{comment}{// we will store everything in the output array:}
00332 
00333   abort\_construction = AssembleOperator();
00334 
00335 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00336   \textcolor{keywordflow}{if} (!abort\_construction) \{
00337     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;
00338     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00339     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00340   \}
00341 \textcolor{preprocessor}{  #endif}
00342 
00343   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00344 \}
00345 
\hypertarget{mtk__grad__1d_8cc_source_l00346}{}\hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{00346} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{mtk::Grad1D::num\_bndy\_coeffs}()\textcolor{keyword}{ const }\{
00347 
00348   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00349 \}
00350 
\hypertarget{mtk__grad__1d_8cc_source_l00351}{}\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{00351} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{mtk::Grad1D::coeffs\_interior}()\textcolor{keyword}{ const }\{
00352 
00353   \textcolor{keywordflow}{return} coeffs\_interior\_;
00354 \}
00355 
\hypertarget{mtk__grad__1d_8cc_source_l00356}{}\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{00356} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{mtk::Grad1D::weights\_crs}()\textcolor{keyword}{ const }\{
00357 
00358   \textcolor{keywordflow}{return} weights\_crs\_;
00359 \}
00360 
\hypertarget{mtk__grad__1d_8cc_source_l00361}{}\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{00361} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{mtk::Grad1D::weights\_cbs}()\textcolor{keyword}{ const }\{
00362 
00363   \textcolor{keywordflow}{return} weights\_cbs\_;
00364 \}
00365 
\hypertarget{mtk__grad__1d_8cc_source_l00366}{}\hyperlink{classmtk_1_1Grad1D_a3ee5504c8fedaae9e58f00d3698f7986}{00366} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_a3ee5504c8fedaae9e58f00d3698f7986}{mtk::Grad1D::num\_feasible\_sols}()\textcolor{keyword}{ const }\{
00367 
00368   \textcolor{keywordflow}{return} num\_feasible\_sols\_;
00369 \}
00370 
\hypertarget{mtk__grad__1d_8cc_source_l00371}{}\hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{00371} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{mtk::Grad1D::mim\_bndy}()\textcolor{keyword}{ const }\{
00372 
00373   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} xx(dim\_null\_ + 1, 3*order\_accuracy\_/2);
00374 
00375   \textcolor{keyword}{auto} counter = 0;
00376   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_ + 1; ++ii) \{
00377     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < 3*order\_accuracy\_/2; ++jj) \{
00378       xx.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj, gradient\_[2*order\_accuracy\_ + 1 + counter]);
00379       counter++;
00380     \}
00381   \}
00382 
00383   \textcolor{keywordflow}{return} xx;
00384 \}
00385 
\hypertarget{mtk__grad__1d_8cc_source_l00386}{}\hyperlink{classmtk_1_1Grad1D_ab1c580e5e7f6fad9a0f643b48d3e0e55}{00386} std::vector<mtk::Real> \hyperlink{classmtk_1_1Grad1D_ab1c580e5e7f6fad9a0f643b48d3e0e55}{mtk::Grad1D::sums\_rows\_mim\_bndy}()\textcolor{keyword}{ const }\{
00387 
00388   \textcolor{keywordflow}{return} sums\_rows\_mim\_bndy\_;
00389 \}
00390 
\hypertarget{mtk__grad__1d_8cc_source_l00391}{}\hyperlink{classmtk_1_1Grad1D_a66bb2a8e60e685a0be897548ade3a6d6}{00391} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} \hyperlink{classmtk_1_1Grad1D_a66bb2a8e60e685a0be897548ade3a6d6}{mtk::Grad1D::mimetic\_measure}()\textcolor{keyword}{ const }\{
00392 
00393   \textcolor{keywordflow}{return} mimetic\_measure\_;
00394 \}
00395 
\hypertarget{mtk__grad__1d_8cc_source_l00396}{}\hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{00396} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} west,
00397                                                   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} east,
00398                                                   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00399 
00400   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00401 
00402 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00403   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(east < west, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00404   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00405   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00406 \textcolor{preprocessor}{  #endif}
00407 
00408   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} delta\_x = (east - west)/((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) num\_cells\_x);
00409 
00410   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/delta\_x\};
00411 
00412   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00413   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00414   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00415   \textcolor{keywordtype}{int} elements\_per\_extra\_row = num\_bndy\_coeffs\_;
00416 
00417   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00418   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00419 
00420   out.\hyperlink{classmtk_1_1DenseMatrix_ac0f824b0fec88c4fb42e77b7550fb0d3}{set\_encoded\_operator}(\hyperlink{namespacemtk_ga9b50023bfb2692219d2915feade94f80a90f70ea2675c36bd9b0b44a79f37a41f}{mtk::EncodedOperator::GRADIENT}
      );
00421 
00423 
00424   \textcolor{keyword}{auto} ee\_index = 0;
00425   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00426     \textcolor{keyword}{auto} cc = 0;
00427     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00428       \textcolor{keywordflow}{if}(cc >= elements\_per\_extra\_row) \{
00429         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00430       \} \textcolor{keywordflow}{else} \{
00431         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00432                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00433         cc++;
00434       \}
00435     \}
00436   \}
00437 
00439 
00440   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00441     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00442     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00443       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00444     \}
00445   \}
00446 
00448 
00449   ee\_index = 0;
00450   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00451     \textcolor{keyword}{auto} cc = 0;
00452     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00453       \textcolor{keywordflow}{if}(cc >= elements\_per\_extra\_row) \{
00454         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00455       \} \textcolor{keywordflow}{else} \{
00456         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00457                      -gradient\_[2*order\_accuracy\_ + 1 +
00458 ee\_index++]*inv\_delta\_x);
00459         cc++;
00460       \}
00461      \}
00462   \}
00463 
00464   \textcolor{keywordflow}{return} out;
00465 \}
00466 
\hypertarget{mtk__grad__1d_8cc_source_l00467}{}\hyperlink{classmtk_1_1Grad1D_a871a3b31e257b04d5e303b3211df3a73}{00467} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
00468   \textcolor{keyword}{const} \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid)\textcolor{keyword}{ const }\{
00469 
00470   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00471 
00472 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00473   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00474   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00475   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6f6a5a23011fe90971ed6b8f5f640cd2}{field\_nature}() != 
      \hyperlink{namespacemtk_ga4c54f2a329cfb4e56213b02a259d19e2a8f3d9a4b6a7b7f2c7afa61ca113d0db9}{mtk::FieldNature::SCALAR},
00476                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00477 \textcolor{preprocessor}{  #endif}
00478 
00479   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00480 
00481   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00482   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00483   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00484   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00485 
00486   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00487   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00488 
00489   out.\hyperlink{classmtk_1_1DenseMatrix_ac0f824b0fec88c4fb42e77b7550fb0d3}{set\_encoded\_operator}(\hyperlink{namespacemtk_ga9b50023bfb2692219d2915feade94f80a90f70ea2675c36bd9b0b44a79f37a41f}{mtk::EncodedOperator::GRADIENT}
      );
00490 
00492 
00493   \textcolor{keyword}{auto} ee\_index = 0;
00494   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00495     \textcolor{keyword}{auto} cc = 0;
00496     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00497       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00498         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00499       \} \textcolor{keywordflow}{else} \{
00500         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00501                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00502         cc++;
00503       \}
00504     \}
00505   \}
00506 
00508 
00509   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00510     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00511     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00512       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00513     \}
00514   \}
00515 
00517 
00518   ee\_index = 0;
00519   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00520     \textcolor{keyword}{auto} cc = 0;
00521     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00522       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00523         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00524       \} \textcolor{keywordflow}{else} \{
00525         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00526                     -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00527         cc++;
00528       \}
00529      \}
00530   \}
00531 
00532   \textcolor{keywordflow}{return} out;
00533 \}
00534 
\hypertarget{mtk__grad__1d_8cc_source_l00535}{}\hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{00535} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{mtk::Grad1D::ReturnAsDimensionlessDenseMatrix}
      (
00536   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00537 
00538   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00539 
00540 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00541   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00542   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00543 \textcolor{preprocessor}{  #endif}
00544 
00545   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00546   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00547   \textcolor{keywordtype}{int} elements\_per\_extra\_row = num\_bndy\_coeffs\_;
00548   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00549 
00550   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00551   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00552 
00553   out.\hyperlink{classmtk_1_1DenseMatrix_ac0f824b0fec88c4fb42e77b7550fb0d3}{set\_encoded\_operator}(\hyperlink{namespacemtk_ga9b50023bfb2692219d2915feade94f80a90f70ea2675c36bd9b0b44a79f37a41f}{mtk::EncodedOperator::GRADIENT}
      );
00554 
00556 
00557   \textcolor{keyword}{auto} ee\_index = 0;
00558   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00559     \textcolor{keyword}{auto} cc = 0;
00560     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00561       \textcolor{keywordflow}{if}(cc >= elements\_per\_extra\_row) \{
00562         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00563       \} \textcolor{keywordflow}{else} \{
00564         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00565                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00566         cc++;
00567       \}
00568     \}
00569   \}
00570 
00572 
00573   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00574     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00575     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00576       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]);
00577     \}
00578   \}
00579 
00581 
00582   ee\_index = 0;
00583   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00584     \textcolor{keyword}{auto} cc = 0;
00585     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00586       \textcolor{keywordflow}{if}(cc >= elements\_per\_extra\_row) \{
00587         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00588       \} \textcolor{keywordflow}{else} \{
00589         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00590                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00591         cc++;
00592       \}
00593      \}
00594   \}
00595 
00596   \textcolor{keywordflow}{return} out;
00597 \}
00598 
\hypertarget{mtk__grad__1d_8cc_source_l00599}{}\hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{00599} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{mtk::Grad1D::ComputeStencilInteriorGrid}() \{
00600 
00602 
00603   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00604 
00605   \textcolor{keywordflow}{try} \{
00606     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00607   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00608     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00609       std::endl;
00610     std::cerr << memory\_allocation\_exception.what() << std::endl;
00611   \}
00612   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00613 
00614 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00615   pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00616 \textcolor{preprocessor}{  #else}
00617   pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00618 \textcolor{preprocessor}{  #endif}
00619 
00620   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00621     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00622   \}
00623 
00624 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00625   std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00626   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00627     std::cout << std::setw(12) << pp[ii];
00628   \}
00629   std::cout << std::endl << std::endl;
00630 \textcolor{preprocessor}{  #endif}
00631 
00633 
00634   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00635 
00636   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,order\_accuracy\_,order\_accuracy\_,transpose);
00637 
00638 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00639   std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00640   std::cout << vander\_matrix << std::endl << std::endl;
00641 \textcolor{preprocessor}{  #endif}
00642 
00644 
00645   \textcolor{keywordflow}{try} \{
00646     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00647   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00648     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00649       std::endl;
00650     std::cerr << memory\_allocation\_exception.what() << std::endl;
00651   \}
00652   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00653 \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00654 
00655   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00656 
00657 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00658   std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00659   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00660     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00661   \}
00662   std::cout << std::endl;
00663 \textcolor{preprocessor}{  #endif}
00664 
00666 
00667   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00668                                                 coeffs\_interior\_)\};
00669 
00670 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00671   \textcolor{keywordflow}{if} (!info) \{
00672     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00673     std::cout << std::endl;
00674   \}
00675   \textcolor{keywordflow}{else} \{
00676     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00677     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00678     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00679   \}
00680 \textcolor{preprocessor}{  #endif}
00681 
00682 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00683   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00684   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00685     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00686   \}
00687   std::cout << std::endl << std::endl;
00688 \textcolor{preprocessor}{  #endif}
00689 
00690   \textcolor{keyword}{delete} [] pp;
00691   pp = \textcolor{keyword}{nullptr};
00692 
00693   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00694 \}
00695 
\hypertarget{mtk__grad__1d_8cc_source_l00696}{}\hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{00696} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{mtk::Grad1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00697 
00699 
00700   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00701 
00702   \textcolor{keywordflow}{try} \{
00703     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00704   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00705     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00706       std::endl;
00707     std::cerr << memory\_allocation\_exception.what() << std::endl;
00708   \}
00709   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00710 
00711 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00712   gg[1] = 1.0/2.0;
00713 \textcolor{preprocessor}{  #else}
00714   gg[1] = 1.0f/2.0f;
00715 \textcolor{preprocessor}{  #endif}
00716   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00717     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00718   \}
00719 
00720 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00721   std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00722   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00723     std::cout << std::setw(12) << gg[ii];
00724   \}
00725   std::cout << std::endl << std::endl;
00726 \textcolor{preprocessor}{  #endif}
00727 
00729 
00730   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00731 
00732   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00733 
00734 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00735   std::cout << \textcolor{stringliteral}{"aa\_west\_t ="} << std::endl;
00736   std::cout << aa\_west\_t << std::endl;
00737 \textcolor{preprocessor}{  #endif}
00738 
00740 
00741   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (aa\_west\_t));
00742 
00743 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00744   std::cout << \textcolor{stringliteral}{"qq\_t = "} << std::endl;
00745   std::cout << qq\_t << std::endl;
00746 \textcolor{preprocessor}{  #endif}
00747 
00749 
00750   \textcolor{keywordtype}{int} kk\_num\_rows\{num\_bndy\_coeffs\_\};
00751   \textcolor{keywordtype}{int} kk\_num\_cols\{dim\_null\_\};
00752 
00753   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} kk(kk\_num\_rows, kk\_num\_cols);
00754 
00755   \textcolor{comment}{// In the case of the gradient, even though we must solve for a null-space}
00756   \textcolor{comment}{// of dimension 2, we must only extract ONE basis for the kernel.}
00757   \textcolor{comment}{// We perform this extraction here:}
00758 
00759   \textcolor{keywordtype}{int} aux\_\{kk\_num\_rows - kk\_num\_cols\};
00760   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = kk\_num\_rows - kk\_num\_cols; ii < kk\_num\_rows; ii++) \{
00761     aux\_--;
00762     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < kk\_num\_rows; jj++) \{
00763       kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj*kk\_num\_cols + (kk\_num\_rows - kk\_num\_cols - aux\_ - 1)] =
00764         qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00765     \}
00766   \}
00767 
00768 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
00769   std::cout << \textcolor{stringliteral}{"kk ="} << std::endl;
00770   std::cout << kk << std::endl;
00771   std::cout << \textcolor{stringliteral}{"kk.num\_rows() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a53f3afb3b6a8d21854458aaa9663cc74}{num\_rows}() << std::endl;
00772   std::cout << \textcolor{stringliteral}{"kk.num\_cols() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() << std::endl;
00773   std::cout << std::endl;
00774 \textcolor{preprocessor}{  #endif}
00775 
00777 
00778   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00779   \textcolor{comment}{// null-space, adopt the pattern we require.}
00780   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00781   \textcolor{comment}{//  scalers = kk(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00782   \textcolor{comment}{//  SK = kk*scalers}
00783   \textcolor{comment}{// where SK is the scaled null-space.}
00784 
00785   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00786   \textcolor{comment}{// in memory. We will create the matrix iden\_, and elements we wish to scale}
00787   \textcolor{comment}{// in the kk array. Using the concept of the leading dimension, we could just}
00788   \textcolor{comment}{// use kk, with the correct leading dimension and that is it. BUT I DO NOT}
00789   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00790   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00791   \textcolor{comment}{// whole kk:}
00792 
00793   \textcolor{comment}{// We will then create memory for that sub-matrix of kk (subk).}
00794 
00795   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} subk(dim\_null\_, dim\_null\_);
00796 
00797   \textcolor{keyword}{auto} zz = 0;
00798   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = order\_accuracy\_ + 1; ii < num\_bndy\_coeffs\_; ii++) \{
00799     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; jj++) \{
00800       subk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[zz*(dim\_null\_) + jj] = kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(dim\_null\_) + jj];
00801     \}
00802     zz++;
00803   \}
00804 
00805 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00806   std::cout << \textcolor{stringliteral}{"subk ="} << std::endl;
00807   std::cout << subk << std::endl;
00808 \textcolor{preprocessor}{  #endif}
00809 
00810   subk.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00811 
00812 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00813   std::cout << \textcolor{stringliteral}{"subk\_t ="} << std::endl;
00814   std::cout << subk << std::endl;
00815 \textcolor{preprocessor}{  #endif}
00816 
00817   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00818   tran = \textcolor{keyword}{false};
00819 
00820   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} iden(dim\_null\_, padded, tran);
00821 
00822 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00823   std::cout << \textcolor{stringliteral}{"iden ="} << std::endl;
00824   std::cout << iden << std::endl;
00825 \textcolor{preprocessor}{  #endif}
00826 
00827   \textcolor{comment}{// Solve the system to compute the scalers.}
00828   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00829   \textcolor{comment}{//}
00830   \textcolor{comment}{// subk*scalers = iden or}
00831   \textcolor{comment}{//}
00832   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00833   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00834   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00835   \textcolor{comment}{//}
00836   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00837   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00838   \textcolor{comment}{// will be stored in the created identity matrix.}
00839   \textcolor{comment}{// Let us first transpose subk (because of LAPACK):}
00840 
00841   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(subk, iden)\};
00842 
00843 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00844   \textcolor{keywordflow}{if} (!info) \{
00845     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00846       std::endl;
00847   \} \textcolor{keywordflow}{else} \{
00848     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00849       std::endl;
00850     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00851     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00852   \}
00853   std::cout << std::endl;
00854 \textcolor{preprocessor}{  #endif}
00855 
00856 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00857   std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00858   std::cout << iden << std::endl;
00859 \textcolor{preprocessor}{  #endif}
00860 
00861   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00862 
00863   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(kk, iden);
00864 
00865 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00866   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00867   std::cout << rat\_basis\_null\_space\_ << std::endl;
00868 \textcolor{preprocessor}{  #endif}
00869 
00870   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00871   \textcolor{comment}{// pattern we need! :)}
00872 
00873   \textcolor{keyword}{delete} [] gg;
00874   gg = \textcolor{keyword}{nullptr};
00875 
00876   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00877 \}
00878 
\hypertarget{mtk__grad__1d_8cc_source_l00879}{}\hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{00879} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{mtk::Grad1D::ComputePreliminaryApproximations}() \{
00880 
00882 
00883   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00884 
00885   \textcolor{keywordflow}{try} \{
00886     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00887   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00888     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00889       std::endl;
00890     std::cerr << memory\_allocation\_exception.what() << std::endl;
00891   \}
00892   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00893 
00894 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00895   gg[1] = 1.0/2.0;
00896 \textcolor{preprocessor}{  #else}
00897   gg[1] = 1.0f/2.0f;
00898 \textcolor{preprocessor}{  #endif}
00899   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00900     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00901   \}
00902 
00903 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00904   std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00905   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00906     std::cout << std::setw(12) << gg[ii];
00907   \}
00908   std::cout << std::endl << std::endl;
00909 \textcolor{preprocessor}{  #endif}
00910 
00911   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00912   \textcolor{keywordflow}{try} \{
00913     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
00914   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00915     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00916 std::endl;
00917     std::cerr << memory\_allocation\_exception.what() << std::endl;
00918   \}
00919   memset(prem\_apps\_,
00920          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00921          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
00922 
00924 
00925   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < num\_bndy\_approxs\_; ++ll) \{
00926 
00927     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00928 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00929     \textcolor{keywordflow}{if} (ll > 0) \{
00930       std::cout << \textcolor{stringliteral}{"gg\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00931       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00932         std::cout << std::setw(12) << gg[ii];
00933       \}
00934       std::cout << std::endl << std::endl;
00935     \}
00936 \textcolor{preprocessor}{    #endif}
00937 
00939 
00940     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00941 
00942     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa(gg,
00943                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00944                          transpose);
00945 
00946 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
00947     std::cout << \textcolor{stringliteral}{"aa\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00948     std::cout << aa << std::endl;
00949 \textcolor{preprocessor}{    #endif}
00950 
00952 
00953     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00954 
00955     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00956 
00957     \textcolor{keywordflow}{try} \{
00958       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00959     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00960       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00961         std::endl;
00962       std::cerr << memory\_allocation\_exception.what() << std::endl;
00963     \}
00964     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00965 
00966     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00967 
00968 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00969     std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00970     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00971       std::cout << std::setw(12) << ob[ii] << std::endl;
00972     \}
00973     std::cout << std::endl;
00974 \textcolor{preprocessor}{    #endif}
00975 
00977 
00978     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00979     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00980     \textcolor{comment}{// our LAPACKAdapter class.}
00981 
00982     \textcolor{keywordtype}{int} info\_\{
00983       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(aa, ob
      , ob\_ld)\};
00984 
00985 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00986     \textcolor{keywordflow}{if} (!info\_) \{
00987       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00988     \} \textcolor{keywordflow}{else} \{
00989       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00990       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00991     \}
00992 \textcolor{preprocessor}{    #endif}
00993 
00994 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00995     std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00996     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00997       std::cout << std::setw(12) << ob[ii] << std::endl;
00998     \}
00999     std::cout << std::endl;
01000 \textcolor{preprocessor}{    #endif}
01001 
01003 
01004     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
01005     \textcolor{comment}{// for this operation.}
01006 
01008     \textcolor{comment}{// Save them into the ob\_bottom array:}
01009 
01010     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
01011 
01012     \textcolor{keywordflow}{try} \{
01013       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01014     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01015       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01016         std::endl;
01017       std::cerr << memory\_allocation\_exception.what() << std::endl;
01018     \}
01019     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
01020 
01021     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01022       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
01023     \}
01024 
01025 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01026     std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
01027     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01028       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
01029     \}
01030     std::cout << std::endl;
01031 \textcolor{preprocessor}{    #endif}
01032 
01034 
01035     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
01036     \textcolor{comment}{// rat\_basis\_null\_space\_.}
01037     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
01038     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
01039     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
01040 
01041 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
01042     std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
01043     std::cout << rat\_basis\_null\_space\_ << std::endl;
01044 \textcolor{preprocessor}{    #endif}
01045 
01046     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01047     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01048 
01049     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
01050                                   ob\_bottom, beta, ob);
01051 
01052 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01053     std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
01054     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01055       std::cout << std::setw(12) << ob[ii] << std::endl;
01056     \}
01057     std::cout << std::endl;
01058 \textcolor{preprocessor}{    #endif}
01059 
01060     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
01061     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
01062     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
01063     \textcolor{comment}{// to implement.}
01064 
01065     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01066       prem\_apps\_[ii*num\_bndy\_approxs\_ + ll] = ob[ii];
01067     \}
01068 
01069     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
01070     \textcolor{comment}{// generator vector used:}
01071     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01072       gg[ii]--;
01073     \}
01074 
01075     \textcolor{comment}{// Garbage collection for this loop:}
01076     \textcolor{keyword}{delete}[] ob;
01077     ob = \textcolor{keyword}{nullptr};
01078 
01079     \textcolor{keyword}{delete}[] ob\_bottom;
01080     ob\_bottom = \textcolor{keyword}{nullptr};
01081   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
01082 
01083 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01084   std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
01085   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01086     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01087       std::cout << std::setw(12) << prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01088     \}
01089     std::cout << std::endl;
01090   \}
01091   std::cout << std::endl;
01092 \textcolor{preprocessor}{  #endif}
01093 
01094   \textcolor{keyword}{delete}[] gg;
01095   gg = \textcolor{keyword}{nullptr};
01096 
01097   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01098 \}
01099 
\hypertarget{mtk__grad__1d_8cc_source_l01100}{}\hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{01100} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{mtk::Grad1D::ComputeWeights}() \{
01101 
01102   \textcolor{comment}{// Matrix to compute the weights as in the CRSA.}
01103   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
01104 
01106 
01107   \textcolor{comment}{// Assemble the pi matrix using:}
01108   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
01109   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
01110   \textcolor{comment}{// 3. The scaled basis for the null-space.}
01111 
01112   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
01113 
01114   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
01115   \textcolor{comment}{// of the pi matrix:}
01116   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01117     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01118       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(2*(num\_bndy\_approxs\_ - 1) + (order\_accuracy\_/2 + 1)) + jj] =
01119         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01120     \}
01121   \}
01122 
01123   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
01124 
01125   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
01126   \textcolor{comment}{// final pi matrix:}
01127   \textcolor{keyword}{auto} mm = 1;
01128   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < order\_accuracy\_; ++jj) \{
01129     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01130       \textcolor{keyword}{auto} de = (ii + mm)*(2*(num\_bndy\_approxs\_ - 1) +
01131         (order\_accuracy\_/2 + 1)) + jj;
01132       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = coeffs\_interior\_[ii];
01133     \}
01134     ++mm;
01135   \}
01136 
01137   rat\_basis\_null\_space\_.OrderColMajor();
01138 
01139 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01140   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
01141   std::cout << rat\_basis\_null\_space\_ << std::endl;
01142 \textcolor{preprocessor}{  #endif}
01143 
01144   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
01145 
01146   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1);
01147        jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
01148     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01149       \textcolor{keyword}{auto} og =
01150         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
01151       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
01152       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
01153     \}
01154   \}
01155 
01156 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01157   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
01158   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01159     std::cout << std::setw(12) << coeffs\_interior\_[ii];
01160   \}
01161   std::cout << std::endl << std::endl;
01162 \textcolor{preprocessor}{  #endif}
01163 
01164 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01165   std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
01166   std::cout << pi << std::endl;
01167 \textcolor{preprocessor}{  #endif}
01168 
01170 
01171   \textcolor{comment}{// This imposes the mimetic condition.}
01172 
01173   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
01174 
01175   \textcolor{keywordflow}{try} \{
01176     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01177   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01178     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01179       std::endl;
01180     std::cerr << memory\_allocation\_exception.what() << std::endl;
01181   \}
01182   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
01183 
01184   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
01185   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
01186     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01187     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
01188       aux\_xx += coeffs\_interior\_[jj];
01189     \}
01190     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
01191   \}
01192 
01194 
01195   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
01196 
01197   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
01198   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
01199   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
01200   \textcolor{comment}{// unique. We will use dgels\_.}
01201 
01202   \textcolor{keywordflow}{try} \{
01203     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01204   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01205     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01206       std::endl;
01207     std::cerr << memory\_allocation\_exception.what() << std::endl;
01208   \}
01209   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
01210 
01211   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() + 1\};
01212 
01213   \textcolor{comment}{// Preserve hh.}
01214   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
01215 
01216   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01217 
01218   \textcolor{keywordtype}{int} info\{
01219     \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(pi,
01220                                                     weights\_cbs\_, weights\_ld)
01221   \};
01222 
01223 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
01224   \textcolor{keywordflow}{if} (!info) \{
01225     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01226   \} \textcolor{keywordflow}{else} \{
01227     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01228     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
01229   \}
01230 \textcolor{preprocessor}{  #endif}
01231 
01232 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01233   std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01234   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01235     std::cout << std::setw(11) << hh[ii] << std::endl;
01236   \}
01237   std::cout << std::endl;
01238 \textcolor{preprocessor}{  #endif}
01239 
01240   \textcolor{comment}{// Preserve the original weights for research.}
01241 
01242   \textcolor{keywordflow}{try} \{
01243     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01244   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01245     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01246       std::endl;
01247     std::cerr << memory\_allocation\_exception.what() << std::endl;
01248   \}
01249   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01250 
01251   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01252 
01253 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01254   std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01255   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01256     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01257   \}
01258   std::cout << std::endl;
01259 \textcolor{preprocessor}{  #endif}
01260 
01262 
01263   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
01264 
01266 
01267     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01268 
01269     \textcolor{comment}{// 6.1. Insert preliminary approximations to first set of columns.}
01270 
01271     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01272       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01273         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(order\_accuracy\_) + jj] =
01274           prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01275       \}
01276     \}
01277 
01278     \textcolor{comment}{// 6.2. Skip a column and negate preliminary approximations.}
01279 
01280     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; jj++) \{
01281       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_approxs\_; ii++) \{
01282         \textcolor{keyword}{auto} de = (ii+ order\_accuracy\_ - num\_bndy\_approxs\_+ jj*order\_accuracy\_);
01283         \textcolor{keyword}{auto} og = (num\_bndy\_approxs\_ - ii + (jj)*num\_bndy\_approxs\_);
01284         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = -prem\_apps\_[og];
01285       \}
01286     \}
01287 
01288     \textcolor{comment}{// 6.3. Flip negative columns up-down.}
01289 
01290     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ii++) \{
01291       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_ + 1; jj < order\_accuracy\_; jj++) \{
01292         \textcolor{keyword}{auto} aux = phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj];
01293         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj] =
01294           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj];
01295         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj] = aux;
01296       \}
01297     \}
01298 
01299     \textcolor{comment}{// 6.4. Insert stencil.}
01300 
01301     \textcolor{keyword}{auto} mm = 0;
01302     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < num\_bndy\_approxs\_ +  1; jj++) \{
01303       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ii++) \{
01304         \textcolor{keywordflow}{if} (ii == 0) \{
01305           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj] = 0.0;
01306         \} \textcolor{keywordflow}{else} \{
01307           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(ii + mm)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii - 1];
01308         \}
01309       \}
01310       mm++;
01311     \}
01312 
01313 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
01314     std::cout << \textcolor{stringliteral}{"phi ="} << std::endl;
01315     std::cout << phi << std::endl;
01316 \textcolor{preprocessor}{    #endif}
01317 
01319 
01320     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01321 
01322     \textcolor{keywordflow}{try} \{
01323       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_approxs\_ - 1];
01324     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01325       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01326         std::endl;
01327       std::cerr << memory\_allocation\_exception.what() << std::endl;
01328     \}
01329     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*(num\_bndy\_approxs\_ - 1));
01330 
01331     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01332       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01333     \}
01334 
01335 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01336     std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01337     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01338       std::cout << std::setw(12) << lamed[ii] << std::endl;
01339     \}
01340     std::cout << std::endl;
01341 \textcolor{preprocessor}{    #endif}
01342 
01343     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01344       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01345       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_ - 1; ++jj) \{
01346         temp = temp +
01347           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01348       \}
01349       hh[ii] = hh[ii] - temp;
01350     \}
01351 
01352 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01353     std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01354     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01355       std::cout << std::setw(12) << hh[ii] << std::endl;
01356     \}
01357     std::cout << std::endl;
01358 \textcolor{preprocessor}{    #endif}
01359 
01361 
01362 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01363     \textcolor{keywordtype}{int} copy\_result\{1\};
01364 \textcolor{preprocessor}{    #else}
01365     \textcolor{keywordtype}{int} copy\_result\{\};
01366 \textcolor{preprocessor}{    #endif}
01367 
01368     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01369 
01370     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01371     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\{std::numeric\_limits<mtk::Real>::infinity()\};
01372 
01373     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01374 
01375 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01376     std::ofstream table(\textcolor{stringliteral}{"grad\_1d\_"} + std::to\_string(order\_accuracy\_) +
01377       \textcolor{stringliteral}{"\_weights.tex"});
01378 
01379     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)begin\{tabular\}[c]\{c"};
01380     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01381       table << \textcolor{charliteral}{'c'};
01382     \}
01383     table << \textcolor{stringliteral}{":c\}\(\backslash\)n\(\backslash\)\(\backslash\)toprule\(\backslash\)nRow & "};
01384     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01385       table << \textcolor{stringliteral}{"$ q\_\{"} + std::to\_string(ii) + \textcolor{stringliteral}{"\}$ &"};
01386     \}
01387     table << \textcolor{stringliteral}{" Relative error \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)midrule\(\backslash\)n"};
01388 \textcolor{preprocessor}{    #endif}
01389 
01390     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01391       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a0c9ebb125445bc5af752bf4fb47f44b2}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01392                                                           order\_accuracy\_ + 1,
01393                                                           order\_accuracy\_,
01394                                                           order\_accuracy\_,
01395                                                           hh,
01396                                                           weights\_cbs\_,
01397                                                           row\_,
01398                                                           mimetic\_threshold\_,
01399                                                           copy\_result);
01400       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\};
01401 
01402 \textcolor{preprocessor}{      #if MTK\_VERBOSE\_LEVEL > 2}
01403       std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01404       std::cout << std::endl;
01405 \textcolor{preprocessor}{      #endif}
01406 
01407       num\_feasible\_sols\_ = num\_feasible\_sols\_ +
01408         (int) (normerr\_ != std::numeric\_limits<mtk::Real>::infinity());
01409 
01410       \textcolor{keywordflow}{if} (aux < minnorm) \{
01411         minnorm = aux;
01412         minrow\_= row\_;
01413       \}
01414 
01415 \textcolor{preprocessor}{      #ifdef MTK\_VERBOSE\_WEIGHTS}
01416       table << std::to\_string(row\_ + 1) << \textcolor{stringliteral}{" & "};
01417       \textcolor{keywordflow}{if} (normerr\_ != std::numeric\_limits<mtk::Real>::infinity()) \{
01418         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01419           table << std::to\_string(weights\_cbs\_[ii - 1]) + \textcolor{stringliteral}{" & "};
01420         \}
01421         table << std::to\_string(aux) << \textcolor{stringliteral}{" \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01422       \} \textcolor{keywordflow}{else} \{
01423         table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)multicolumn\{"} << std::to\_string(order\_accuracy\_) <<
01424           \textcolor{stringliteral}{"\}\{c\}\{$\(\backslash\)\(\backslash\)emptyset$\} & "};
01425         table << \textcolor{stringliteral}{" - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01426       \}
01427 \textcolor{preprocessor}{      #endif}
01428     \}
01429 
01430 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01431     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)midrule"} << std::endl;
01432     table << \textcolor{stringliteral}{"CRS weights:"};
01433     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01434       table << \textcolor{stringliteral}{" & "} << std::to\_string(weights\_crs\_[ii - 1]);
01435     \}
01436     table << \textcolor{stringliteral}{" & - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)bottomrule\(\backslash\)n\(\backslash\)\(\backslash\)end\{tabular\}"} << std::endl;
01437     table.close();
01438 \textcolor{preprocessor}{    #endif}
01439 
01440 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01441     std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01442       std::endl;
01443     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01444       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01445     \}
01446     std::cout << std::endl;
01447 \textcolor{preprocessor}{    #endif}
01448 
01450 
01451     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01452     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01453     \textcolor{comment}{// chosen to be the new weights\_.}
01454 
01455 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01456     std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm << \textcolor{stringliteral}{" found at row "} <<
01457       minrow\_ + 1 << std::endl;
01458     std::cout << std::endl;
01459 \textcolor{preprocessor}{    #endif}
01460 
01461     copy\_result = 1;
01462     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a0c9ebb125445bc5af752bf4fb47f44b2}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01463                                                         order\_accuracy\_ + 1,
01464                                                         order\_accuracy\_,
01465                                                         order\_accuracy\_,
01466                                                         hh,
01467                                                         weights\_cbs\_,
01468                                                         minrow\_,
01469                                                         mimetic\_threshold\_,
01470                                                         copy\_result);
01471     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\};
01472 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01473     std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01474     std::cout << std::endl;
01475 \textcolor{preprocessor}{    #endif}
01476 
01477     \textcolor{keyword}{delete} [] lamed;
01478     lamed = \textcolor{keyword}{nullptr};
01479   \}
01480 
01481   \textcolor{keyword}{delete} [] hh;
01482   hh = \textcolor{keyword}{nullptr};
01483 
01484   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01485 \}
01486 
\hypertarget{mtk__grad__1d_8cc_source_l01487}{}\hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{01487} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{mtk::Grad1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01488 
01489 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01490   std::cout << \textcolor{stringliteral}{"weights\_* + lambda ="} << std::endl;
01491   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01492     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01493   \}
01494   std::cout << std::endl;
01495 \textcolor{preprocessor}{  #endif}
01496 
01498 
01499   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01500 
01501   \textcolor{keywordflow}{try} \{
01502     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01503   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01504     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01505       std::endl;
01506     std::cerr << memory\_allocation\_exception.what() << std::endl;
01507   \}
01508   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01509 
01510   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01511     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01512   \}
01513 
01514 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01515   std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01516   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01517     std::cout << std::setw(12) << lambda[ii] << std::endl;
01518   \}
01519   std::cout << std::endl;
01520 \textcolor{preprocessor}{  #endif}
01521 
01523 
01524   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01525 
01526   \textcolor{keywordflow}{try} \{
01527     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01528   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01529     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01530       std::endl;
01531     std::cerr << memory\_allocation\_exception.what() << std::endl;
01532   \}
01533   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01534 
01535   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01536     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01537   \}
01538 
01539 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01540   std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01541   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01542     std::cout << std::setw(12) << alpha[ii] << std::endl;
01543   \}
01544   std::cout << std::endl;
01545 \textcolor{preprocessor}{  #endif}
01546 
01548 
01549   \textcolor{keywordflow}{try} \{
01550     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
01551   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01552     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01553       std::endl;
01554     std::cerr << memory\_allocation\_exception.what() << std::endl;
01555   \}
01556   memset(mim\_bndy\_,
01557          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
01558          \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
01559 
01560   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01561     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < (num\_bndy\_approxs\_ - 1); ++jj) \{
01562       mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj] =
01563         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj] +
01564         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01565     \}
01566   \}
01567 
01568   \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01569     mim\_bndy\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)] =
01570       prem\_apps\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)];
01571   \}
01572 
01573 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01574   std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01575   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01576     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01577       std::cout << std::setw(13) << mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj];
01578     \}
01579     std::cout << std::endl;
01580   \}
01581   std::cout << std::endl;
01582 \textcolor{preprocessor}{  #endif}
01583 
01585 
01586   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_; ++ii) \{
01587     sums\_rows\_mim\_bndy\_.push\_back(\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
01588 
01589 
01590 
01591 
01592     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; ++jj) \{
01593       sums\_rows\_mim\_bndy\_[ii] += mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01594     \}
01595   \}
01596 
01597     mimetic\_measure\_ = *std::max\_element(sums\_rows\_mim\_bndy\_.begin(),
01598                                       sums\_rows\_mim\_bndy\_.end());
01599 
01600 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01601   std::cout << \textcolor{stringliteral}{"Row-wise sum of mimetic approximations:"} << std::endl;
01602   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_; ++ii) \{
01603     std::cout << std::setw(13) << sums\_rows\_mim\_bndy\_[ii];
01604   \}
01605   std::cout << std::endl;
01606   std::cout << std::endl;
01607 \textcolor{preprocessor}{  #endif}
01608 
01609   \textcolor{keyword}{delete}[] lambda;
01610   lambda = \textcolor{keyword}{nullptr};
01611 
01612   \textcolor{keyword}{delete}[] alpha;
01613   alpha = \textcolor{keyword}{nullptr};
01614 
01615   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01616 \}
01617 
\hypertarget{mtk__grad__1d_8cc_source_l01618}{}\hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{01618} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{mtk::Grad1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01619 
01620   \textcolor{comment}{// The output array will have this form:}
01621   \textcolor{comment}{// 1. The first entry of the array will contain the used order kk.}
01622   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01623   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01624   \textcolor{comment}{// 3. The third entry will contain a collection of weights.}
01625   \textcolor{comment}{// 4. The next dim\_null - 1 entries will contain the collections of}
01626   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01627 
01628   gradient\_length\_ = 1 + order\_accuracy\_ + order\_accuracy\_ +
01629     num\_bndy\_approxs\_*num\_bndy\_coeffs\_;
01630 
01631 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
01632   std::cout << \textcolor{stringliteral}{"gradient\_length\_ = "} << gradient\_length\_ << std::endl;
01633 \textcolor{preprocessor}{  #endif}
01634 
01635   \textcolor{keywordflow}{try} \{
01636     gradient\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[gradient\_length\_];
01637   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01638     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01639       std::endl;
01640     std::cerr << memory\_allocation\_exception.what() << std::endl;
01641   \}
01642   memset(gradient\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gradient\_[0])*gradient\_length\_);
01643 
01645 
01646   gradient\_[0] = order\_accuracy\_;
01647 
01650 
01651   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01652     gradient\_[ii + 1] = coeffs\_interior\_[ii];
01653   \}
01654 
01656 
01657   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01658     gradient\_[(order\_accuracy\_ + 1) + ii] = weights\_cbs\_[ii];
01659   \}
01660 
01663 
01664   \textcolor{keywordtype}{int} offset\{2*order\_accuracy\_ + 1\};
01665 
01666   \textcolor{keywordtype}{int} aux \{\}; \textcolor{comment}{// Auxiliary variable.}
01667 
01668   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01669     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ ; ii++) \{
01670       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; jj++) \{
01671         gradient\_[offset + aux] = mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01672         aux++;
01673       \}
01674     \}
01675   \} \textcolor{keywordflow}{else} \{
01676     gradient\_[offset + 0] = prem\_apps\_[0];
01677     gradient\_[offset + 1] = prem\_apps\_[1];
01678     gradient\_[offset + 2] = prem\_apps\_[2];
01679   \}
01680 
01681 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 1}
01682   std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order grad built!"} << std::endl;
01683   std::cout << std::endl;
01684 \textcolor{preprocessor}{  #endif}
01685 
01686   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01687 \}
\end{DoxyCode}
