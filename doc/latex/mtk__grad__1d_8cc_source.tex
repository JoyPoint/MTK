\hypertarget{mtk__grad__1d_8cc_source}{\section{mtk\+\_\+grad\+\_\+1d.\+cc}
\label{mtk__grad__1d_8cc_source}\index{src/mtk\+\_\+grad\+\_\+1d.\+cc@{src/mtk\+\_\+grad\+\_\+1d.\+cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed, unless these modifications are made through the project's GitHub}
00025 \textcolor{comment}{page: http://www.csrc.sdsu.edu/mtk. Documentation related to said modifications}
00026 \textcolor{comment}{should be developed and included in any deliverable.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00029 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00030 \textcolor{comment}{}
00031 \textcolor{comment}{3. Redistributions in binary form must reproduce the above copyright notice,}
00032 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00033 \textcolor{comment}{other materials provided with the distribution.}
00034 \textcolor{comment}{}
00035 \textcolor{comment}{4. Usage of the binary form on proprietary applications shall require explicit}
00036 \textcolor{comment}{prior written permission from the the copyright holders, and due credit should}
00037 \textcolor{comment}{be given to the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{5. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 
00067 \textcolor{preprocessor}{#ifdef MTK\_VERBOSE\_WEIGHTS}
00068 \textcolor{preprocessor}{#include <fstream>}
00069 \textcolor{preprocessor}{#endif}
00070 
00071 \textcolor{preprocessor}{#include <limits>}
00072 \textcolor{preprocessor}{#include <algorithm>}
00073 
00074 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00075 
00076 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00077 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00078 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00079 
00080 \textcolor{preprocessor}{#include "\hyperlink{mtk__grad__1d_8h}{mtk\_grad\_1d.h}"}
00081 
00082 \textcolor{keyword}{namespace }\hyperlink{namespacemtk}{mtk} \{
00083 
\hypertarget{mtk__grad__1d_8cc_source_l00084}{}\hyperlink{namespacemtk_a3f546b8a3743b8719db17e33f2d7ef7f}{00084} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Grad1D}{mtk::Grad1D} &in) \{
00085 
00087 
00088   stream << \textcolor{stringliteral}{"gradient\_[0] = "} << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[0] << std::endl;
00089 
00091 
00092   stream << \textcolor{stringliteral}{"gradient\_[1:"} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00093   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00094     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00095   \}
00096   stream << std::endl;
00097 
00099 
00100   stream << \textcolor{stringliteral}{"gradient\_["} << in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1 << \textcolor{stringliteral}{":"} <<
00101     2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00102   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_}; ++ii) \{
00103     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[ii] << \textcolor{stringliteral}{" "};
00104   \}
00105   stream << std::endl;
00106 
00108 
00109   \textcolor{keywordtype}{int} offset\{2*in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} + 1\};
00110   \textcolor{keywordtype}{int} mm \{\};
00111 
00112   stream << \textcolor{stringliteral}{"gradient\_["} << offset + mm << \textcolor{stringliteral}{":"} <<
00113     offset + mm + in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_} - 1 << \textcolor{stringliteral}{"] = "};
00114 
00115   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Grad1D_a545e9c865e5d4716f2684a64f744c78c}{order\_accuracy\_} > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
00116     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Grad1D_abe15c1ffd9dfaba1a65f4f0e096287ce}{num\_bndy\_approxs\_} ; ++ii) \{
00117       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Grad1D_a60c560882bc601f9ab1d4cd5331e55ef}{num\_bndy\_coeffs\_}; jj++) \{
00118         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + (mm)];
00119         stream << std::setw(9) << value << \textcolor{stringliteral}{" "};
00120         mm++;
00121       \}
00122     \}
00123   \} \textcolor{keywordflow}{else} \{
00124     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 0] << \textcolor{charliteral}{' '};
00125     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 1] << \textcolor{charliteral}{' '};
00126     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Grad1D_a024b84b1ea285c0c590eb42d40ff4469}{gradient\_}[offset + 2] << \textcolor{charliteral}{' '};
00127   \}
00128   stream << std::endl;
00129 
00130   \textcolor{keywordflow}{return} stream;
00131 \}
00132 \}
00133 
\hypertarget{mtk__grad__1d_8cc_source_l00134}{}\hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{00134} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}():
00135   order\_accuracy\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00136   dim\_null\_(),
00137   num\_bndy\_approxs\_(),
00138   num\_bndy\_coeffs\_(),
00139   gradient\_length\_(),
00140   minrow\_(),
00141   row\_(),
00142   coeffs\_interior\_(),
00143   prem\_apps\_(),
00144   weights\_crs\_(),
00145   weights\_cbs\_(),
00146   mim\_bndy\_(),
00147   gradient\_(),
00148   mimetic\_threshold\_(\hyperlink{namespacemtk}{mtk}::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}) \{\}
00149 
\hypertarget{mtk__grad__1d_8cc_source_l00150}{}\hyperlink{classmtk_1_1Grad1D_a5708bcb61bde3f7f3a4ddede191d82a4}{00150} \hyperlink{classmtk_1_1Grad1D_ae21e6ac2652e653c48f15b304ee83a75}{mtk::Grad1D::Grad1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Grad1D}{Grad1D} &grad):
00151   order\_accuracy\_(grad.order\_accuracy\_),
00152   dim\_null\_(grad.dim\_null\_),
00153   num\_bndy\_approxs\_(grad.num\_bndy\_approxs\_),
00154   num\_bndy\_coeffs\_(grad.num\_bndy\_coeffs\_),
00155   gradient\_length\_(grad.gradient\_length\_),
00156   minrow\_(grad.minrow\_),
00157   row\_(grad.row\_),
00158   coeffs\_interior\_(grad.coeffs\_interior\_),
00159   prem\_apps\_(grad.prem\_apps\_),
00160   weights\_crs\_(grad.weights\_crs\_),
00161   weights\_cbs\_(grad.weights\_cbs\_),
00162   mim\_bndy\_(grad.mim\_bndy\_),
00163   gradient\_(grad.gradient\_),
00164   mimetic\_threshold\_(grad.mimetic\_threshold\_) \{\}
00165 
\hypertarget{mtk__grad__1d_8cc_source_l00166}{}\hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{00166} \hyperlink{classmtk_1_1Grad1D_a2f9b1d306c0f09f36145bb1e7e486b54}{mtk::Grad1D::~Grad1D}() \{
00167 
00168   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00169   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00170 
00171   \textcolor{keyword}{delete}[] prem\_apps\_;
00172   prem\_apps\_ = \textcolor{keyword}{nullptr};
00173 
00174   \textcolor{keyword}{delete}[] weights\_crs\_;
00175   weights\_crs\_ = \textcolor{keyword}{nullptr};
00176 
00177   \textcolor{keyword}{delete}[] weights\_cbs\_;
00178   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00179 
00180   \textcolor{keyword}{delete}[] mim\_bndy\_;
00181   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00182 
00183   \textcolor{keyword}{delete}[] gradient\_;
00184   gradient\_ = \textcolor{keyword}{nullptr};
00185 \}
00186 
\hypertarget{mtk__grad__1d_8cc_source_l00187}{}\hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{00187} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a74ef5245cfae6fd158bd7f563a0c2e52}{mtk::Grad1D::ConstructGrad1D}(\textcolor{keywordtype}{int} order\_accuracy, 
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} mimetic\_threshold) \{
00188 
00189 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00190   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00191   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00192   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00193                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00194 
00195   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
00196     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is high."} << std::endl;
00197   \}
00198 
00199   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;
00200   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;
00201 \textcolor{preprocessor}{  #endif}
00202 
00203   order\_accuracy\_ = order\_accuracy;
00204   mimetic\_threshold\_ = mimetic\_threshold;
00205 
00207   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00208 
00209 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00210   \textcolor{keywordflow}{if} (!abort\_construction) \{
00211     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;
00212     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00213     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00214   \}
00215 \textcolor{preprocessor}{  #endif}
00216 
00217   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00218   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00219 
00220   dim\_null\_ = order\_accuracy\_/2 - 1;
00221 
00222   num\_bndy\_approxs\_ = dim\_null\_ + 1;
00223 
00224 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00225   num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00226 \textcolor{preprocessor}{  #else}
00227   num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00228 \textcolor{preprocessor}{  #endif}
00229 
00231 
00232   \textcolor{comment}{// For this we will follow recommendations given in:}
00233   \textcolor{comment}{//}
00234   \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00235   \textcolor{comment}{//}
00236   \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00237   \textcolor{comment}{// following (MATLAB) pseudo-code:}
00238   \textcolor{comment}{//}
00239   \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00240   \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00241   \textcolor{comment}{//}
00242   \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00243   \textcolor{comment}{//}
00244   \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00245   \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00246   \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00247   \textcolor{comment}{// (west boundary).}
00248 
00249   \textcolor{comment}{// In the case of the gradient, the first Vandermonde system has a unique}
00250   \textcolor{comment}{// solution for the case of second-order-accuracy. Ergo, the Vandermonde}
00251   \textcolor{comment}{// matrix used to assemble said system, will have an empty null-space.}
00252 
00253   \textcolor{comment}{// Therefore, we only compute a rational basis for the case of order higher}
00254   \textcolor{comment}{// than second.}
00255 
00256   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00257 
00258     abort\_construction = ComputeRationalBasisNullSpace();
00259 
00260 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00261     \textcolor{keywordflow}{if} (!abort\_construction) \{
00262       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;
00263       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00264       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00265     \}
00266 \textcolor{preprocessor}{    #endif}
00267   \}
00268 
00270   abort\_construction = ComputePreliminaryApproximations();
00271 
00272 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00273   \textcolor{keywordflow}{if} (!abort\_construction) \{
00274     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;
00275     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00276     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00277   \}
00278 \textcolor{preprocessor}{  #endif}
00279 
00281   abort\_construction = ComputeWeights();
00282 
00283 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00284   \textcolor{keywordflow}{if} (!abort\_construction) \{
00285     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;
00286     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00287     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00288   \}
00289 \textcolor{preprocessor}{  #endif}
00290 
00292   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00293 
00294     abort\_construction = ComputeStencilBoundaryGrid();
00295 
00296 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00297     \textcolor{keywordflow}{if} (!abort\_construction) \{
00298       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;
00299       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00300       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00301     \}
00302 \textcolor{preprocessor}{    #endif}
00303   \}
00304 
00306 
00307   \textcolor{comment}{// Once we have the following three collections of data:}
00308   \textcolor{comment}{//   (a) the coefficients for the interior,}
00309   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00310   \textcolor{comment}{//   (c) and the weights (if it applies),}
00311   \textcolor{comment}{// we will store everything in the output array:}
00312 
00313   abort\_construction = AssembleOperator();
00314 
00315 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00316   \textcolor{keywordflow}{if} (!abort\_construction) \{
00317     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;
00318     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00319     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00320   \}
00321 \textcolor{preprocessor}{  #endif}
00322 
00323   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00324 \}
00325 
\hypertarget{mtk__grad__1d_8cc_source_l00326}{}\hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{00326} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Grad1D_a7168205c21ba00012558f8bba069c119}{mtk::Grad1D::num\_bndy\_coeffs}()\textcolor{keyword}{ const }\{
00327 
00328   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00329 \}
00330 
\hypertarget{mtk__grad__1d_8cc_source_l00331}{}\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{00331} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_a88735f8d2a6ed986370dc3caeb84959b}{mtk::Grad1D::coeffs\_interior}()\textcolor{keyword}{ const }\{
00332 
00333   \textcolor{keywordflow}{return} coeffs\_interior\_;
00334 \}
00335 
\hypertarget{mtk__grad__1d_8cc_source_l00336}{}\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{00336} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ae5f15d8986a5680b6a1c120283c6cc5e}{mtk::Grad1D::weights\_crs}()\textcolor{keyword}{ const }\{
00337 
00338   \textcolor{keywordflow}{return} weights\_crs\_;
00339 \}
00340 
\hypertarget{mtk__grad__1d_8cc_source_l00341}{}\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{00341} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Grad1D_ad11927d8f9f1ca0089aaa2be7094f7f3}{mtk::Grad1D::weights\_cbs}()\textcolor{keyword}{ const }\{
00342 
00343   \textcolor{keywordflow}{return} weights\_cbs\_;
00344 \}
00345 
\hypertarget{mtk__grad__1d_8cc_source_l00346}{}\hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{00346} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab25e1d064a5a00fbe3777e65fd5750c0}{mtk::Grad1D::mim\_bndy}()\textcolor{keyword}{ const }\{
00347 
00348   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} xx(dim\_null\_ + 1, 3*order\_accuracy\_/2);
00349 
00350   \textcolor{keyword}{auto} counter = 0;
00351   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_ + 1; ++ii) \{
00352     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < 3*order\_accuracy\_/2; ++jj) \{
00353       xx.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj, gradient\_[2*order\_accuracy\_ + 1 + counter]);
00354       counter++;
00355     \}
00356   \}
00357 
00358   \textcolor{keywordflow}{return} xx;
00359 \}
00360 
\hypertarget{mtk__grad__1d_8cc_source_l00361}{}\hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{00361} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
      \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} west,
00362                                                   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} east,
00363                                                   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00364 
00365   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00366 
00367 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00368   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(east < west, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00369   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00370   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00371 \textcolor{preprocessor}{  #endif}
00372 
00373   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} delta\_x = (east - west)/((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) num\_cells\_x);
00374 
00375   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/delta\_x\};
00376 
00377   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00378   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00379   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00380   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00381 
00382   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00383   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00384 
00386 
00387   \textcolor{keyword}{auto} ee\_index = 0;
00388   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00389     \textcolor{keyword}{auto} cc = 0;
00390     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00391       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00392         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00393       \} \textcolor{keywordflow}{else} \{
00394         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00395                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00396         cc++;
00397       \}
00398     \}
00399   \}
00400 
00402 
00403   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00404     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00405     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00406       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00407     \}
00408   \}
00409 
00411 
00412   ee\_index = 0;
00413   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00414     \textcolor{keyword}{auto} cc = 0;
00415     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00416       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00417         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00418       \} \textcolor{keywordflow}{else} \{
00419         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00420                      -gradient\_[2*order\_accuracy\_ + 1 +
00421 ee\_index++]*inv\_delta\_x);
00422         cc++;
00423       \}
00424      \}
00425   \}
00426 
00427   \textcolor{keywordflow}{return} out;
00428 \}
00429 
\hypertarget{mtk__grad__1d_8cc_source_l00430}{}\hyperlink{classmtk_1_1Grad1D_a871a3b31e257b04d5e303b3211df3a73}{00430} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_a77b2eddbe4ab03f469306c604d505b1a}{mtk::Grad1D::ReturnAsDenseMatrix}(
00431   \textcolor{keyword}{const} \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid)\textcolor{keyword}{ const }\{
00432 
00433   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00434 
00435 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00436   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00437   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00438 \textcolor{preprocessor}{  #endif}
00439 
00440   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00441 
00442   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00443   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00444   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00445   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00446 
00447   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00448   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00449 
00451 
00452   \textcolor{keyword}{auto} ee\_index = 0;
00453   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00454     \textcolor{keyword}{auto} cc = 0;
00455     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00456       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00457         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00458       \} \textcolor{keywordflow}{else} \{
00459         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00460                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00461         cc++;
00462       \}
00463     \}
00464   \}
00465 
00467 
00468   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00469     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00470     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00471       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00472     \}
00473   \}
00474 
00476 
00477   ee\_index = 0;
00478   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00479     \textcolor{keyword}{auto} cc = 0;
00480     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00481       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00482         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00483       \} \textcolor{keywordflow}{else} \{
00484         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00485                     -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]*inv\_delta\_x);
00486         cc++;
00487       \}
00488      \}
00489   \}
00490 
00491   \textcolor{keywordflow}{return} out;
00492 \}
00493 
\hypertarget{mtk__grad__1d_8cc_source_l00494}{}\hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{00494} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Grad1D_ab07e6a15edca32534ae3d1a8ccaf1c42}{mtk::Grad1D::ReturnAsDimensionlessDenseMatrix}
      (
00495   \textcolor{keywordtype}{int} num\_cells\_x)\textcolor{keyword}{ const }\{
00496 
00497   \textcolor{keywordtype}{int} nn\{num\_cells\_x\}; \textcolor{comment}{// Number of cells on the grid.}
00498 
00499 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00500   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00501   \hyperlink{classmtk_1_1Tools_a332324c6f25e66be9dff48c5987a3b9f}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00502 \textcolor{preprocessor}{  #endif}
00503 
00504   \textcolor{keywordtype}{int} gg\_num\_rows = nn + 1;
00505   \textcolor{keywordtype}{int} gg\_num\_cols = nn + 2;
00506   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00507   \textcolor{keywordtype}{int} num\_extra\_rows = order\_accuracy\_/2;
00508 
00509   \textcolor{comment}{// Output matrix featuring sizes for gradient operators.}
00510   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(gg\_num\_rows, gg\_num\_cols);
00511 
00513 
00514   \textcolor{keyword}{auto} ee\_index = 0;
00515   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_extra\_rows; ii++) \{
00516     \textcolor{keyword}{auto} cc = 0;
00517     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < gg\_num\_cols; jj++) \{
00518       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00519         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00520       \} \textcolor{keywordflow}{else} \{
00521         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00522                      gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00523         cc++;
00524       \}
00525     \}
00526   \}
00527 
00529 
00530   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows; ii < gg\_num\_rows - num\_extra\_rows; ii++) \{
00531     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows + 1;
00532     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00533       out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii, jj, coeffs\_interior\_[cc]);
00534     \}
00535   \}
00536 
00538 
00539   ee\_index = 0;
00540   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = gg\_num\_rows - 1; ii >= gg\_num\_rows - num\_extra\_rows; ii--) \{
00541     \textcolor{keyword}{auto} cc = 0;
00542     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = gg\_num\_cols - 1; jj >= 0; jj--) \{
00543       \textcolor{keywordflow}{if}(cc >= elements\_per\_row) \{
00544         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,\hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00545       \} \textcolor{keywordflow}{else} \{
00546         out.\hyperlink{classmtk_1_1DenseMatrix_a784ce5784109ac86bfb9d8562b334b13}{SetValue}(ii,jj,
00547                      -gradient\_[2*order\_accuracy\_ + 1 + ee\_index++]);
00548         cc++;
00549       \}
00550      \}
00551   \}
00552 
00553   \textcolor{keywordflow}{return} out;
00554 \}
00555 
\hypertarget{mtk__grad__1d_8cc_source_l00556}{}\hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{00556} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_ad6df25cc9dfc85ff8562ae3605486976}{mtk::Grad1D::ComputeStencilInteriorGrid}() \{
00557 
00559 
00560   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00561 
00562   \textcolor{keywordflow}{try} \{
00563     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00564   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00565     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00566       std::endl;
00567     std::cerr << memory\_allocation\_exception.what() << std::endl;
00568   \}
00569   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00570 
00571 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00572   pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00573 \textcolor{preprocessor}{  #else}
00574   pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00575 \textcolor{preprocessor}{  #endif}
00576 
00577   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00578     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00579   \}
00580 
00581 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00582   std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00583   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00584     std::cout << std::setw(12) << pp[ii];
00585   \}
00586   std::cout << std::endl << std::endl;
00587 \textcolor{preprocessor}{  #endif}
00588 
00590 
00591   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00592 
00593   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,order\_accuracy\_,order\_accuracy\_,transpose);
00594 
00595 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00596   std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00597   std::cout << vander\_matrix << std::endl << std::endl;
00598 \textcolor{preprocessor}{  #endif}
00599 
00601 
00602   \textcolor{keywordflow}{try} \{
00603     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00604   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00605     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00606       std::endl;
00607     std::cerr << memory\_allocation\_exception.what() << std::endl;
00608   \}
00609   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00610 \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00611 
00612   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00613 
00614 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00615   std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00616   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00617     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00618   \}
00619   std::cout << std::endl;
00620 \textcolor{preprocessor}{  #endif}
00621 
00623 
00624   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00625                                                 coeffs\_interior\_)\};
00626 
00627 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00628   \textcolor{keywordflow}{if} (!info) \{
00629     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00630     std::cout << std::endl;
00631   \}
00632   \textcolor{keywordflow}{else} \{
00633     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00634     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00635     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00636   \}
00637 \textcolor{preprocessor}{  #endif}
00638 
00639 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00640   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00641   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00642     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00643   \}
00644   std::cout << std::endl << std::endl;
00645 \textcolor{preprocessor}{  #endif}
00646 
00647   \textcolor{keyword}{delete} [] pp;
00648   pp = \textcolor{keyword}{nullptr};
00649 
00650   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00651 \}
00652 
\hypertarget{mtk__grad__1d_8cc_source_l00653}{}\hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{00653} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a2d03e6a3961bee558f575ec4099782a9}{mtk::Grad1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00654 
00656 
00657   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00658 
00659   \textcolor{keywordflow}{try} \{
00660     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00661   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00662     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00663       std::endl;
00664     std::cerr << memory\_allocation\_exception.what() << std::endl;
00665   \}
00666   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00667 
00668 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00669   gg[1] = 1.0/2.0;
00670 \textcolor{preprocessor}{  #else}
00671   gg[1] = 1.0f/2.0f;
00672 \textcolor{preprocessor}{  #endif}
00673   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00674     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00675   \}
00676 
00677 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00678   std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00679   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00680     std::cout << std::setw(12) << gg[ii];
00681   \}
00682   std::cout << std::endl << std::endl;
00683 \textcolor{preprocessor}{  #endif}
00684 
00686 
00687   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00688 
00689   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00690 
00691 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00692   std::cout << \textcolor{stringliteral}{"aa\_west\_t ="} << std::endl;
00693   std::cout << aa\_west\_t << std::endl;
00694 \textcolor{preprocessor}{  #endif}
00695 
00697 
00698   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (aa\_west\_t));
00699 
00700 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00701   std::cout << \textcolor{stringliteral}{"qq\_t = "} << std::endl;
00702   std::cout << qq\_t << std::endl;
00703 \textcolor{preprocessor}{  #endif}
00704 
00706 
00707   \textcolor{keywordtype}{int} kk\_num\_rows\{num\_bndy\_coeffs\_\};
00708   \textcolor{keywordtype}{int} kk\_num\_cols\{dim\_null\_\};
00709 
00710   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} kk(kk\_num\_rows, kk\_num\_cols);
00711 
00712   \textcolor{comment}{// In the case of the gradient, even though we must solve for a null-space}
00713   \textcolor{comment}{// of dimension 2, we must only extract ONE basis for the kernel.}
00714   \textcolor{comment}{// We perform this extraction here:}
00715 
00716   \textcolor{keywordtype}{int} aux\_\{kk\_num\_rows - kk\_num\_cols\};
00717   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = kk\_num\_rows - kk\_num\_cols; ii < kk\_num\_rows; ii++) \{
00718     aux\_--;
00719     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < kk\_num\_rows; jj++) \{
00720       kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj*kk\_num\_cols + (kk\_num\_rows - kk\_num\_cols - aux\_ - 1)] =
00721         qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00722     \}
00723   \}
00724 
00725 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
00726   std::cout << \textcolor{stringliteral}{"kk ="} << std::endl;
00727   std::cout << kk << std::endl;
00728   std::cout << \textcolor{stringliteral}{"kk.num\_rows() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a53f3afb3b6a8d21854458aaa9663cc74}{num\_rows}() << std::endl;
00729   std::cout << \textcolor{stringliteral}{"kk.num\_cols() = "} << kk.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() << std::endl;
00730   std::cout << std::endl;
00731 \textcolor{preprocessor}{  #endif}
00732 
00734 
00735   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00736   \textcolor{comment}{// null-space, adopt the pattern we require.}
00737   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00738   \textcolor{comment}{//  scalers = kk(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00739   \textcolor{comment}{//  SK = kk*scalers}
00740   \textcolor{comment}{// where SK is the scaled null-space.}
00741 
00742   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00743   \textcolor{comment}{// in memory. We will create the matrix iden\_, and elements we wish to scale}
00744   \textcolor{comment}{// in the kk array. Using the concept of the leading dimension, we could just}
00745   \textcolor{comment}{// use kk, with the correct leading dimension and that is it. BUT I DO NOT}
00746   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00747   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00748   \textcolor{comment}{// whole kk:}
00749 
00750   \textcolor{comment}{// We will then create memory for that sub-matrix of kk (subk).}
00751 
00752   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} subk(dim\_null\_, dim\_null\_);
00753 
00754   \textcolor{keyword}{auto} zz = 0;
00755   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = order\_accuracy\_ + 1; ii < num\_bndy\_coeffs\_; ii++) \{
00756     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; jj++) \{
00757       subk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[zz*(dim\_null\_) + jj] = kk.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(dim\_null\_) + jj];
00758     \}
00759     zz++;
00760   \}
00761 
00762 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00763   std::cout << \textcolor{stringliteral}{"subk ="} << std::endl;
00764   std::cout << subk << std::endl;
00765 \textcolor{preprocessor}{  #endif}
00766 
00767   subk.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00768 
00769 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00770   std::cout << \textcolor{stringliteral}{"subk\_t ="} << std::endl;
00771   std::cout << subk << std::endl;
00772 \textcolor{preprocessor}{  #endif}
00773 
00774   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00775   tran = \textcolor{keyword}{false};
00776 
00777   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} iden(dim\_null\_, padded, tran);
00778 
00779 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00780   std::cout << \textcolor{stringliteral}{"iden ="} << std::endl;
00781   std::cout << iden << std::endl;
00782 \textcolor{preprocessor}{  #endif}
00783 
00784   \textcolor{comment}{// Solve the system to compute the scalers.}
00785   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00786   \textcolor{comment}{//}
00787   \textcolor{comment}{// subk*scalers = iden or}
00788   \textcolor{comment}{//}
00789   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00790   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00791   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00792   \textcolor{comment}{//}
00793   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00794   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00795   \textcolor{comment}{// will be stored in the created identity matrix.}
00796   \textcolor{comment}{// Let us first transpose subk (because of LAPACK):}
00797 
00798   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(subk, iden)\};
00799 
00800 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
00801   \textcolor{keywordflow}{if} (!info) \{
00802     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00803       std::endl;
00804   \} \textcolor{keywordflow}{else} \{
00805     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00806       std::endl;
00807     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00808     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00809   \}
00810   std::cout << std::endl;
00811 \textcolor{preprocessor}{  #endif}
00812 
00813 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00814   std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00815   std::cout << iden << std::endl;
00816 \textcolor{preprocessor}{  #endif}
00817 
00818   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00819 
00820   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(kk, iden);
00821 
00822 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
00823   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00824   std::cout << rat\_basis\_null\_space\_ << std::endl;
00825 \textcolor{preprocessor}{  #endif}
00826 
00827   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00828   \textcolor{comment}{// pattern we need! :)}
00829 
00830   \textcolor{keyword}{delete} [] gg;
00831   gg = \textcolor{keyword}{nullptr};
00832 
00833   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00834 \}
00835 
\hypertarget{mtk__grad__1d_8cc_source_l00836}{}\hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{00836} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_add4c68a6e78d8b9c2b800b3f96f4757d}{mtk::Grad1D::ComputePreliminaryApproximations}() \{
00837 
00839 
00840   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00841 
00842   \textcolor{keywordflow}{try} \{
00843     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00844   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00845     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00846       std::endl;
00847     std::cerr << memory\_allocation\_exception.what() << std::endl;
00848   \}
00849   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00850 
00851 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00852   gg[1] = 1.0/2.0;
00853 \textcolor{preprocessor}{  #else}
00854   gg[1] = 1.0f/2.0f;
00855 \textcolor{preprocessor}{  #endif}
00856   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 2; ii < num\_bndy\_coeffs\_; ++ii) \{
00857     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00858   \}
00859 
00860 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
00861   std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00862   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00863     std::cout << std::setw(12) << gg[ii];
00864   \}
00865   std::cout << std::endl << std::endl;
00866 \textcolor{preprocessor}{  #endif}
00867 
00868   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00869   \textcolor{keywordflow}{try} \{
00870     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
00871   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00872     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00873 std::endl;
00874     std::cerr << memory\_allocation\_exception.what() << std::endl;
00875   \}
00876   memset(prem\_apps\_,
00877          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00878          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
00879 
00881 
00882   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < num\_bndy\_approxs\_; ++ll) \{
00883 
00884     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00885 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00886     \textcolor{keywordflow}{if} (ll > 0) \{
00887       std::cout << \textcolor{stringliteral}{"gg\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00888       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00889         std::cout << std::setw(12) << gg[ii];
00890       \}
00891       std::cout << std::endl << std::endl;
00892     \}
00893 \textcolor{preprocessor}{    #endif}
00894 
00896 
00897     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00898 
00899     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} aa(gg,
00900                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00901                          transpose);
00902 
00903 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
00904     std::cout << \textcolor{stringliteral}{"aa\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00905     std::cout << aa << std::endl;
00906 \textcolor{preprocessor}{    #endif}
00907 
00909 
00910     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00911 
00912     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00913 
00914     \textcolor{keywordflow}{try} \{
00915       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00916     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00917       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00918         std::endl;
00919       std::cerr << memory\_allocation\_exception.what() << std::endl;
00920     \}
00921     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00922 
00923     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00924 
00925 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00926     std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00927     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00928       std::cout << std::setw(12) << ob[ii] << std::endl;
00929     \}
00930     std::cout << std::endl;
00931 \textcolor{preprocessor}{    #endif}
00932 
00934 
00935     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00936     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00937     \textcolor{comment}{// our LAPACKAdapter class.}
00938 
00939     \textcolor{keywordtype}{int} info\_\{
00940       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(aa, ob
      , ob\_ld)\};
00941 
00942 \textcolor{preprocessor}{    #ifdef MTK\_PERFORM\_PREVENTIONS}
00943     \textcolor{keywordflow}{if} (!info\_) \{
00944       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00945     \} \textcolor{keywordflow}{else} \{
00946       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00947       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00948     \}
00949 \textcolor{preprocessor}{    #endif}
00950 
00951 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00952     std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00953     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00954       std::cout << std::setw(12) << ob[ii] << std::endl;
00955     \}
00956     std::cout << std::endl;
00957 \textcolor{preprocessor}{    #endif}
00958 
00960 
00961     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
00962     \textcolor{comment}{// for this operation.}
00963 
00965     \textcolor{comment}{// Save them into the ob\_bottom array:}
00966 
00967     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
00968 
00969     \textcolor{keywordflow}{try} \{
00970       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
00971     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00972       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00973         std::endl;
00974       std::cerr << memory\_allocation\_exception.what() << std::endl;
00975     \}
00976     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
00977 
00978     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00979       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
00980     \}
00981 
00982 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
00983     std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
00984     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00985       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
00986     \}
00987     std::cout << std::endl;
00988 \textcolor{preprocessor}{    #endif}
00989 
00991 
00992     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
00993     \textcolor{comment}{// rat\_basis\_null\_space\_.}
00994     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
00995     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
00996     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
00997 
00998 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
00999     std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
01000     std::cout << rat\_basis\_null\_space\_ << std::endl;
01001 \textcolor{preprocessor}{    #endif}
01002 
01003     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01004     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
01005 
01006     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
01007                                   ob\_bottom, beta, ob);
01008 
01009 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01010     std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
01011     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01012       std::cout << std::setw(12) << ob[ii] << std::endl;
01013     \}
01014     std::cout << std::endl;
01015 \textcolor{preprocessor}{    #endif}
01016 
01017     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
01018     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
01019     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
01020     \textcolor{comment}{// to implement.}
01021 
01022     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01023       prem\_apps\_[ii*num\_bndy\_approxs\_ + ll] = ob[ii];
01024     \}
01025 
01026     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
01027     \textcolor{comment}{// generator vector used:}
01028     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01029       gg[ii]--;
01030     \}
01031 
01032     \textcolor{comment}{// Garbage collection for this loop:}
01033     \textcolor{keyword}{delete}[] ob;
01034     ob = \textcolor{keyword}{nullptr};
01035 
01036     \textcolor{keyword}{delete}[] ob\_bottom;
01037     ob\_bottom = \textcolor{keyword}{nullptr};
01038   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
01039 
01040 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01041   std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
01042   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01043     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01044       std::cout << std::setw(12) << prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01045     \}
01046     std::cout << std::endl;
01047   \}
01048   std::cout << std::endl;
01049 \textcolor{preprocessor}{  #endif}
01050 
01051   \textcolor{keyword}{delete}[] gg;
01052   gg = \textcolor{keyword}{nullptr};
01053 
01054   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01055 \}
01056 
\hypertarget{mtk__grad__1d_8cc_source_l01057}{}\hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{01057} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a224082617751864bffca9bfe494c36d5}{mtk::Grad1D::ComputeWeights}() \{
01058 
01059   \textcolor{comment}{// Matrix to compute the weights as in the CRSA.}
01060   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
01061 
01063 
01064   \textcolor{comment}{// Assemble the pi matrix using:}
01065   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
01066   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
01067   \textcolor{comment}{// 3. The scaled basis for the null-space.}
01068 
01069   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
01070 
01071   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
01072   \textcolor{comment}{// of the pi matrix:}
01073   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01074     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01075       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(2*(num\_bndy\_approxs\_ - 1) + (order\_accuracy\_/2 + 1)) + jj] =
01076         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01077     \}
01078   \}
01079 
01080   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
01081 
01082   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
01083   \textcolor{comment}{// final pi matrix:}
01084   \textcolor{keyword}{auto} mm = 1;
01085   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < order\_accuracy\_; ++jj) \{
01086     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01087       \textcolor{keyword}{auto} de = (ii + mm)*(2*(num\_bndy\_approxs\_ - 1) +
01088         (order\_accuracy\_/2 + 1)) + jj;
01089       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = coeffs\_interior\_[ii];
01090     \}
01091     ++mm;
01092   \}
01093 
01094   rat\_basis\_null\_space\_.OrderColMajor();
01095 
01096 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01097   std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
01098   std::cout << rat\_basis\_null\_space\_ << std::endl;
01099 \textcolor{preprocessor}{  #endif}
01100 
01101   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
01102 
01103   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1);
01104        jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
01105     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01106       \textcolor{keyword}{auto} og =
01107         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
01108       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
01109       pi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
01110     \}
01111   \}
01112 
01113 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01114   std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
01115   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01116     std::cout << std::setw(12) << coeffs\_interior\_[ii];
01117   \}
01118   std::cout << std::endl << std::endl;
01119 \textcolor{preprocessor}{  #endif}
01120 
01121 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01122   std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
01123   std::cout << pi << std::endl;
01124 \textcolor{preprocessor}{  #endif}
01125 
01127 
01128   \textcolor{comment}{// This imposes the mimetic condition.}
01129 
01130   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
01131 
01132   \textcolor{keywordflow}{try} \{
01133     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01134   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01135     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01136       std::endl;
01137     std::cerr << memory\_allocation\_exception.what() << std::endl;
01138   \}
01139   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
01140 
01141   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
01142   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
01143     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01144     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
01145       aux\_xx += coeffs\_interior\_[jj];
01146     \}
01147     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
01148   \}
01149 
01151 
01152   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
01153 
01154   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
01155   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
01156   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
01157   \textcolor{comment}{// unique. We will use dgels\_.}
01158 
01159   \textcolor{keywordflow}{try} \{
01160     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01161   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01162     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01163       std::endl;
01164     std::cerr << memory\_allocation\_exception.what() << std::endl;
01165   \}
01166   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
01167 
01168   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_a41747502d468c6728a4be31501b16e0e}{num\_cols}() + 1\};
01169 
01170   \textcolor{comment}{// Preserve hh.}
01171   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
01172 
01173   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01174 
01175   \textcolor{keywordtype}{int} info\{
01176     \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(pi,
01177                                                     weights\_cbs\_, weights\_ld)
01178   \};
01179 
01180 \textcolor{preprocessor}{  #ifdef MTK\_PERFORM\_PREVENTIONS}
01181   \textcolor{keywordflow}{if} (!info) \{
01182     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01183   \} \textcolor{keywordflow}{else} \{
01184     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01185     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
01186   \}
01187 \textcolor{preprocessor}{  #endif}
01188 
01189 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01190   std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01191   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01192     std::cout << std::setw(11) << hh[ii] << std::endl;
01193   \}
01194   std::cout << std::endl;
01195 \textcolor{preprocessor}{  #endif}
01196 
01197   \textcolor{comment}{// Preserve the original weights for research.}
01198 
01199   \textcolor{keywordflow}{try} \{
01200     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01201   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01202     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01203       std::endl;
01204     std::cerr << memory\_allocation\_exception.what() << std::endl;
01205   \}
01206   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01207 
01208   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01209 
01210 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01211   std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01212   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01213     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01214   \}
01215   std::cout << std::endl;
01216 \textcolor{preprocessor}{  #endif}
01217 
01219 
01220   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga295dd2f403c775ecd942c22b5a777496}{mtk::kCriticalOrderAccuracyGrad}) \{
01221 
01223 
01224     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01225 
01226     \textcolor{comment}{// 6.1. Insert preliminary approximations to first set of columns.}
01227 
01228     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01229       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01230         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*(order\_accuracy\_) + jj] =
01231           prem\_apps\_[ii*num\_bndy\_approxs\_ + jj];
01232       \}
01233     \}
01234 
01235     \textcolor{comment}{// 6.2. Skip a column and negate preliminary approximations.}
01236 
01237     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; jj++) \{
01238       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_approxs\_; ii++) \{
01239         \textcolor{keyword}{auto} de = (ii+ order\_accuracy\_ - num\_bndy\_approxs\_+ jj*order\_accuracy\_);
01240         \textcolor{keyword}{auto} og = (num\_bndy\_approxs\_ - ii + (jj)*num\_bndy\_approxs\_);
01241         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[de] = -prem\_apps\_[og];
01242       \}
01243     \}
01244 
01245     \textcolor{comment}{// 6.3. Flip negative columns up-down.}
01246 
01247     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ii++) \{
01248       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_ + 1; jj < order\_accuracy\_; jj++) \{
01249         \textcolor{keyword}{auto} aux = phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj];
01250         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[ii*order\_accuracy\_ + jj] =
01251           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj];
01252         phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(order\_accuracy\_ - ii)*order\_accuracy\_ + jj] = aux;
01253       \}
01254     \}
01255 
01256     \textcolor{comment}{// 6.4. Insert stencil.}
01257 
01258     \textcolor{keyword}{auto} mm = 0;
01259     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = num\_bndy\_approxs\_; jj < num\_bndy\_approxs\_ +  1; jj++) \{
01260       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ii++) \{
01261         \textcolor{keywordflow}{if} (ii == 0) \{
01262           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[jj] = 0.0;
01263         \} \textcolor{keywordflow}{else} \{
01264           phi.\hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}()[(ii + mm)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii - 1];
01265         \}
01266       \}
01267       mm++;
01268     \}
01269 
01270 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 4}
01271     std::cout << \textcolor{stringliteral}{"phi ="} << std::endl;
01272     std::cout << phi << std::endl;
01273 \textcolor{preprocessor}{    #endif}
01274 
01276 
01277     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01278 
01279     \textcolor{keywordflow}{try} \{
01280       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_approxs\_ - 1];
01281     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01282       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01283         std::endl;
01284       std::cerr << memory\_allocation\_exception.what() << std::endl;
01285     \}
01286     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*(num\_bndy\_approxs\_ - 1));
01287 
01288     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01289       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01290     \}
01291 
01292 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01293     std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01294     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ - 1; ++ii) \{
01295       std::cout << std::setw(12) << lamed[ii] << std::endl;
01296     \}
01297     std::cout << std::endl;
01298 \textcolor{preprocessor}{    #endif}
01299 
01300     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01301       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01302       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_ - 1; ++jj) \{
01303         temp = temp +
01304           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01305       \}
01306       hh[ii] = hh[ii] - temp;
01307     \}
01308 
01309 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01310     std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01311     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01312       std::cout << std::setw(12) << hh[ii] << std::endl;
01313     \}
01314     std::cout << std::endl;
01315 \textcolor{preprocessor}{    #endif}
01316 
01318 
01319 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01320     \textcolor{keywordtype}{int} copy\_result\{1\};
01321 \textcolor{preprocessor}{    #else}
01322     \textcolor{keywordtype}{int} copy\_result\{\};
01323 \textcolor{preprocessor}{    #endif}
01324 
01325     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01326 
01327     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01328     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\{std::numeric\_limits<mtk::Real>::infinity()\};
01329 
01330     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01331 
01332 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01333     std::ofstream table(\textcolor{stringliteral}{"grad\_1d\_"} + std::to\_string(order\_accuracy\_) +
01334       \textcolor{stringliteral}{"\_weights.tex"});
01335 
01336     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)begin\{tabular\}[c]\{c"};
01337     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01338       table << \textcolor{charliteral}{'c'};
01339     \}
01340     table << \textcolor{stringliteral}{":c\}\(\backslash\)n\(\backslash\)\(\backslash\)toprule\(\backslash\)nRow & "};
01341     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01342       table << \textcolor{stringliteral}{"$ q\_\{"} + std::to\_string(ii) + \textcolor{stringliteral}{"\}$ &"};
01343     \}
01344     table << \textcolor{stringliteral}{" Relative error \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)midrule\(\backslash\)n"};
01345 \textcolor{preprocessor}{    #endif}
01346 
01347     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01348       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01349                                                           order\_accuracy\_ + 1,
01350                                                           order\_accuracy\_,
01351                                                           order\_accuracy\_,
01352                                                           hh,
01353                                                           weights\_cbs\_,
01354                                                           row\_,
01355                                                           mimetic\_threshold\_,
01356                                                           copy\_result);
01357       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\};
01358 
01359 \textcolor{preprocessor}{      #if MTK\_VERBOSE\_LEVEL > 2}
01360       std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01361       std::cout << std::endl;
01362 \textcolor{preprocessor}{      #endif}
01363 
01364       \textcolor{keywordflow}{if} (aux < minnorm) \{
01365         minnorm = aux;
01366         minrow\_= row\_;
01367       \}
01368 
01369 \textcolor{preprocessor}{      #ifdef MTK\_VERBOSE\_WEIGHTS}
01370       table << std::to\_string(row\_ + 1) << \textcolor{stringliteral}{" & "};
01371       \textcolor{keywordflow}{if} (normerr\_ != std::numeric\_limits<mtk::Real>::infinity()) \{
01372         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01373           table << std::to\_string(weights\_cbs\_[ii - 1]) + \textcolor{stringliteral}{" & "};
01374         \}
01375         table << std::to\_string(aux) << \textcolor{stringliteral}{" \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01376       \} \textcolor{keywordflow}{else} \{
01377         table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)multicolumn\{"} << std::to\_string(order\_accuracy\_) <<
01378           \textcolor{stringliteral}{"\}\{c\}\{$\(\backslash\)\(\backslash\)emptyset$\} & "};
01379         table << \textcolor{stringliteral}{" - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"} << std::endl;
01380       \}
01381 \textcolor{preprocessor}{      #endif}
01382     \}
01383 
01384 \textcolor{preprocessor}{    #ifdef MTK\_VERBOSE\_WEIGHTS}
01385     table << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)midrule"} << std::endl;
01386     table << \textcolor{stringliteral}{"CRS weights:"};
01387     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ii = 1; ii <= order\_accuracy\_; ++ii) \{
01388       table << \textcolor{stringliteral}{" & "} << std::to\_string(weights\_crs\_[ii - 1]);
01389     \}
01390     table << \textcolor{stringliteral}{" & - \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)bottomrule\(\backslash\)n\(\backslash\)\(\backslash\)end\{tabular\}"} << std::endl;
01391     table.close();
01392 \textcolor{preprocessor}{    #endif}
01393 
01394 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 3}
01395     std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01396       std::endl;
01397     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01398       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01399     \}
01400     std::cout << std::endl;
01401 \textcolor{preprocessor}{    #endif}
01402 
01404 
01405     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01406     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01407     \textcolor{comment}{// chosen to be the new weights\_.}
01408 
01409 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01410     std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm << \textcolor{stringliteral}{" found at row "} <<
01411       minrow\_ + 1 << std::endl;
01412     std::cout << std::endl;
01413 \textcolor{preprocessor}{    #endif}
01414 
01415     copy\_result = 1;
01416     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a0c33b8a9e01d157c61ddbdf807c25d84}{data}(),
01417                                                         order\_accuracy\_ + 1,
01418                                                         order\_accuracy\_,
01419                                                         order\_accuracy\_,
01420                                                         hh,
01421                                                         weights\_cbs\_,
01422                                                         minrow\_,
01423                                                         mimetic\_threshold\_,
01424                                                         copy\_result);
01425     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\};
01426 \textcolor{preprocessor}{    #if MTK\_VERBOSE\_LEVEL > 2}
01427     std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01428     std::cout << std::endl;
01429 \textcolor{preprocessor}{    #endif}
01430 
01431     \textcolor{keyword}{delete} [] lamed;
01432     lamed = \textcolor{keyword}{nullptr};
01433   \}
01434 
01435   \textcolor{keyword}{delete} [] hh;
01436   hh = \textcolor{keyword}{nullptr};
01437 
01438   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01439 \}
01440 
\hypertarget{mtk__grad__1d_8cc_source_l01441}{}\hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{01441} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a7ad1cecf6b52647263208ffaea0ee1e5}{mtk::Grad1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01442 
01443 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01444   std::cout << \textcolor{stringliteral}{"weights\_* + lambda ="} << std::endl;
01445   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01446     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01447   \}
01448   std::cout << std::endl;
01449 \textcolor{preprocessor}{  #endif}
01450 
01452 
01453   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01454 
01455   \textcolor{keywordflow}{try} \{
01456     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01457   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01458     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01459       std::endl;
01460     std::cerr << memory\_allocation\_exception.what() << std::endl;
01461   \}
01462   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01463 
01464   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01465     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01466   \}
01467 
01468 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01469   std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01470   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01471     std::cout << std::setw(12) << lambda[ii] << std::endl;
01472   \}
01473   std::cout << std::endl;
01474 \textcolor{preprocessor}{  #endif}
01475 
01477 
01478   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01479 
01480   \textcolor{keywordflow}{try} \{
01481     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01482   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01483     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01484       std::endl;
01485     std::cerr << memory\_allocation\_exception.what() << std::endl;
01486   \}
01487   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01488 
01489   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01490     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01491   \}
01492 
01493 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 3}
01494   std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01495   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01496     std::cout << std::setw(12) << alpha[ii] << std::endl;
01497   \}
01498   std::cout << std::endl;
01499 \textcolor{preprocessor}{  #endif}
01500 
01502 
01503   \textcolor{keywordflow}{try} \{
01504     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*num\_bndy\_approxs\_];
01505   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01506     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01507       std::endl;
01508     std::cerr << memory\_allocation\_exception.what() << std::endl;
01509   \}
01510   memset(mim\_bndy\_,
01511          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
01512          \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*num\_bndy\_approxs\_);
01513 
01514   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01515     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < (num\_bndy\_approxs\_ - 1); ++jj) \{
01516       mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj] =
01517         prem\_apps\_[ii*num\_bndy\_approxs\_ + jj] +
01518         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01519     \}
01520   \}
01521 
01522   \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01523     mim\_bndy\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)] =
01524       prem\_apps\_[ii*num\_bndy\_approxs\_ + (num\_bndy\_approxs\_ - 1)];
01525   \}
01526 
01527 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 4}
01528   std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01529   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01530     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_approxs\_; ++jj) \{
01531       std::cout << std::setw(13) << mim\_bndy\_[ii*num\_bndy\_approxs\_ + jj];
01532     \}
01533     std::cout << std::endl;
01534   \}
01535   std::cout << std::endl;
01536 \textcolor{preprocessor}{  #endif}
01537 
01538   \textcolor{keyword}{delete}[] lambda;
01539   lambda = \textcolor{keyword}{nullptr};
01540 
01541   \textcolor{keyword}{delete}[] alpha;
01542   alpha = \textcolor{keyword}{nullptr};
01543 
01544   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01545 \}
01546 
\hypertarget{mtk__grad__1d_8cc_source_l01547}{}\hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{01547} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Grad1D_a4eb4d363506b8c64b2bb18a318bbd259}{mtk::Grad1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01548 
01549   \textcolor{comment}{// The output array will have this form:}
01550   \textcolor{comment}{// 1. The first entry of the array will contain the used order kk.}
01551   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01552   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01553   \textcolor{comment}{// 3. The third entry will contain a collection of weights.}
01554   \textcolor{comment}{// 4. The next dim\_null - 1 entries will contain the collections of}
01555   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01556 
01557   gradient\_length\_ = 1 + order\_accuracy\_ + order\_accuracy\_ +
01558     num\_bndy\_approxs\_*num\_bndy\_coeffs\_;
01559 
01560 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 2}
01561   std::cout << \textcolor{stringliteral}{"gradient\_length\_ = "} << gradient\_length\_ << std::endl;
01562 \textcolor{preprocessor}{  #endif}
01563 
01564   \textcolor{keywordflow}{try} \{
01565     gradient\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[gradient\_length\_];
01566   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01567     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01568       std::endl;
01569     std::cerr << memory\_allocation\_exception.what() << std::endl;
01570   \}
01571   memset(gradient\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gradient\_[0])*gradient\_length\_);
01572 
01574 
01575   gradient\_[0] = order\_accuracy\_;
01576 
01579 
01580   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01581     gradient\_[ii + 1] = coeffs\_interior\_[ii];
01582   \}
01583 
01585 
01586   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01587     gradient\_[(order\_accuracy\_ + 1) + ii] = weights\_cbs\_[ii];
01588   \}
01589 
01592 
01593   \textcolor{keywordtype}{int} offset\{2*order\_accuracy\_ + 1\};
01594 
01595   \textcolor{keywordtype}{int} aux \{\}; \textcolor{comment}{// Auxiliary variable.}
01596 
01597   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01598     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_approxs\_ ; ii++) \{
01599       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; jj++) \{
01600         gradient\_[offset + aux] = mim\_bndy\_[jj*num\_bndy\_approxs\_ + ii];
01601         aux++;
01602       \}
01603     \}
01604   \} \textcolor{keywordflow}{else} \{
01605     gradient\_[offset + 0] = prem\_apps\_[0];
01606     gradient\_[offset + 1] = prem\_apps\_[1];
01607     gradient\_[offset + 2] = prem\_apps\_[2];
01608   \}
01609 
01610 \textcolor{preprocessor}{  #if MTK\_VERBOSE\_LEVEL > 1}
01611   std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order grad built!"} << std::endl;
01612   std::cout << std::endl;
01613 \textcolor{preprocessor}{  #endif}
01614 
01615   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01616 \}
\end{DoxyCode}
