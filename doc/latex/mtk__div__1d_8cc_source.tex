\hypertarget{mtk__div__1d_8cc}{\section{mtk\-\_\-div\-\_\-1d.\-cc}
\label{mtk__div__1d_8cc}\index{src/mtk\-\_\-div\-\_\-1d.\-cc@{src/mtk\-\_\-div\-\_\-1d.\-cc}}
}

\begin{DoxyCode}
00001 
00015 \textcolor{comment}{/*}
00016 \textcolor{comment}{Copyright (C) 2015, Computational Science Research Center, San Diego State}
00017 \textcolor{comment}{University. All rights reserved.}
00018 \textcolor{comment}{}
00019 \textcolor{comment}{Redistribution and use in source and binary forms, with or without modification,}
00020 \textcolor{comment}{are permitted provided that the following conditions are met:}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{1. Modifications to source code should be reported to: esanchez@mail.sdsu.edu}
00023 \textcolor{comment}{and a copy of the modified files should be reported once modifications are}
00024 \textcolor{comment}{completed. Documentation related to said modifications should be included.}
00025 \textcolor{comment}{}
00026 \textcolor{comment}{2. Redistributions of source code must be done through direct}
00027 \textcolor{comment}{downloads from the project's GitHub page: http://www.csrc.sdsu.edu/mtk}
00028 \textcolor{comment}{}
00029 \textcolor{comment}{3. Redistributions of source code must retain the above copyright notice, this}
00030 \textcolor{comment}{list of conditions and the following disclaimer.}
00031 \textcolor{comment}{}
00032 \textcolor{comment}{4. Redistributions in binary form must reproduce the above copyright notice,}
00033 \textcolor{comment}{this list of conditions and the following disclaimer in the documentation and/or}
00034 \textcolor{comment}{other materials provided with the distribution.}
00035 \textcolor{comment}{}
00036 \textcolor{comment}{5. Usage of the binary form on proprietary applications shall require explicit}
00037 \textcolor{comment}{prior written permission from the the copyright holders.}
00038 \textcolor{comment}{}
00039 \textcolor{comment}{6. Neither the name of the copyright holder nor the names of its contributors}
00040 \textcolor{comment}{may be used to endorse or promote products derived from this software without}
00041 \textcolor{comment}{specific prior written permission.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{The copyright holders provide no reassurances that the source code provided does}
00044 \textcolor{comment}{not infringe any patent, copyright, or any other intellectual property rights of}
00045 \textcolor{comment}{third parties. The copyright holders disclaim any liability to any recipient for}
00046 \textcolor{comment}{claims brought against recipient by any third party for infringement of that}
00047 \textcolor{comment}{parties intellectual property rights.}
00048 \textcolor{comment}{}
00049 \textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00050 \textcolor{comment}{ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00051 \textcolor{comment}{WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00052 \textcolor{comment}{DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR}
00053 \textcolor{comment}{ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00054 \textcolor{comment}{(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00055 \textcolor{comment}{LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00056 \textcolor{comment}{ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00057 \textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00058 \textcolor{comment}{SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00059 \textcolor{comment}{*/}
00060 
00061 \textcolor{preprocessor}{#include <cmath>}
00062 \textcolor{preprocessor}{#include <cstring>}
00063 
00064 \textcolor{preprocessor}{#include <iostream>}
00065 \textcolor{preprocessor}{#include <iomanip>}
00066 \textcolor{preprocessor}{#include <limits>}
00067 \textcolor{preprocessor}{#include <algorithm>}
00068 
00069 \textcolor{preprocessor}{#include "\hyperlink{mtk__tools_8h}{mtk\_tools.h}"}
00070 
00071 \textcolor{preprocessor}{#include "\hyperlink{mtk__blas__adapter_8h}{mtk\_blas\_adapter.h}"}
00072 \textcolor{preprocessor}{#include "\hyperlink{mtk__lapack__adapter_8h}{mtk\_lapack\_adapter.h}"}
00073 \textcolor{preprocessor}{#include "\hyperlink{mtk__glpk__adapter_8h}{mtk\_glpk\_adapter.h}"}
00074 
00075 \textcolor{preprocessor}{#include "\hyperlink{mtk__div__1d_8h}{mtk\_div\_1d.h}"}
00076 
00077 \textcolor{keyword}{namespace }mtk \{
00078 
\hypertarget{mtk__div__1d_8cc_source_l00079}{}\hyperlink{namespacemtk_a12db5e6fff3788f728819a60d5c28d01}{00079} std::ostream& \hyperlink{namespacemtk_ad3bcf52cda59ddb5fc7b4bdce76c46dc}{operator <<}(std::ostream &stream, \hyperlink{classmtk_1_1Div1D}{mtk::Div1D} &in) \{
00080 
00082 
00083   stream << \textcolor{stringliteral}{"divergence\_[0] = "} << std::setw(9) << in.\hyperlink{classmtk_1_1Div1D_a0f96410051ba1fa6d91dfa7b7eacead9}{divergence\_}[0] <<
00084     std::endl;
00085 
00087 
00088   stream << \textcolor{stringliteral}{"divergence\_[1:"} << in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00089   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii <= in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_}; ++ii) \{
00090     stream << std::setw(9) << in.\hyperlink{classmtk_1_1Div1D_a0f96410051ba1fa6d91dfa7b7eacead9}{divergence\_}[ii] << \textcolor{stringliteral}{" "};
00091   \}
00092   stream << std::endl;
00093 
00094   \textcolor{keywordflow}{if} (in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} > 2) \{
00095 
00097 
00098     stream << \textcolor{stringliteral}{"divergence\_["} << in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} + 1 << \textcolor{stringliteral}{":"} <<
00099       2*in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} << \textcolor{stringliteral}{"] = "};
00100     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} + 1; ii <= 2*in.
      \hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_}; ++ii) \{
00101       stream << std::setw(9) << in.\hyperlink{classmtk_1_1Div1D_a0f96410051ba1fa6d91dfa7b7eacead9}{divergence\_}[ii] << \textcolor{stringliteral}{" "};
00102     \}
00103     stream << std::endl;
00104 
00106 
00107     \textcolor{keyword}{auto} offset = (2*in.\hyperlink{classmtk_1_1Div1D_a9c8a8d7cd08a72dbd1daa8deee06f9c6}{order\_accuracy\_} + 1);
00108     \textcolor{keywordtype}{int} mm\{\};
00109     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < in.\hyperlink{classmtk_1_1Div1D_a264027144def76d802778391f55381a0}{dim\_null\_}; ++ii) \{
00110       stream << \textcolor{stringliteral}{"divergence\_["} << offset + mm << \textcolor{stringliteral}{":"} <<
00111         offset + mm + in.\hyperlink{classmtk_1_1Div1D_a717240b41eaa2adde858630b9e3d3042}{num\_bndy\_coeffs\_} - 1 << \textcolor{stringliteral}{"] = "};
00112       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < in.\hyperlink{classmtk_1_1Div1D_a717240b41eaa2adde858630b9e3d3042}{num\_bndy\_coeffs\_}; ++jj) \{
00113         \textcolor{keyword}{auto} value = in.\hyperlink{classmtk_1_1Div1D_a0f96410051ba1fa6d91dfa7b7eacead9}{divergence\_}[offset + mm];
00114         stream << std::setw(9) << value << \textcolor{stringliteral}{" "};
00115         ++mm;
00116       \}
00117       stream << std::endl;
00118     \}
00119   \}
00120 
00121   \textcolor{keywordflow}{return} stream;
00122 \}
00123 \}
00124 
\hypertarget{mtk__div__1d_8cc_source_l00125}{}\hyperlink{classmtk_1_1Div1D_a339c66dd4ed8f50cbeda3645de18e5ab}{00125} \hyperlink{classmtk_1_1Div1D_a339c66dd4ed8f50cbeda3645de18e5ab}{mtk::Div1D::Div1D}():
00126   order\_accuracy\_(mtk::\hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{kDefaultOrderAccuracy}),
00127   dim\_null\_(),
00128   num\_bndy\_coeffs\_(),
00129   divergence\_length\_(),
00130   minrow\_(),
00131   row\_(),
00132   coeffs\_interior\_(),
00133   prem\_apps\_(),
00134   weights\_crs\_(),
00135   weights\_cbs\_(),
00136   mim\_bndy\_(),
00137   divergence\_(),
00138   mimetic\_threshold\_(mtk::\hyperlink{group__c01-roots_ga35718d949bdc81a08a9cc8ebbe3478a2}{kDefaultMimeticThreshold}) \{\}
00139 
\hypertarget{mtk__div__1d_8cc_source_l00140}{}\hyperlink{classmtk_1_1Div1D_a25376152cf97aa27f6b61bcb62b4ea7a}{00140} \hyperlink{classmtk_1_1Div1D_a339c66dd4ed8f50cbeda3645de18e5ab}{mtk::Div1D::Div1D}(\textcolor{keyword}{const} \hyperlink{classmtk_1_1Div1D}{Div1D} &div):
00141   order\_accuracy\_(div.order\_accuracy\_),
00142   dim\_null\_(div.dim\_null\_),
00143   num\_bndy\_coeffs\_(div.num\_bndy\_coeffs\_),
00144   divergence\_length\_(div.divergence\_length\_),
00145   minrow\_(div.minrow\_),
00146   row\_(div.row\_),
00147   coeffs\_interior\_(div.coeffs\_interior\_),
00148   prem\_apps\_(div.prem\_apps\_),
00149   weights\_crs\_(div.weights\_crs\_),
00150   weights\_cbs\_(div.weights\_cbs\_),
00151   mim\_bndy\_(div.mim\_bndy\_),
00152   divergence\_(div.divergence\_),
00153   mimetic\_threshold\_(div.mimetic\_threshold\_) \{\}
00154 
\hypertarget{mtk__div__1d_8cc_source_l00155}{}\hyperlink{classmtk_1_1Div1D_ac2c215f42b8da513df2a4ee477b5fa1f}{00155} \hyperlink{classmtk_1_1Div1D_ac2c215f42b8da513df2a4ee477b5fa1f}{mtk::Div1D::~Div1D}() \{
00156 
00157   \textcolor{keyword}{delete}[] coeffs\_interior\_;
00158   coeffs\_interior\_ = \textcolor{keyword}{nullptr};
00159 
00160   \textcolor{keyword}{delete}[] prem\_apps\_;
00161   prem\_apps\_ = \textcolor{keyword}{nullptr};
00162 
00163   \textcolor{keyword}{delete}[] weights\_crs\_;
00164   weights\_crs\_ = \textcolor{keyword}{nullptr};
00165 
00166   \textcolor{keyword}{delete}[] weights\_cbs\_;
00167   weights\_cbs\_ = \textcolor{keyword}{nullptr};
00168 
00169   \textcolor{keyword}{delete}[] mim\_bndy\_;
00170   mim\_bndy\_ = \textcolor{keyword}{nullptr};
00171 
00172   \textcolor{keyword}{delete}[] divergence\_;
00173   divergence\_ = \textcolor{keyword}{nullptr};
00174 \}
00175 
\hypertarget{mtk__div__1d_8cc_source_l00176}{}\hyperlink{classmtk_1_1Div1D_a52fcd1542f11e606e36bd188e48bfdf7}{00176} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_a52fcd1542f11e606e36bd188e48bfdf7}{mtk::Div1D::ConstructDiv1D}(\textcolor{keywordtype}{int} order\_accuracy,
00177                                 \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} mimetic\_threshold) \{
00178 
00179 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00180 \textcolor{preprocessor}{}  \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(order\_accuracy < 2, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00181   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}((order\_accuracy%2) != 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00182   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(mimetic\_threshold <= \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00183                       \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00184 
00185   \textcolor{keywordflow}{if} (order\_accuracy >= \hyperlink{group__c01-roots_ga0898eef2108473e44a5223932d571c31}{mtk::kCriticalOrderAccuracyDiv}) \{
00186     std::cout << \textcolor{stringliteral}{"WARNING: Numerical accuracy is critical."} << std::endl;
00187   \}
00188 
00189   std::cout << \textcolor{stringliteral}{"order\_accuracy\_ = "} << order\_accuracy << std::endl;
00190   std::cout << \textcolor{stringliteral}{"mimetic\_threshold\_ = "} << mimetic\_threshold << std::endl;
00191 \textcolor{preprocessor}{  #endif}
00192 \textcolor{preprocessor}{}
00193   order\_accuracy\_ = order\_accuracy;
00194   mimetic\_threshold\_ = mimetic\_threshold;
00195 
00197 
00198   \textcolor{keywordtype}{bool} abort\_construction = ComputeStencilInteriorGrid();
00199 
00200 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00201 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00202     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 1."} << std::endl;
00203     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00204     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00205   \}
00206 \textcolor{preprocessor}{  #endif}
00207 \textcolor{preprocessor}{}
00208   \textcolor{comment}{// At this point, we already have the values for the interior stencil stored}
00209   \textcolor{comment}{// in the coeffs\_interior\_ array.}
00210 
00211   \textcolor{comment}{// It is noteworthy, that the 2nd-order-accurate divergence operator has NO}
00212   \textcolor{comment}{// approximation at the boundary, thus it has no weights. For this case, the}
00213   \textcolor{comment}{// dimension of the null-space of the Vandermonde matrices used to compute the}
00214   \textcolor{comment}{// approximating coefficients at the boundary is 0. Ergo, we compute this}
00215   \textcolor{comment}{// number first and then decide if we must compute anything at the boundary.}
00216 
00217   dim\_null\_ = order\_accuracy\_/2 - 1;
00218 
00219   \textcolor{keywordflow}{if} (dim\_null\_ > 0) \{
00220 
00221 \textcolor{preprocessor}{    #ifdef MTK\_PRECISION\_DOUBLE}
00222 \textcolor{preprocessor}{}    num\_bndy\_coeffs\_ = (int) (3.0*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0);
00223 \textcolor{preprocessor}{    #else}
00224 \textcolor{preprocessor}{}    num\_bndy\_coeffs\_ = (int) (3.0f*((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f);
00225 \textcolor{preprocessor}{    #endif}
00226 \textcolor{preprocessor}{}
00228 
00229     \textcolor{comment}{// For this we will follow recommendations given in:}
00230     \textcolor{comment}{//}
00231     \textcolor{comment}{// http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=5&t=4506}
00232     \textcolor{comment}{//}
00233     \textcolor{comment}{// We will compute the QR Factorization of the transpose, as in the}
00234     \textcolor{comment}{// following (MATLAB) pseudo-code:}
00235     \textcolor{comment}{//}
00236     \textcolor{comment}{// [Q,R] = qr(V'); % Full QR as defined in}
00237     \textcolor{comment}{// % http://www.stanford.edu/class/ee263/notes/qr\_matlab.pdf}
00238     \textcolor{comment}{//}
00239     \textcolor{comment}{// null-space = Q(:, last (order\_accuracy\_/2 - 1) columns of Q );}
00240     \textcolor{comment}{//}
00241     \textcolor{comment}{// However, given the nature of the Vandermonde matrices we've just}
00242     \textcolor{comment}{// computed, they all posses the same null-space. Therefore, we impose the}
00243     \textcolor{comment}{// convention of computing the null-space of the first Vandermonde matrix}
00244     \textcolor{comment}{// (west boundary).}
00245 
00246     abort\_construction = ComputeRationalBasisNullSpace();
00247 
00248 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00249 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00250       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.1."} << std::endl;
00251       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00252       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00253     \}
00254 \textcolor{preprocessor}{    #endif}
00255 \textcolor{preprocessor}{}
00257 
00258     abort\_construction = ComputePreliminaryApproximations();
00259 
00260 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00261 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00262       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.2."} << std::endl;
00263       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00264       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00265     \}
00266 \textcolor{preprocessor}{    #endif}
00267 \textcolor{preprocessor}{}
00269 
00270     abort\_construction = ComputeWeights();
00271 
00272 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00273 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00274       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.3."} << std::endl;
00275       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00276       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00277     \}
00278 \textcolor{preprocessor}{    #endif}
00279 \textcolor{preprocessor}{}
00281 
00282     abort\_construction = ComputeStencilBoundaryGrid();
00283 
00284 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00285 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!abort\_construction) \{
00286       std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 2.4."} << std::endl;
00287       std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00288       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00289     \}
00290 \textcolor{preprocessor}{    #endif}
00291 \textcolor{preprocessor}{}
00292   \} \textcolor{comment}{// End of: if (dim\_null\_ > 0);}
00293 
00295 
00296   \textcolor{comment}{// Once we have the following three collections of data:}
00297   \textcolor{comment}{//   (a) the coefficients for the interior,}
00298   \textcolor{comment}{//   (b) the coefficients for the boundary (if it applies),}
00299   \textcolor{comment}{//   (c) and the weights (if it applies),}
00300   \textcolor{comment}{// we will store everything in the output array:}
00301 
00302   abort\_construction = AssembleOperator();
00303 
00304 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00305 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!abort\_construction) \{
00306     std::cerr << \textcolor{stringliteral}{"Could NOT complete stage 3."} << std::endl;
00307     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00308     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00309   \}
00310 \textcolor{preprocessor}{  #endif}
00311 \textcolor{preprocessor}{}
00312   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00313 \}
00314 
\hypertarget{mtk__div__1d_8cc_source_l00315}{}\hyperlink{classmtk_1_1Div1D_a3739d9659cf6c31fd2f21bc9fcaaef98}{00315} \textcolor{keywordtype}{int} \hyperlink{classmtk_1_1Div1D_a3739d9659cf6c31fd2f21bc9fcaaef98}{mtk::Div1D::num\_bndy\_coeffs}() \{
00316 
00317   \textcolor{keywordflow}{return} num\_bndy\_coeffs\_;
00318 \}
00319 
\hypertarget{mtk__div__1d_8cc_source_l00320}{}\hyperlink{classmtk_1_1Div1D_a77e27cac7b7a105311d882e5d126d1bf}{00320} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Div1D_a77e27cac7b7a105311d882e5d126d1bf}{mtk::Div1D::weights\_crs}() \{
00321 
00322   \textcolor{keywordflow}{return} weights\_crs\_;
00323 \}
00324 
\hypertarget{mtk__div__1d_8cc_source_l00325}{}\hyperlink{classmtk_1_1Div1D_a163bf1575222651c84ee83092d6734e5}{00325} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *\hyperlink{classmtk_1_1Div1D_a163bf1575222651c84ee83092d6734e5}{mtk::Div1D::weights\_cbs}() \{
00326 
00327   \textcolor{keywordflow}{return} weights\_cbs\_;
00328 \}
00329 
\hypertarget{mtk__div__1d_8cc_source_l00330}{}\hyperlink{classmtk_1_1Div1D_afdbb1e11f05dd77b882f36426229acf7}{00330} \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} \hyperlink{classmtk_1_1Div1D_afdbb1e11f05dd77b882f36426229acf7}{mtk::Div1D::ReturnAsDenseMatrix}(\textcolor{keyword}{const} 
      \hyperlink{classmtk_1_1UniStgGrid1D}{UniStgGrid1D} &grid) \{
00331 
00332   \textcolor{keywordtype}{int} nn\{grid.\hyperlink{classmtk_1_1UniStgGrid1D_af1b3729d8afa07be5b2775ed68015b80}{num\_cells\_x}()\}; \textcolor{comment}{// Number of cells on the grid.}
00333 
00334 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00335 \textcolor{preprocessor}{}  \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(order\_accuracy\_ <= 0, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00336   \hyperlink{classmtk_1_1Tools_acbcff02946d3db565d53ecbcc459f0b5}{mtk::Tools::Prevent}(nn < 3*order\_accuracy\_ - 1, \_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_);
00337 \textcolor{preprocessor}{  #endif}
00338 \textcolor{preprocessor}{}
00339   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} inv\_delta\_x\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}/grid.\hyperlink{classmtk_1_1UniStgGrid1D_a6e7173b01241632cf509496d66b9f74c}{delta\_x}()\};
00340 
00341   \textcolor{keywordtype}{int} dd\_num\_rows = nn + 2;
00342   \textcolor{keywordtype}{int} dd\_num\_cols = nn + 1;
00343   \textcolor{keywordtype}{int} elements\_per\_row = num\_bndy\_coeffs\_;
00344   \textcolor{keywordtype}{int} num\_extra\_rows = dim\_null\_;
00345 
00346   \textcolor{comment}{// Output matrix featuring sizes for divergence operators.}
00347   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} out(dd\_num\_rows, dd\_num\_cols);
00348 
00350 
00351   \textcolor{keyword}{auto} ee\_index = 0;
00352   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_extra\_rows + 1; ii++) \{
00353     \textcolor{keyword}{auto} cc = 0;
00354     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0 ; jj < dd\_num\_rows; jj++) \{
00355       \textcolor{keywordflow}{if}( cc >= elements\_per\_row) \{
00356         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii, jj, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero});
00357       \} \textcolor{keywordflow}{else} \{
00358         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj, mim\_bndy\_[ee\_index++]*inv\_delta\_x);
00359         cc++;
00360       \}
00361     \}
00362   \}
00363 
00365 
00366   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_extra\_rows + 1;
00367        ii < dd\_num\_rows - num\_extra\_rows - 1; ii++) \{
00368     \textcolor{keyword}{auto} jj = ii - num\_extra\_rows - 1;
00369     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cc = 0; cc < order\_accuracy\_; cc++, jj++) \{
00370       out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii, jj, coeffs\_interior\_[cc]*inv\_delta\_x);
00371     \}
00372   \}
00373 
00375 
00376   ee\_index = 0;
00377   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = dd\_num\_rows - 2; ii >= dd\_num\_rows - num\_extra\_rows - 1; ii--) \{
00378     \textcolor{keyword}{auto} cc = 0;
00379     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dd\_num\_cols - 1; jj >= 0; jj--) \{
00380       \textcolor{keywordflow}{if}( cc >= elements\_per\_row) \{
00381         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj,0.0);
00382       \} \textcolor{keywordflow}{else} \{
00383         out.\hyperlink{classmtk_1_1DenseMatrix_ae0f873a6d3a734da467cafb817da64ae}{SetValue}(ii,jj,-mim\_bndy\_[ee\_index++]*inv\_delta\_x);
00384         cc++;
00385       \}
00386      \}
00387   \}
00388 
00389   \textcolor{keywordflow}{return} out;
00390 \}
00391 
\hypertarget{mtk__div__1d_8cc_source_l00392}{}\hyperlink{classmtk_1_1Div1D_a3eb3a32862a6b066cd583cbbd00a6509}{00392} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_a3eb3a32862a6b066cd583cbbd00a6509}{mtk::Div1D::ComputeStencilInteriorGrid}() \{
00393 
00395 
00396   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* pp\{\}; \textcolor{comment}{// Spatial coordinates to create interior stencil.}
00397 
00398   \textcolor{keywordflow}{try} \{
00399     pp = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00400   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00401     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00402       std::endl;
00403     std::cerr << memory\_allocation\_exception.what() << std::endl;
00404   \}
00405   memset(pp, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(pp[0])*order\_accuracy\_);
00406 
00407 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00408 \textcolor{preprocessor}{}  pp[0] = 1.0/2.0 - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0;
00409 \textcolor{preprocessor}{  #else}
00410 \textcolor{preprocessor}{}  pp[0] = 1.0f/2.0f - ((\hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}) order\_accuracy\_)/2.0f;
00411 \textcolor{preprocessor}{  #endif}
00412 \textcolor{preprocessor}{}
00413   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < order\_accuracy\_; ++ii) \{
00414     pp[ii] = pp[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00415   \}
00416 
00417 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00418 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"pp ="} << std::endl;
00419   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00420     std::cout << std::setw(12) << pp[ii];
00421   \}
00422   std::cout << std::endl << std::endl;
00423 \textcolor{preprocessor}{  #endif}
00424 \textcolor{preprocessor}{}
00426 
00427   \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00428 
00429   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vander\_matrix(pp,
00430                                  order\_accuracy\_,
00431                                  order\_accuracy\_,
00432                                  transpose);
00433 
00434 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00435 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"vander\_matrix = "} << std::endl;
00436   std::cout << vander\_matrix << std::endl;
00437 \textcolor{preprocessor}{  #endif}
00438 \textcolor{preprocessor}{}
00440 
00441   \textcolor{keywordflow}{try} \{
00442     coeffs\_interior\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[order\_accuracy\_];
00443   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00444     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00445       std::endl;
00446     std::cerr << memory\_allocation\_exception.what() << std::endl;
00447   \}
00448   memset(coeffs\_interior\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(coeffs\_interior\_[0])*order\_accuracy\_);
00449 
00450   coeffs\_interior\_[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00451 
00452 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00453 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"oo ="} << std::endl;
00454   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00455     std::cout << std::setw(12) << coeffs\_interior\_[ii] << std::endl;
00456   \}
00457   std::cout << std::endl;
00458 \textcolor{preprocessor}{  #endif}
00459 \textcolor{preprocessor}{}
00461 
00462   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(vander\_matrix,
00463                                                 coeffs\_interior\_)\};
00464 
00465 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00466 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
00467     std::cout << \textcolor{stringliteral}{"System solved! Interior stencil attained!"} << std::endl;
00468     std::cout << std::endl;
00469   \}
00470   \textcolor{keywordflow}{else} \{
00471     std::cerr << \textcolor{stringliteral}{"Something wrong solving system! info = "} << info << std::endl;
00472     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00473     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00474   \}
00475 \textcolor{preprocessor}{  #endif}
00476 \textcolor{preprocessor}{}
00477 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00478 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00479   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00480     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00481   \}
00482   std::cout << std::endl << std::endl;
00483 \textcolor{preprocessor}{  #endif}
00484 \textcolor{preprocessor}{}
00485   \textcolor{keyword}{delete} [] pp;
00486   pp = \textcolor{keyword}{nullptr};
00487 
00488   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00489 \}
00490 
\hypertarget{mtk__div__1d_8cc_source_l00491}{}\hyperlink{classmtk_1_1Div1D_aa0c0c278b2c00a29c1ceaa70d31aebab}{00491} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_aa0c0c278b2c00a29c1ceaa70d31aebab}{mtk::Div1D::ComputeRationalBasisNullSpace}(\textcolor{keywordtype}{void}) \{
00492 
00493   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}* gg\{\}; \textcolor{comment}{// Generator vector for the first Vandermonde matrix.}
00494 
00496 
00497   \textcolor{keywordflow}{try} \{
00498     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00499   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00500     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00501       std::endl;
00502     std::cerr << memory\_allocation\_exception.what() << std::endl;
00503   \}
00504   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00505 
00506 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00507 \textcolor{preprocessor}{}  gg[0] = -1.0/2.0;
00508 \textcolor{preprocessor}{  #else}
00509 \textcolor{preprocessor}{}  gg[0] = -1.0f/2.0f;
00510 \textcolor{preprocessor}{  #endif}
00511 \textcolor{preprocessor}{}  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_coeffs\_; ++ii) \{
00512     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00513   \}
00514 
00515 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00516 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"gg ="} << std::endl;
00517   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00518     std::cout << std::setw(12) << gg[ii];
00519   \}
00520   std::cout << std::endl << std::endl;
00521 \textcolor{preprocessor}{  #endif}
00522 \textcolor{preprocessor}{}
00524 
00525   \textcolor{keywordtype}{bool} tran\{\textcolor{keyword}{true}\}; \textcolor{comment}{// Should I transpose the Vandermonde matrix.}
00526 
00527   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} vv\_west\_t(gg, num\_bndy\_coeffs\_, order\_accuracy\_ + 1, tran);
00528 
00529 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00530 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"vv\_west\_t ="} << std::endl;
00531   std::cout << vv\_west\_t << std::endl;
00532 \textcolor{preprocessor}{  #endif}
00533 \textcolor{preprocessor}{}
00535 
00536   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} qq\_t(\hyperlink{classmtk_1_1LAPACKAdapter_ae5c6e78c9c819c9ac7a6f31bfd011d7a}{mtk::LAPACKAdapter::QRFactorDenseMatrix}
      (vv\_west\_t));
00537 
00538 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00539 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"QQ^T = "} << std::endl;
00540   std::cout << qq\_t << std::endl;
00541 \textcolor{preprocessor}{  #endif}
00542 \textcolor{preprocessor}{}
00544 
00545   \textcolor{keywordtype}{int} KK\_num\_rows\_\{num\_bndy\_coeffs\_\};
00546   \textcolor{keywordtype}{int} KK\_num\_cols\_\{dim\_null\_\};
00547 
00548   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} KK(KK\_num\_rows\_, KK\_num\_cols\_);
00549 
00550   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_bndy\_coeffs\_ - dim\_null\_; ii < num\_bndy\_coeffs\_; ++ii) \{
00551     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; ++jj) \{
00552       KK.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[jj*dim\_null\_ + (ii - (num\_bndy\_coeffs\_ - dim\_null\_))] =
00553           qq\_t.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*num\_bndy\_coeffs\_ + jj];
00554     \}
00555   \}
00556 
00557 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00558 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"KK ="} << std::endl;
00559   std::cout << KK << std::endl;
00560   std::cout << \textcolor{stringliteral}{"KK.num\_rows() = "} << KK.\hyperlink{classmtk_1_1DenseMatrix_a17d8d3b9cc0926044b6972dd190a5c21}{num\_rows}() << std::endl;
00561   std::cout << \textcolor{stringliteral}{"KK.num\_cols() = "} << KK.\hyperlink{classmtk_1_1DenseMatrix_af6f78373aaf2136f0c78974d7c8de0a8}{num\_cols}() << std::endl;
00562   std::cout << std::endl;
00563 \textcolor{preprocessor}{  #endif}
00564 \textcolor{preprocessor}{}
00566 
00567   \textcolor{comment}{// Scale thus requesting that the last entries of the attained basis for the}
00568   \textcolor{comment}{// null-space, adopt the pattern we require.}
00569   \textcolor{comment}{// Essentially we will implement the following MATLAB pseudo-code:}
00570   \textcolor{comment}{//  scalers = KK(num\_bndy\_approxs - (dim\_null - 1):num\_bndy\_approxs,:)\(\backslash\)B}
00571   \textcolor{comment}{//  SK = KK*scalers}
00572   \textcolor{comment}{// where SK is the scaled null-space.}
00573 
00574   \textcolor{comment}{// In this point, we almost have all the data we need correctly allocated}
00575   \textcolor{comment}{// in memory. We will create the matrix II\_, and elements we wish to scale in}
00576   \textcolor{comment}{// the KK array. Using the concept of the leading dimension, we could just}
00577   \textcolor{comment}{// use KK, with the correct leading dimension and that is it. BUT I DO NOT}
00578   \textcolor{comment}{// GET how does it work. So I will just create a matrix with the content of}
00579   \textcolor{comment}{// this array that we need, solve for the scalers and then scale the}
00580   \textcolor{comment}{// whole KK:}
00581 
00582   \textcolor{comment}{// We will then create memory for that sub-matrix of KK (SUBK).}
00583 
00584   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} SUBK(dim\_null\_,dim\_null\_);
00585 
00586   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = num\_bndy\_coeffs\_ - dim\_null\_; ii < num\_bndy\_coeffs\_; ++ii) \{
00587     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
00588       SUBK.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(ii - (num\_bndy\_coeffs\_ - dim\_null\_))*dim\_null\_ + jj] =
00589           KK.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*dim\_null\_ + jj];
00590     \}
00591   \}
00592 
00593 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00594 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"SUBK ="} << std::endl;
00595   std::cout << SUBK << std::endl;
00596 \textcolor{preprocessor}{  #endif}
00597 \textcolor{preprocessor}{}
00598   SUBK.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
00599 
00600 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00601 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"SUBK^T ="} << std::endl;
00602   std::cout << SUBK << std::endl;
00603 \textcolor{preprocessor}{  #endif}
00604 \textcolor{preprocessor}{}
00605   \textcolor{keywordtype}{bool} padded\{\textcolor{keyword}{false}\};
00606   tran = \textcolor{keyword}{false};
00607 
00608   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} II(dim\_null\_, padded, tran);
00609 
00610 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00611 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"II ="} << std::endl;
00612   std::cout << II << std::endl;
00613 \textcolor{preprocessor}{  #endif}
00614 \textcolor{preprocessor}{}
00615   \textcolor{comment}{// Solve the system to compute the scalers.}
00616   \textcolor{comment}{// An example of the system to solve, for k = 8, is:}
00617   \textcolor{comment}{//}
00618   \textcolor{comment}{// SUBK*scalers = II\_ or}
00619   \textcolor{comment}{//}
00620   \textcolor{comment}{// |  0.386018  -0.0339244   -0.129478 |           | 1 0 0 |}
00621   \textcolor{comment}{// | -0.119774   0.0199423   0.0558632 |*scalers = | 0 1 0 |}
00622   \textcolor{comment}{// | 0.0155708 -0.00349546 -0.00853182 |           | 0 0 1 |}
00623   \textcolor{comment}{//}
00624   \textcolor{comment}{// Notice this is a nrhs = 3 system.}
00625   \textcolor{comment}{// Noteworthy: we do NOT ACTUALLY ALLOCATE space for the scalers... they}
00626   \textcolor{comment}{// will be stored in the created identity matrix.}
00627   \textcolor{comment}{// Let us first transpose SUBK (because of LAPACK):}
00628 
00629   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a7428bccf74fd4a4af68fb7233846da22}{mtk::LAPACKAdapter::SolveDenseSystem}(SUBK, II)\};
00630 
00631 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00632 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
00633     std::cout << \textcolor{stringliteral}{"System successfully solved!"} <<
00634       std::endl;
00635   \} \textcolor{keywordflow}{else} \{
00636     std::cerr << \textcolor{stringliteral}{"Something went wrong solving system! info = "} << info <<
00637       std::endl;
00638     std::cerr << \textcolor{stringliteral}{"Exiting..."} << std::endl;
00639     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00640   \}
00641   std::cout << std::endl;
00642 \textcolor{preprocessor}{  #endif}
00643 \textcolor{preprocessor}{}
00644 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00645 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Computed scalers:"} << std::endl;
00646   std::cout << II << std::endl;
00647 \textcolor{preprocessor}{  #endif}
00648 \textcolor{preprocessor}{}
00649   \textcolor{comment}{// Multiply the two matrices to attain a scaled basis for null-space.}
00650 
00651   rat\_basis\_null\_space\_ = \hyperlink{classmtk_1_1BLASAdapter_acebd0e9bfe0bdd609c7fbea98ccfd3b5}{mtk::BLASAdapter::RealDenseMM}(KK, II);
00652 
00653 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00654 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00655   std::cout << rat\_basis\_null\_space\_ << std::endl;
00656 \textcolor{preprocessor}{  #endif}
00657 \textcolor{preprocessor}{}
00658   \textcolor{comment}{// At this point, we have a rational basis for the null-space, with the}
00659   \textcolor{comment}{// pattern we need! :)}
00660 
00661   \textcolor{keyword}{delete} [] gg;
00662   gg = \textcolor{keyword}{nullptr};
00663 
00664   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00665 \}
00666 
\hypertarget{mtk__div__1d_8cc_source_l00667}{}\hyperlink{classmtk_1_1Div1D_a4be0534a4e22d44a7aedde326cc3f3b6}{00667} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_a4be0534a4e22d44a7aedde326cc3f3b6}{mtk::Div1D::ComputePreliminaryApproximations}(\textcolor{keywordtype}{void}) \{
00668 
00670 
00671   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *gg\{\}; \textcolor{comment}{// Generator vector for the first approximation.}
00672 
00673   \textcolor{keywordflow}{try} \{
00674     gg = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00675   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00676     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00677 std::endl;
00678     std::cerr << memory\_allocation\_exception.what() << std::endl;
00679   \}
00680   memset(gg, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(gg[0])*num\_bndy\_coeffs\_);
00681 
00682 \textcolor{preprocessor}{  #ifdef MTK\_PRECISION\_DOUBLE}
00683 \textcolor{preprocessor}{}  gg[0] = -1.0/2.0;
00684 \textcolor{preprocessor}{  #else}
00685 \textcolor{preprocessor}{}  gg[0] = -1.0f/2.0f;
00686 \textcolor{preprocessor}{  #endif}
00687 \textcolor{preprocessor}{}  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 1; ii < num\_bndy\_coeffs\_; ++ii) \{
00688     gg[ii] = gg[ii - 1] + \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00689   \}
00690 
00691 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00692 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"gg0 ="} << std::endl;
00693   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00694     std::cout << std::setw(12) << gg[ii];
00695   \}
00696   std::cout << std::endl << std::endl;
00697 \textcolor{preprocessor}{  #endif}
00698 \textcolor{preprocessor}{}
00699   \textcolor{comment}{// Allocate 2D array to store the collection of preliminary approximations.}
00700   \textcolor{keywordflow}{try} \{
00701     prem\_apps\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*dim\_null\_];
00702   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00703     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00704 std::endl;
00705     std::cerr << memory\_allocation\_exception.what() << std::endl;
00706   \}
00707   memset(prem\_apps\_,
00708          \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero},
00709          \textcolor{keyword}{sizeof}(prem\_apps\_[0])*num\_bndy\_coeffs\_*dim\_null\_);
00710 
00712 
00713   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ll = 0; ll < dim\_null\_; ++ll) \{
00714 
00715     \textcolor{comment}{// Re-check new generator vector for every iteration except for the first.}
00716 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00717 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (ll > 0) \{
00718       std::cout << \textcolor{stringliteral}{"gg"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00719       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00720         std::cout << std::setw(12) << gg[ii];
00721       \}
00722       std::cout << std::endl << std::endl;
00723     \}
00724 \textcolor{preprocessor}{    #endif}
00725 \textcolor{preprocessor}{}
00727 
00728     \textcolor{keywordtype}{bool} transpose\{\textcolor{keyword}{false}\};
00729 
00730     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} AA\_(gg,
00731                          num\_bndy\_coeffs\_, order\_accuracy\_ + 1,
00732                          transpose);
00733 
00734 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00735 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"AA\_"} << ll << \textcolor{stringliteral}{" ="} << std::endl;
00736     std::cout << AA\_ << std::endl;
00737 \textcolor{preprocessor}{    #endif}
00738 \textcolor{preprocessor}{}
00740 
00741     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *ob\{\};
00742 
00743     \textcolor{keyword}{auto} ob\_ld = num\_bndy\_coeffs\_;
00744 
00745     \textcolor{keywordflow}{try} \{
00746       ob = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[ob\_ld];
00747     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00748       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00749         std::endl;
00750       std::cerr << memory\_allocation\_exception.what() << std::endl;
00751     \}
00752     memset(ob, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob[0])*ob\_ld);
00753 
00754     ob[1] = \hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00755 
00756 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00757 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob = "} << std::endl << std::endl;
00758     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00759       std::cout << std::setw(12) << ob[ii] << std::endl;
00760     \}
00761     std::cout << std::endl;
00762 \textcolor{preprocessor}{    #endif}
00763 \textcolor{preprocessor}{}
00765 
00766     \textcolor{comment}{// However, this is an under-determined system of equations. So we can not}
00767     \textcolor{comment}{// use the same LAPACK routine (dgesv\_). We will instead use dgels\_, through}
00768     \textcolor{comment}{// our LAPACKAdapter class.}
00769 
00770     \textcolor{keywordtype}{int} info\_\{
00771       \hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(AA\_, 
      ob, ob\_ld)\};
00772 
00773 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00774 \textcolor{preprocessor}{}    \textcolor{keywordflow}{if} (!info\_) \{
00775       std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
00776     \} \textcolor{keywordflow}{else} \{
00777       std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info\_ << std::endl;
00778     \}
00779 \textcolor{preprocessor}{    #endif}
00780 \textcolor{preprocessor}{}
00781 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00782 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob ="} << std::endl;
00783     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < ob\_ld; ++ii) \{
00784       std::cout << std::setw(12) << ob[ii] << std::endl;
00785     \}
00786     std::cout << std::endl;
00787 \textcolor{preprocessor}{    #endif}
00788 \textcolor{preprocessor}{}
00790 
00791     \textcolor{comment}{// This implies a DAXPY operation. However, we must construct the arguments}
00792     \textcolor{comment}{// for this operation.}
00793 
00795     \textcolor{comment}{// Save them into the ob\_bottom array:}
00796 
00797     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{Real} *ob\_bottom\{\}; \textcolor{comment}{// Bottom part of the attained kernel used to scale it.}
00798 
00799     \textcolor{keywordflow}{try} \{
00800       ob\_bottom = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
00801     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00802       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00803         std::endl;
00804       std::cerr << memory\_allocation\_exception.what() << std::endl;
00805     \}
00806     memset(ob\_bottom, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(ob\_bottom[0])*dim\_null\_);
00807 
00808     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00809       ob\_bottom[(dim\_null\_ - 1) - ii] = ob[num\_bndy\_coeffs\_ - ii - 1];
00810     \}
00811 
00812 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00813 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"ob\_bottom ="} << std::endl;
00814     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
00815       std::cout << std::setw(12) << ob\_bottom[ii] << std::endl;
00816     \}
00817     std::cout << std::endl;
00818 \textcolor{preprocessor}{    #endif}
00819 \textcolor{preprocessor}{}
00821 
00822     \textcolor{comment}{// We must computed an scaled ob, sob, using the scaled null-space in}
00823     \textcolor{comment}{// rat\_basis\_null\_space\_.}
00824     \textcolor{comment}{// Such operation is: sob = ob - rat\_basis\_null\_space\_*ob\_bottom}
00825     \textcolor{comment}{// or:                 ob = -1.0*rat\_basis\_null\_space\_*ob\_bottom + 1.0*ob}
00826     \textcolor{comment}{// thus:                Y =    a*A    *x         +   b*Y (DAXPY).}
00827 
00828 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00829 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Rational basis for the null-space:"} << std::endl;
00830     std::cout << rat\_basis\_null\_space\_ << std::endl;
00831 \textcolor{preprocessor}{    #endif}
00832 \textcolor{preprocessor}{}
00833     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} alpha\{-\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00834     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} beta\{\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}\};
00835 
00836     \hyperlink{classmtk_1_1BLASAdapter_afdcac059a4294287cb55638221220646}{mtk::BLASAdapter::RealDenseMV}(alpha, rat\_basis\_null\_space\_,
00837                                   ob\_bottom, beta, ob);
00838 
00839 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
00840 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"scaled ob:"} << std::endl;
00841     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00842       std::cout << std::setw(12) << ob[ii] << std::endl;
00843     \}
00844     std::cout << std::endl;
00845 \textcolor{preprocessor}{    #endif}
00846 \textcolor{preprocessor}{}
00847     \textcolor{comment}{// We save the recently scaled solution, into an array containing these.}
00848     \textcolor{comment}{// We can NOT start building the pi matrix, simply because I want that part}
00849     \textcolor{comment}{// to be separated since its construction depends on the algorithm we want}
00850     \textcolor{comment}{// to implement.}
00851 
00852     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00853       prem\_apps\_[ii*dim\_null\_ + ll] = ob[ii];
00854     \}
00855 
00856     \textcolor{comment}{// After the first iteration, simply shift the entries of the last}
00857     \textcolor{comment}{// generator vector used:}
00858     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00859       gg[ii]--;
00860     \}
00861 
00862     \textcolor{comment}{// Garbage collection for this loop:}
00863     \textcolor{keyword}{delete}[] ob;
00864     ob = \textcolor{keyword}{nullptr};
00865 
00866     \textcolor{keyword}{delete}[] ob\_bottom;
00867     ob\_bottom = \textcolor{keyword}{nullptr};
00868   \} \textcolor{comment}{// End of: for (ll = 0; ll < dim\_null; ll++);}
00869 
00870 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00871 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Matrix post-scaled preliminary apps: "} << std::endl;
00872   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00873     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
00874       std::cout << std::setw(12) << prem\_apps\_[ii*dim\_null\_ + jj];
00875     \}
00876     std::cout << std::endl;
00877   \}
00878   std::cout << std::endl;
00879 \textcolor{preprocessor}{  #endif}
00880 \textcolor{preprocessor}{}
00881   \textcolor{keyword}{delete}[] gg;
00882   gg = \textcolor{keyword}{nullptr};
00883 
00884   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00885 \}
00886 
\hypertarget{mtk__div__1d_8cc_source_l00887}{}\hyperlink{classmtk_1_1Div1D_aaadd6a6e6836bb94841c4c35dffab828}{00887} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_aaadd6a6e6836bb94841c4c35dffab828}{mtk::Div1D::ComputeWeights}(\textcolor{keywordtype}{void}) \{
00888 
00889   \textcolor{comment}{// Matrix to copmpute the weights as in the CRSA.}
00890   \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} pi(num\_bndy\_coeffs\_, num\_bndy\_coeffs\_ - 1);
00891 
00893 
00894   \textcolor{comment}{// Assemble the pi matrix using:}
00895   \textcolor{comment}{// 1. The collection of scaled preliminary approximations.}
00896   \textcolor{comment}{// 2. The collection of coefficients approximating at the interior.}
00897   \textcolor{comment}{// 3. The scaled basis for the null-space.}
00898 
00899   \textcolor{comment}{// 1.1. Process array of scaled preliminary approximations.}
00900 
00901   \textcolor{comment}{// These are queued in scaled\_solutions. Each one of these, will be a column}
00902   \textcolor{comment}{// of the pi matrix:}
00903   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00904     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
00905       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj] =
00906         prem\_apps\_[ii*dim\_null\_ + jj];
00907     \}
00908   \}
00909 
00910   \textcolor{comment}{// 1.2. Add columns from known stencil approximating at the interior.}
00911 
00912   \textcolor{comment}{// However, these must be padded by zeros, according to their position in the}
00913   \textcolor{comment}{// final pi matrix:}
00914   \textcolor{keyword}{auto} mm = 0;
00915   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_; jj < order\_accuracy\_; ++jj) \{
00916     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00917       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(ii + mm)*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj] =
00918         coeffs\_interior\_[ii];
00919     \}
00920     ++mm;
00921   \}
00922 
00923   rat\_basis\_null\_space\_.OrderColMajor();
00924 
00925 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
00926 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Rational basis for the null-space (col. major):"} << std::endl;
00927   std::cout << rat\_basis\_null\_space\_ << std::endl;
00928 \textcolor{preprocessor}{  #endif}
00929 \textcolor{preprocessor}{}
00930   \textcolor{comment}{// 1.3. Add final set of columns: rational basis for null-space.}
00931   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + (order\_accuracy\_/2 + 1); jj < num\_bndy\_coeffs\_ - 1; ++jj) \{
00932     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
00933       \textcolor{keyword}{auto} og =
00934         (jj - (dim\_null\_ + (order\_accuracy\_/2 + 1)))*num\_bndy\_coeffs\_ + ii;
00935       \textcolor{keyword}{auto} de = ii*(2*dim\_null\_ + (order\_accuracy\_/2 + 1)) + jj;
00936       pi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[de] = rat\_basis\_null\_space\_.data()[og];
00937     \}
00938   \}
00939 
00940 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
00941 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"coeffs\_interior\_ ="} << std::endl;
00942   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
00943     std::cout << std::setw(12) << coeffs\_interior\_[ii];
00944   \}
00945   std::cout << std::endl << std::endl;
00946 \textcolor{preprocessor}{  #endif}
00947 \textcolor{preprocessor}{}
00948 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
00949 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Constructed pi matrix for CRS Algorithm: "} << std::endl;
00950   std::cout << pi << std::endl;
00951 \textcolor{preprocessor}{  #endif}
00952 \textcolor{preprocessor}{}
00954 
00955   \textcolor{comment}{// This imposes the mimetic condition.}
00956 
00957   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *hh\{\};  \textcolor{comment}{// Right-hand side to compute weights in the C\{R,B\}SA.}
00958 
00959   \textcolor{keywordflow}{try} \{
00960     hh = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00961   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00962     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00963       std::endl;
00964     std::cerr << memory\_allocation\_exception.what() << std::endl;
00965   \}
00966   memset(hh, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(hh[0])*num\_bndy\_coeffs\_);
00967 
00968   hh[0] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne};
00969   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = (order\_accuracy\_/2 + 2 - 1); ii < num\_bndy\_coeffs\_; ++ii) \{
00970     \textcolor{keyword}{auto} aux\_xx = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
00971     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < ((ii - (order\_accuracy\_/2 - 1)) - 1); ++jj) \{
00972       aux\_xx += coeffs\_interior\_[jj];
00973     \}
00974     hh[ii] = -\hyperlink{group__c01-roots_ga26407c24d43b6b95480943340d285c71}{mtk::kOne}*aux\_xx;
00975   \}
00976 
00978 
00979   \textcolor{comment}{// That is, we construct a system, to solve for the weights.}
00980 
00981   \textcolor{comment}{// Once again we face the challenge of solving with LAPACK. However, for the}
00982   \textcolor{comment}{// CRSA, this matrix PI is over-determined, since it has more rows than}
00983   \textcolor{comment}{// unknowns. However, according to the theory, the solution to this system is}
00984   \textcolor{comment}{// unique. We will use dgels\_.}
00985 
00986   \textcolor{keywordflow}{try} \{
00987     weights\_cbs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
00988   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
00989     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
00990       std::endl;
00991     std::cerr << memory\_allocation\_exception.what() << std::endl;
00992   \}
00993   memset(weights\_cbs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_cbs\_[0])*num\_bndy\_coeffs\_);
00994 
00995   \textcolor{keywordtype}{int} weights\_ld\{pi.\hyperlink{classmtk_1_1DenseMatrix_af6f78373aaf2136f0c78974d7c8de0a8}{num\_cols}() + 1\};
00996 
00997   \textcolor{comment}{// Preserve hh.}
00998   std::copy(hh, hh + weights\_ld, weights\_cbs\_);
00999 
01000   pi.\hyperlink{classmtk_1_1DenseMatrix_a71d9c07ca66e88d97d1fd5012f43138b}{Transpose}();
01001 
01002   \textcolor{keywordtype}{int} info\{\hyperlink{classmtk_1_1LAPACKAdapter_a380f148ffdf96bae2f79ae28f1a6560c}{mtk::LAPACKAdapter::SolveRectangularDenseSystem}(
      pi, weights\_cbs\_, weights\_ld)\};
01003 
01004 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01005 \textcolor{preprocessor}{}  \textcolor{keywordflow}{if} (!info) \{
01006     std::cout << \textcolor{stringliteral}{"System successfully solved!"} << std::endl << std::endl;
01007   \} \textcolor{keywordflow}{else} \{
01008     std::cerr << \textcolor{stringliteral}{"Error solving system! info = "} << info << std::endl;
01009   \}
01010 \textcolor{preprocessor}{  #endif}
01011 \textcolor{preprocessor}{}
01012 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01013 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"hh ="} << std::endl;
01014   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01015     std::cout << std::setw(11) << hh[ii] << std::endl;
01016   \}
01017   std::cout << std::endl;
01018 \textcolor{preprocessor}{  #endif}
01019 \textcolor{preprocessor}{}
01020   \textcolor{comment}{// Preserve the original weights for research.}
01021 
01022   \textcolor{keywordflow}{try} \{
01023     weights\_crs\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_];
01024   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01025     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01026       std::endl;
01027     std::cerr << memory\_allocation\_exception.what() << std::endl;
01028   \}
01029   memset(weights\_crs\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(weights\_crs\_[0])*num\_bndy\_coeffs\_);
01030 
01031   std::copy(weights\_cbs\_, weights\_cbs\_ + (weights\_ld - 1), weights\_crs\_);
01032 
01033 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01034 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"weights\_CRSA + lambda ="} << std::endl;
01035   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < weights\_ld - 1; ++ii) \{
01036     std::cout << std::setw(12) << weights\_crs\_[ii] << std::endl;
01037   \}
01038   std::cout << std::endl;
01039 \textcolor{preprocessor}{  #endif}
01040 \textcolor{preprocessor}{}
01042   \textcolor{keywordflow}{if} (order\_accuracy\_ >= \hyperlink{group__c01-roots_ga0898eef2108473e44a5223932d571c31}{mtk::kCriticalOrderAccuracyDiv}) \{
01043 
01044     \textcolor{keywordtype}{int} minrow\_\{std::numeric\_limits<int>::infinity()\};
01045 
01046     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} norm\_\{\hyperlink{classmtk_1_1BLASAdapter_ab92440888b730863244c5d9479c11aca}{mtk::BLASAdapter::RealNRM2}(weights\_cbs\_,
      order\_accuracy\_)\};
01047     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} minnorm\_\{std::numeric\_limits<mtk::Real>::infinity()\};
01048 
01050 
01051     \hyperlink{classmtk_1_1DenseMatrix}{mtk::DenseMatrix} phi(order\_accuracy\_ + 1, order\_accuracy\_);
01052 
01053     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_ + 1; ++ii) \{
01054       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
01055         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*(order\_accuracy\_) + jj] = prem\_apps\_[ii*dim\_null\_ + jj];
01056       \}
01057     \}
01058 
01059     \textcolor{keywordtype}{int} aux\{\};  \textcolor{comment}{// Auxiliary variable.}
01060     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_; jj < dim\_null\_ + 2; ++jj) \{
01061       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01062         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(ii + aux)*order\_accuracy\_ + jj] = coeffs\_interior\_[ii];
01063       \}
01064       ++aux;
01065     \}
01066 
01067     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj=order\_accuracy\_ - 1; jj >=order\_accuracy\_ - dim\_null\_; jj--) \{
01068       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii=0; ii<order\_accuracy\_ + 1; ++ii) \{
01069         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*order\_accuracy\_+jj] = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01070       \}
01071     \}
01072 
01073     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < order\_accuracy\_ + 1; ++jj) \{
01074       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01075         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(ii + order\_accuracy\_ - dim\_null\_ + jj*order\_accuracy\_)] =
01076           -prem\_apps\_[(dim\_null\_ - ii - 1 + jj*dim\_null\_)];
01077       \}
01078     \}
01079 
01080     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_/2; ++ii) \{
01081       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = dim\_null\_ + 2; jj < order\_accuracy\_; ++jj) \{
01082         \textcolor{keyword}{auto} swap = phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*order\_accuracy\_+jj];
01083         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[ii*order\_accuracy\_ + jj] =
01084           phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(order\_accuracy\_-ii)*order\_accuracy\_+jj];
01085         phi.\hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}()[(order\_accuracy\_-ii)*order\_accuracy\_+jj] = swap;
01086       \}
01087     \}
01088 
01089 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01090 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Constructed PHI matrix for CBS Algorithm: "} << std::endl;
01091     std::cout << phi << std::endl;
01092 \textcolor{preprocessor}{    #endif}
01093 \textcolor{preprocessor}{}
01095 
01096     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lamed\{\};  \textcolor{comment}{// Used to build big lambda.}
01097 
01098     \textcolor{keywordflow}{try} \{
01099       lamed = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01100     \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01101       std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01102         std::endl;
01103       std::cerr << memory\_allocation\_exception.what() << std::endl;
01104     \}
01105     memset(lamed, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lamed[0])*dim\_null\_);
01106 
01107     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01108       lamed[ii] = hh[ii + order\_accuracy\_ + 1] ;
01109     \}
01110 
01111 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01112 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"lamed ="} << std::endl;
01113     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01114       std::cout << std::setw(12) << lamed[ii] << std::endl;
01115     \}
01116     std::cout << std::endl;
01117 \textcolor{preprocessor}{    #endif}
01118 \textcolor{preprocessor}{}
01119     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01120       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} temp = \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero};
01121       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
01122         temp = temp +
01123           lamed[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01124       \}
01125       hh[ii] = hh[ii] - temp;
01126     \}
01127 
01128 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01129 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"big\_lambda ="} << std::endl;
01130     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01131       std::cout << std::setw(12) << hh[ii] << std::endl;
01132     \}
01133     std::cout << std::endl;
01134 \textcolor{preprocessor}{    #endif}
01135 \textcolor{preprocessor}{}
01136     \textcolor{keywordtype}{int} copy\_result\{\};
01137 
01138     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} normerr\_; \textcolor{comment}{// Norm of the error for the solution on each row.}
01139 
01141 
01142     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} row\_= 0; row\_ < order\_accuracy\_ + 1; ++row\_) \{
01143       normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}(),
01144                                                           order\_accuracy\_ + 1,
01145                                                           order\_accuracy\_,
01146                                                           order\_accuracy\_,
01147                                                           hh,
01148                                                           weights\_cbs\_,
01149                                                           row\_,
01150                                                           mimetic\_threshold\_,
01151                                                           copy\_result);
01152       \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\{normerr\_/norm\_\};
01153 
01154 \textcolor{preprocessor}{      #if MTK\_DEBUG\_LEVEL>0}
01155 \textcolor{preprocessor}{}      std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux << \textcolor{stringliteral}{" "} << std::endl;
01156       std::cout << std::endl;
01157 \textcolor{preprocessor}{      #endif}
01158 \textcolor{preprocessor}{}
01159       \textcolor{keywordflow}{if} (aux < minnorm\_) \{
01160         minnorm\_ = aux;
01161         minrow\_= row\_;
01162       \}
01163     \}
01164 
01165 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01166 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda (after brute force search):"} <<
01167       std::endl;
01168     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01169       std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01170     \}
01171     std::cout << std::endl;
01172 \textcolor{preprocessor}{    #endif}
01173 \textcolor{preprocessor}{}
01175 
01176     \textcolor{comment}{// After we know which row yields the smallest relative norm that row is}
01177     \textcolor{comment}{// chosen to be the objective function and the result of the optimizer is}
01178     \textcolor{comment}{// chosen to be the new weights\_.}
01179 
01180 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01181 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Minimum Relative Norm "} << minnorm\_ << \textcolor{stringliteral}{" found at row "} <<
01182       minrow\_ + 1 << std::endl;
01183     std::cout << std::endl;
01184 \textcolor{preprocessor}{    #endif}
01185 \textcolor{preprocessor}{}
01186     copy\_result = 1;
01187     normerr\_ = \hyperlink{classmtk_1_1GLPKAdapter_a834480aca83e3c0d09fdab7fdb7e8a3f}{mtk::GLPKAdapter::SolveSimplexAndCompare}(phi.
      \hyperlink{classmtk_1_1DenseMatrix_a16b3ff56feb2658b9fc7147d1de4d8e7}{data}(),
01188                                                         order\_accuracy\_ + 1,
01189                                                         order\_accuracy\_,
01190                                                         order\_accuracy\_,
01191                                                         hh,
01192                                                         weights\_cbs\_,
01193                                                         minrow\_,
01194                                                         mimetic\_threshold\_,
01195                                                         copy\_result);
01196     \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} aux\_\{normerr\_/norm\_\};
01197 \textcolor{preprocessor}{    #if MTK\_DEBUG\_LEVEL > 0}
01198 \textcolor{preprocessor}{}    std::cout << \textcolor{stringliteral}{"Relative norm: "} << aux\_ << std::endl;
01199     std::cout << std::endl;
01200 \textcolor{preprocessor}{    #endif}
01201 \textcolor{preprocessor}{}
01202     \textcolor{keyword}{delete} [] lamed;
01203     lamed = \textcolor{keyword}{nullptr};
01204   \}
01205 
01206   \textcolor{keyword}{delete} [] hh;
01207   hh = \textcolor{keyword}{nullptr};
01208 
01209   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01210 \}
01211 
\hypertarget{mtk__div__1d_8cc_source_l01212}{}\hyperlink{classmtk_1_1Div1D_a29bb417c76286414dce9258a0bcb5aab}{01212} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_a29bb417c76286414dce9258a0bcb5aab}{mtk::Div1D::ComputeStencilBoundaryGrid}(\textcolor{keywordtype}{void}) \{
01213 
01214 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01215 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"weights\_CBSA + lambda ="} << std::endl;
01216   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_ - 1; ++ii) \{
01217     std::cout << std::setw(12) << weights\_cbs\_[ii] << std::endl;
01218   \}
01219   std::cout << std::endl;
01220 \textcolor{preprocessor}{  #endif}
01221 \textcolor{preprocessor}{}
01223 
01224   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *lambda\{\}; \textcolor{comment}{// Collection of bottom values from weights\_.}
01225 
01226   \textcolor{keywordflow}{try} \{
01227     lambda = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01228   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01229     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01230       std::endl;
01231     std::cerr << memory\_allocation\_exception.what() << std::endl;
01232   \}
01233   memset(lambda, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(lambda[0])*dim\_null\_);
01234 
01235   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01236     lambda[ii] = weights\_cbs\_[order\_accuracy\_ + ii];
01237   \}
01238 
01239 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01240 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"lambda ="} << std::endl;
01241   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01242     std::cout << std::setw(12) << lambda[ii] << std::endl;
01243   \}
01244   std::cout << std::endl;
01245 \textcolor{preprocessor}{  #endif}
01246 \textcolor{preprocessor}{}
01248 
01249   \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real} *alpha\{\}; \textcolor{comment}{// Collection of alpha values.}
01250 
01251   \textcolor{keywordflow}{try} \{
01252     alpha = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[dim\_null\_];
01253   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01254     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01255       std::endl;
01256     std::cerr << memory\_allocation\_exception.what() << std::endl;
01257   \}
01258   memset(alpha, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(alpha[0])*dim\_null\_);
01259 
01260   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01261     alpha[ii] = lambda[ii]/weights\_cbs\_[ii] ;
01262   \}
01263 
01264 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01265 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"alpha ="} << std::endl;
01266   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01267     std::cout << std::setw(12) << alpha[ii] << std::endl;
01268   \}
01269   std::cout << std::endl;
01270 \textcolor{preprocessor}{  #endif}
01271 \textcolor{preprocessor}{}
01273 
01274   \textcolor{keywordflow}{try} \{
01275     mim\_bndy\_ = \textcolor{keyword}{new} \hyperlink{group__c01-roots_gac080bbbf5cbb5502c9f00405f894857d}{mtk::Real}[num\_bndy\_coeffs\_*dim\_null\_];
01276   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01277     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01278       std::endl;
01279     std::cerr << memory\_allocation\_exception.what() << std::endl;
01280   \}
01281   memset(mim\_bndy\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(mim\_bndy\_[0])*num\_bndy\_coeffs\_*dim\_null\_);
01282 
01283   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01284     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
01285       mim\_bndy\_[ii*dim\_null\_ + jj] =
01286         prem\_apps\_[ii*dim\_null\_ + jj] +
01287         alpha[jj]*rat\_basis\_null\_space\_.data()[jj*num\_bndy\_coeffs\_ + ii];
01288     \}
01289   \}
01290 
01291 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL >0}
01292 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"Collection of mimetic approximations:"} << std::endl;
01293   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < num\_bndy\_coeffs\_; ++ii) \{
01294     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < dim\_null\_; ++jj) \{
01295       std::cout << std::setw(13) << mim\_bndy\_[ii*dim\_null\_ + jj];
01296     \}
01297     std::cout << std::endl;
01298   \}
01299   std::cout << std::endl;
01300 \textcolor{preprocessor}{  #endif}
01301 \textcolor{preprocessor}{}
01302   \textcolor{keyword}{delete}[] lambda;
01303   lambda = \textcolor{keyword}{nullptr};
01304 
01305   \textcolor{keyword}{delete}[] alpha;
01306   alpha = \textcolor{keyword}{nullptr};
01307 
01308   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01309 \}
01310 
\hypertarget{mtk__div__1d_8cc_source_l01311}{}\hyperlink{classmtk_1_1Div1D_a5a12482e1ceac232339dd8f647af886b}{01311} \textcolor{keywordtype}{bool} \hyperlink{classmtk_1_1Div1D_a5a12482e1ceac232339dd8f647af886b}{mtk::Div1D::AssembleOperator}(\textcolor{keywordtype}{void}) \{
01312 
01313   \textcolor{comment}{// The output array will have this form:}
01314   \textcolor{comment}{// 1. The first entry of the array will contain the used order order\_accuracy\_.}
01315   \textcolor{comment}{// 2. The second entry of the array will contain the collection of}
01316   \textcolor{comment}{// approximating coefficients for the interior of the grid.}
01317   \textcolor{comment}{// 3. IF order\_accuracy\_ > 2, then the third entry will contain a collection of weights.}
01318   \textcolor{comment}{// 4. IF order\_accuracy\_ > 2, the next dim\_null\_ entries will contain the collections of}
01319   \textcolor{comment}{// approximating coefficients for the west boundary of the grid.}
01320 
01321   \textcolor{keywordflow}{if} (order\_accuracy\_ > \hyperlink{group__c01-roots_ga0d95560098eb36420511103637b6952f}{mtk::kDefaultOrderAccuracy}) \{
01322     divergence\_length\_ =
01323       1 + order\_accuracy\_ + order\_accuracy\_ + dim\_null\_*num\_bndy\_coeffs\_;
01324   \} \textcolor{keywordflow}{else} \{
01325     divergence\_length\_ = 1 + order\_accuracy\_;
01326   \}
01327 
01328 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01329 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"divergence\_length\_ = "} << divergence\_length\_ << std::endl;
01330 \textcolor{preprocessor}{  #endif}
01331 \textcolor{preprocessor}{}
01332   \textcolor{keywordflow}{try} \{
01333     divergence\_ = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[divergence\_length\_];
01334   \} \textcolor{keywordflow}{catch} (std::bad\_alloc &memory\_allocation\_exception) \{
01335     std::cerr << \textcolor{stringliteral}{"Memory allocation exception on line "} << \_\_LINE\_\_ - 3 <<
01336       std::endl;
01337     std::cerr << memory\_allocation\_exception.what() << std::endl;
01338   \}
01339   memset(divergence\_, \hyperlink{group__c01-roots_ga59a451a5fae30d59649bcda274fea271}{mtk::kZero}, \textcolor{keyword}{sizeof}(divergence\_[0])*divergence\_length\_);
01340 
01342 
01343   divergence\_[0] = order\_accuracy\_;
01344 
01346 
01347   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01348   divergence\_[ii + 1] = coeffs\_interior\_[ii];
01349   \}
01350 
01352 
01353   \textcolor{keywordflow}{if} (order\_accuracy\_ > 2) \{
01354     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < order\_accuracy\_; ++ii) \{
01355       divergence\_[(1 + order\_accuracy\_) + ii] = weights\_cbs\_[ii];
01356     \}
01357   \}
01358 
01361 
01362   \textcolor{keywordflow}{if} (order\_accuracy\_ > 2) \{
01363     \textcolor{keyword}{auto} offset = (2*order\_accuracy\_ + 1);
01364     \textcolor{keywordtype}{int} mm\{\};
01365     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ii = 0; ii < dim\_null\_; ++ii) \{
01366       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} jj = 0; jj < num\_bndy\_coeffs\_; ++jj) \{
01367         divergence\_[offset + (mm)] = mim\_bndy\_[jj*dim\_null\_ + ii];
01368         ++mm;
01369       \}
01370     \}
01371   \}
01372 
01373 \textcolor{preprocessor}{  #if MTK\_DEBUG\_LEVEL > 0}
01374 \textcolor{preprocessor}{}  std::cout << \textcolor{stringliteral}{"1D "} << order\_accuracy\_ << \textcolor{stringliteral}{"-order div built!"} << std::endl;
01375   std::cout << std::endl;
01376 \textcolor{preprocessor}{  #endif}
01377 \textcolor{preprocessor}{}
01378   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01379 \}
\end{DoxyCode}
