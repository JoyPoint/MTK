.TH "mtk::BCDescriptor2D" 3 "Mon Nov 23 2015" "MTK: Mimetic Methods Toolkit" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mtk::BCDescriptor2D \- 
.PP
Enforces boundary conditions in either the operator or the grid\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <mtk_bc_descriptor_2d\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBCDescriptor2D\fP ()"
.br
.RI "\fIDefault constructor\&. \fP"
.ti -1c
.RI "\fBBCDescriptor2D\fP (const \fBBCDescriptor2D\fP &desc)"
.br
.RI "\fICopy constructor\&. \fP"
.ti -1c
.RI "\fB~BCDescriptor2D\fP () noexcept"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_west\fP () const noexcept"
.br
.RI "\fIGetter for the highest order of differentiation in the west boundary\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_east\fP () const noexcept"
.br
.RI "\fIGetter for the highest order of differentiation in the east boundary\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_south\fP () const noexcept"
.br
.RI "\fIGetter for the highest order of differentiation in the south boundary\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_north\fP () const noexcept"
.br
.RI "\fIGetter for the highest order of differentiation in the north boundary\&. \fP"
.ti -1c
.RI "void \fBPushBackWestCoeff\fP (\fBCoefficientFunction2D\fP cw)"
.br
.RI "\fIPush back coefficient function at west of lowest order diff\&. available\&. \fP"
.ti -1c
.RI "void \fBPushBackEastCoeff\fP (\fBCoefficientFunction2D\fP ce)"
.br
.RI "\fIPush back coefficient function at east of lowest order diff\&. available\&. \fP"
.ti -1c
.RI "void \fBPushBackSouthCoeff\fP (\fBCoefficientFunction2D\fP cs)"
.br
.RI "\fIPush back coefficient function south of lowest order diff\&. available\&. \fP"
.ti -1c
.RI "void \fBPushBackNorthCoeff\fP (\fBCoefficientFunction2D\fP cn)"
.br
.RI "\fIPush back coefficient function north of lowest order diff\&. available\&. \fP"
.ti -1c
.RI "void \fBset_west_condition\fP (\fBReal\fP(*west_condition)(\fBReal\fP xx, \fBReal\fP yy)) noexcept"
.br
.RI "\fISet boundary condition at west\&. \fP"
.ti -1c
.RI "void \fBset_east_condition\fP (\fBReal\fP(*east_condition)(\fBReal\fP xx, \fBReal\fP yy)) noexcept"
.br
.RI "\fISet boundary condition at east\&. \fP"
.ti -1c
.RI "void \fBset_south_condition\fP (\fBReal\fP(*south_condition)(\fBReal\fP xx, \fBReal\fP yy)) noexcept"
.br
.RI "\fISet boundary condition at south\&. \fP"
.ti -1c
.RI "void \fBset_north_condition\fP (\fBReal\fP(*north_condition)(\fBReal\fP xx, \fBReal\fP yy)) noexcept"
.br
.RI "\fISet boundary condition at north\&. \fP"
.ti -1c
.RI "void \fBImposeOnLaplacianMatrix\fP (const \fBUniStgGrid2D\fP &grid, \fBDenseMatrix\fP &matrix, const int &order_accuracy=2) const "
.br
.RI "\fIImposes the condition on the operator represented as matrix\&. \fP"
.ti -1c
.RI "void \fBImposeOnGrid\fP (\fBUniStgGrid2D\fP &grid) const "
.br
.RI "\fIImposes the condition on the grid\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBImposeOnSouthBoundaryNoSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the south boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnNorthBoundaryNoSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the north boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnWestBoundaryNoSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the west boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnEastBoundaryNoSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the east boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnSouthBoundaryWithSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the south boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnNorthBoundaryWithSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the north boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnWestBoundaryWithSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the west boundary\&. \fP"
.ti -1c
.RI "void \fBImposeOnEastBoundaryWithSpace\fP (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const "
.br
.RI "\fIImposes the condition on the east boundary\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBgenerate_space_\fP"
.br
.RI "\fIShould I generate coordinates as evaluate? \fP"
.ti -1c
.RI "int \fBhighest_order_diff_west_\fP"
.br
.RI "\fIHighest order of differentiation for west\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_east_\fP"
.br
.RI "\fIHighest order of differentiation for east\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_south_\fP"
.br
.RI "\fIHighest order differentiation for south\&. \fP"
.ti -1c
.RI "int \fBhighest_order_diff_north_\fP"
.br
.RI "\fIHighest order differentiation for north\&. \fP"
.ti -1c
.RI "std::vector
.br
< \fBCoefficientFunction2D\fP > \fBwest_coefficients_\fP"
.br
.RI "\fICoeffs\&. west\&. \fP"
.ti -1c
.RI "std::vector
.br
< \fBCoefficientFunction2D\fP > \fBeast_coefficients_\fP"
.br
.RI "\fICoeffs\&. east\&. \fP"
.ti -1c
.RI "std::vector
.br
< \fBCoefficientFunction2D\fP > \fBsouth_coefficients_\fP"
.br
.RI "\fICoeffs\&. south\&. \fP"
.ti -1c
.RI "std::vector
.br
< \fBCoefficientFunction2D\fP > \fBnorth_coefficients_\fP"
.br
.RI "\fICoeffs\&. south\&. \fP"
.ti -1c
.RI "\fBReal\fP(* \fBwest_condition_\fP )(\fBReal\fP xx, \fBReal\fP yy)"
.br
.RI "\fICondition for west\&. \fP"
.ti -1c
.RI "\fBReal\fP(* \fBeast_condition_\fP )(\fBReal\fP xx, \fBReal\fP yy)"
.br
.RI "\fICondition for east\&. \fP"
.ti -1c
.RI "\fBReal\fP(* \fBsouth_condition_\fP )(\fBReal\fP xx, \fBReal\fP yy)"
.br
.RI "\fICondition for south\&. \fP"
.ti -1c
.RI "\fBReal\fP(* \fBnorth_condition_\fP )(\fBReal\fP xx, \fBReal\fP yy)"
.br
.RI "\fICondition for north\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This class presents an interface for the user to specify boundary conditions on 2D mimetic operators and the grids they are acting on\&.
.PP
\fBDef\&.\fP Let $ f $ be any scalar or vector field defined over a domain $ \Omega $\&. We can specify any linear combination of $ f $ and its $ n $ derivatives to fulfill a condition, which we define as a \fBboundary condition\fP:
.PP
\[ \forall \mathbf{x} \in \partial\Omega: \sum_{i = 0}^{n} c_i(\mathbf{x}) <\hat{\mathbf{n}}, \frac{\partial^i f}{\partial x^i}(\mathbf{x})> = \beta(\mathbf{x}). \].PP
This class receives information about the highest-order of differentiation, $ n $, all possible coefficient functions, $ c_i(\mathbf{x}) $ for any subset of the boundary (south, north, west and east), and each condition for any subset of the boundary, and takes care of assigning them to both, the differentiation matrices and the grids\&. 
.PP
Definition at line 123 of file mtk_bc_descriptor_2d\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mtk::BCDescriptor2D::BCDescriptor2D ()"

.PP
Definition at line 80 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "mtk::BCDescriptor2D::BCDescriptor2D (const \fBBCDescriptor2D\fP &desc)"

.PP
\fBParameters:\fP
.RS 4
\fIdesc\fP Given 2D descriptor\&. 
.RE
.PP

.PP
Definition at line 91 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "mtk::BCDescriptor2D::~BCDescriptor2D ()\fC [noexcept]\fP"

.PP
Definition at line 93 of file mtk_bc_descriptor_2d\&.cc\&.
.SH "Member Function Documentation"
.PP 
.SS "int mtk::BCDescriptor2D::highest_order_diff_east () const\fC [noexcept]\fP"

.PP
\fBReturns:\fP
.RS 4
Integer highest order of differentiation in the east boundary\&. 
.RE
.PP

.PP
Definition at line 100 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_north () const\fC [noexcept]\fP"

.PP
\fBReturns:\fP
.RS 4
Integer highest order of differentiation in the north boundary\&. 
.RE
.PP

.PP
Definition at line 110 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_south () const\fC [noexcept]\fP"

.PP
\fBReturns:\fP
.RS 4
Integer highest order of differentiation in the south boundary\&. 
.RE
.PP

.PP
Definition at line 105 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_west () const\fC [noexcept]\fP"

.PP
\fBReturns:\fP
.RS 4
Integer highest order of differentiation in the west boundary\&. 
.RE
.PP

.PP
Definition at line 95 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnEastBoundaryNoSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 467 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnEastBoundaryWithSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 537 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnGrid (\fBmtk::UniStgGrid2D\fP &grid) const"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.RE
.PP

.IP "1." 4
Impose assuming an scalar grid\&.
.PP
.PP
1\&.1\&. Impose south condition\&.
.PP
1\&.1\&.1\&. Impose south-west corner\&.
.PP
1\&.1\&.2\&. Impose south border\&.
.PP
1\&.1\&.3\&. Impose south-east corner\&.
.PP
1\&.2\&. Impose north condition\&.
.PP
1\&.2\&.1\&. Impose north-west corner\&.
.PP
1\&.2\&.2\&. Impose north border\&.
.PP
1\&.2\&.3\&. Impose north-east corner\&.
.PP
1\&.3\&. Impose west condition\&.
.PP
1\&.3\&.1\&. Impose south-west corner\&. 
.PP
\fBNote:\fP
.RS 4
As per discussion with Otilio, we will take the \fBarithmetic\fP \fBmean\fP of the values of the BCs at the corners\&.
.RE
.PP
1\&.3\&.2\&. Impose west border\&.
.PP
1\&.3\&.3\&. Impose north-west corner\&.
.PP
1\&.4\&. Impose east condition\&.
.PP
1\&.4\&.1\&. Impose south-east corner\&.
.PP
1\&.4\&.2\&. Impose east border\&.
.PP
1\&.4\&.3\&. Impose north-east corner\&.
.PP
.IP "2." 4
Impose assuming a vector grid\&.
.PP
.PP
\fBTodo\fP
.RS 4
Implement imposition for vector-valued grids\&. 
.RE
.PP

.PP
Definition at line 596 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnLaplacianMatrix (const \fBUniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy = \fC2\fP) const"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP
If we have not bound anything to the grid, then we have to generate our collection of spatial coordinates, as we evaluate the coefficients\&. 
.PP
Definition at line 558 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnNorthBoundaryNoSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 291 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnNorthBoundaryWithSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose Dirichlet condition\&.
.PP
.PP
For each entry on the diagonal:
.PP
Evaluate next set spatial coordinates to evaluate the coefficient\&.
.PP
Evaluate and assign the Dirichlet coefficient\&.
.PP
.IP "2." 4
Impose the Neumann condition\&. 
.PP

.PP
Definition at line 355 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnSouthBoundaryNoSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.IP "2." 4
Impose the Neumann condition second\&.
.PP
.PP
\fBTodo\fP
.RS 4
Impose the Neumann conditions on every pole, for every scenario\&. 
.RE
.PP

.PP
Definition at line 209 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnSouthBoundaryWithSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.PP
.PP
\fBTodo\fP
.RS 4
Impose Harmonic mean on the corners for the case when the generated space is available, for all poles\&. 
.RE
.PP
.PP
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 269 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnWestBoundaryNoSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.PP
.PP
\fBNote:\fP
.RS 4
As it can be seen, we must adopt a convention about how to treat the corners\&. Based on a reasoning with Otilio, we will take the \fBharmonic mean\fP\&.
.RE
.PP
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 376 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::ImposeOnWestBoundaryWithSpace (const \fBmtk::UniStgGrid2D\fP &grid, \fBmtk::DenseMatrix\fP &matrix, const int &order_accuracy) const\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIgrid\fP Grid upon which impose the desired boundary condition\&. 
.br
\fImatrix\fP Input Laplacian operator\&. 
.br
\fIorder_accuracy\fP Order of accuracy of the operator in the \fBMatrix\fP\&. 
.RE
.PP

.IP "1." 4
Impose the Dirichlet condition first\&.
.IP "2." 4
Impose the Neumann condition second\&. 
.PP

.PP
Definition at line 446 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::PushBackEastCoeff (\fBmtk::CoefficientFunction2D\fPce)"

.PP
\fBParameters:\fP
.RS 4
\fIce\fP Function $ c_e(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 128 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::PushBackNorthCoeff (\fBmtk::CoefficientFunction2D\fPcn)"

.PP
\fBParameters:\fP
.RS 4
\fIcn\fP Function $ c_n(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 154 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::PushBackSouthCoeff (\fBmtk::CoefficientFunction2D\fPcs)"

.PP
\fBParameters:\fP
.RS 4
\fIcs\fP Function $ c_s(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 141 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::PushBackWestCoeff (\fBmtk::CoefficientFunction2D\fPcw)"

.PP
\fBParameters:\fP
.RS 4
\fIcw\fP Function $ c_w(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 115 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::set_east_condition (\fBReal\fP(*)(\fBReal\fP xx, \fBReal\fP yy)east_condition)\fC [noexcept]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIeast_condition\fP $ \beta_e(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 177 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::set_north_condition (\fBReal\fP(*)(\fBReal\fP xx, \fBReal\fP yy)north_condition)\fC [noexcept]\fP"

.PP
\fBParameters:\fP
.RS 4
\fInorth_condition\fP $ \beta_n(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 198 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::set_south_condition (\fBReal\fP(*)(\fBReal\fP xx, \fBReal\fP yy)south_condition)\fC [noexcept]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIsouth_condition\fP $ \beta_s(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 187 of file mtk_bc_descriptor_2d\&.cc\&.
.SS "void mtk::BCDescriptor2D::set_west_condition (\fBReal\fP(*)(\fBReal\fP xx, \fBReal\fP yy)west_condition)\fC [noexcept]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIwest_condition\fP $ \beta_w(x,y):\Omega\mapsto\mathbb{R} $\&. 
.RE
.PP

.PP
Definition at line 167 of file mtk_bc_descriptor_2d\&.cc\&.
.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBCoefficientFunction2D\fP> mtk::BCDescriptor2D::east_coefficients_\fC [private]\fP"

.PP
Definition at line 330 of file mtk_bc_descriptor_2d\&.h\&.
.SS "\fBReal\fP(* mtk::BCDescriptor2D::east_condition_)(\fBReal\fP xx, \fBReal\fP yy)\fC [private]\fP"

.PP
Definition at line 335 of file mtk_bc_descriptor_2d\&.h\&.
.SS "bool mtk::BCDescriptor2D::generate_space_\fC [mutable]\fP, \fC [private]\fP"

.PP
Definition at line 322 of file mtk_bc_descriptor_2d\&.h\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_east_\fC [private]\fP"

.PP
Definition at line 325 of file mtk_bc_descriptor_2d\&.h\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_north_\fC [private]\fP"

.PP
Definition at line 327 of file mtk_bc_descriptor_2d\&.h\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_south_\fC [private]\fP"

.PP
Definition at line 326 of file mtk_bc_descriptor_2d\&.h\&.
.SS "int mtk::BCDescriptor2D::highest_order_diff_west_\fC [private]\fP"

.PP
Definition at line 324 of file mtk_bc_descriptor_2d\&.h\&.
.SS "std::vector<\fBCoefficientFunction2D\fP> mtk::BCDescriptor2D::north_coefficients_\fC [private]\fP"

.PP
Definition at line 332 of file mtk_bc_descriptor_2d\&.h\&.
.SS "\fBReal\fP(* mtk::BCDescriptor2D::north_condition_)(\fBReal\fP xx, \fBReal\fP yy)\fC [private]\fP"

.PP
Definition at line 337 of file mtk_bc_descriptor_2d\&.h\&.
.SS "std::vector<\fBCoefficientFunction2D\fP> mtk::BCDescriptor2D::south_coefficients_\fC [private]\fP"

.PP
Definition at line 331 of file mtk_bc_descriptor_2d\&.h\&.
.SS "\fBReal\fP(* mtk::BCDescriptor2D::south_condition_)(\fBReal\fP xx, \fBReal\fP yy)\fC [private]\fP"

.PP
Definition at line 336 of file mtk_bc_descriptor_2d\&.h\&.
.SS "std::vector<\fBCoefficientFunction2D\fP> mtk::BCDescriptor2D::west_coefficients_\fC [private]\fP"

.PP
Definition at line 329 of file mtk_bc_descriptor_2d\&.h\&.
.SS "\fBReal\fP(* mtk::BCDescriptor2D::west_condition_)(\fBReal\fP xx, \fBReal\fP yy)\fC [private]\fP"

.PP
Definition at line 334 of file mtk_bc_descriptor_2d\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MTK: Mimetic Methods Toolkit from the source code\&.
